#[allow(unused_imports)]
use progenitor_client::{encode_path, ClientHooks, OperationInfo, RequestBuilderExt};
#[allow(unused_imports)]
pub use progenitor_client::{ByteStream, ClientInfo, Error, ResponseValue};
/// Types used as operation parameters and responses.
#[allow(clippy::all)]
pub mod types {
    /// Error types.
    pub mod error {
        /// Error from a `TryFrom` or `FromStr` implementation.
        pub struct ConversionError(::std::borrow::Cow<'static, str>);
        impl ::std::error::Error for ConversionError {}
        impl ::std::fmt::Display for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Display::fmt(&self.0, f)
            }
        }

        impl ::std::fmt::Debug for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Debug::fmt(&self.0, f)
            }
        }

        impl From<&'static str> for ConversionError {
            fn from(value: &'static str) -> Self {
                Self(value.into())
            }
        }

        impl From<String> for ConversionError {
            fn from(value: String) -> Self {
                Self(value.into())
            }
        }
    }

    ///`Address`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "city": {
    ///      "type": "string"
    ///    },
    ///    "country": {
    ///      "description": "A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.",
    ///      "type": "string"
    ///    },
    ///    "postalCode": {
    ///      "description": "A postal code. This field may be required if the
    /// provided country has a postal code system.",
    ///      "type": "string"
    ///    },
    ///    "streetAndNumber": {
    ///      "description": "A street and street number.",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Address {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub city: ::std::option::Option<::std::string::String>,
        ///A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub country: ::std::option::Option<::std::string::String>,
        ///A postal code. This field may be required if the provided country
        /// has a postal code system.
        #[serde(
            rename = "postalCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub postal_code: ::std::option::Option<::std::string::String>,
        ///A street and street number.
        #[serde(
            rename = "streetAndNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub street_and_number: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&Address> for Address {
        fn from(value: &Address) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for Address {
        fn default() -> Self {
            Self {
                city: Default::default(),
                country: Default::default(),
                postal_code: Default::default(),
                street_and_number: Default::default(),
            }
        }
    }

    ///In v2 endpoints, monetary amounts are represented as objects with a
    /// `currency` and `value` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "In v2 endpoints, monetary amounts are represented as
    /// objects with a `currency` and `value` field.",
    ///  "type": "object",
    ///  "required": [
    ///    "currency",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "currency": {
    ///      "description": "A three-character ISO 4217 currency code.",
    ///      "examples": [
    ///        "EUR"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "value": {
    ///      "description": "A string containing an exact monetary amount in the
    /// given currency.",
    ///      "examples": [
    ///        "10.00"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Amount {
        ///A three-character ISO 4217 currency code.
        pub currency: ::std::string::String,
        ///A string containing an exact monetary amount in the given currency.
        pub value: ::std::string::String,
    }

    impl ::std::convert::From<&Amount> for Amount {
        fn from(value: &Amount) -> Self {
            value.clone()
        }
    }

    ///In v2 endpoints, monetary amounts are represented as objects with a
    /// `currency` and `value` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "In v2 endpoints, monetary amounts are represented as
    /// objects with a `currency` and `value` field.",
    ///  "type": [
    ///    "object",
    ///    "null"
    ///  ],
    ///  "required": [
    ///    "currency",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "currency": {
    ///      "description": "A three-character ISO 4217 currency code.",
    ///      "examples": [
    ///        "EUR"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "value": {
    ///      "description": "A string containing an exact monetary amount in the
    /// given currency.",
    ///      "examples": [
    ///        "10.00"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct AmountNullable(pub ::std::option::Option<AmountNullableInner>);
    impl ::std::ops::Deref for AmountNullable {
        type Target = ::std::option::Option<AmountNullableInner>;
        fn deref(&self) -> &::std::option::Option<AmountNullableInner> {
            &self.0
        }
    }

    impl ::std::convert::From<AmountNullable> for ::std::option::Option<AmountNullableInner> {
        fn from(value: AmountNullable) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&AmountNullable> for AmountNullable {
        fn from(value: &AmountNullable) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<AmountNullableInner>> for AmountNullable {
        fn from(value: ::std::option::Option<AmountNullableInner>) -> Self {
            Self(value)
        }
    }

    ///In v2 endpoints, monetary amounts are represented as objects with a
    /// `currency` and `value` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "In v2 endpoints, monetary amounts are represented as
    /// objects with a `currency` and `value` field.",
    ///  "type": "object",
    ///  "required": [
    ///    "currency",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "currency": {
    ///      "description": "A three-character ISO 4217 currency code.",
    ///      "examples": [
    ///        "EUR"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "value": {
    ///      "description": "A string containing an exact monetary amount in the
    /// given currency.",
    ///      "examples": [
    ///        "10.00"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmountNullableInner {
        ///A three-character ISO 4217 currency code.
        pub currency: ::std::string::String,
        ///A string containing an exact monetary amount in the given currency.
        pub value: ::std::string::String,
    }

    impl ::std::convert::From<&AmountNullableInner> for AmountNullableInner {
        fn from(value: &AmountNullableInner) -> Self {
            value.clone()
        }
    }

    ///`BalanceReportGrouping`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "status-balances"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "status-balances",
    ///    "transaction-categories"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BalanceReportGrouping {
        #[serde(rename = "status-balances")]
        StatusBalances,
        #[serde(rename = "transaction-categories")]
        TransactionCategories,
    }

    impl ::std::convert::From<&Self> for BalanceReportGrouping {
        fn from(value: &BalanceReportGrouping) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BalanceReportGrouping {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::StatusBalances => f.write_str("status-balances"),
                Self::TransactionCategories => f.write_str("transaction-categories"),
            }
        }
    }

    impl ::std::str::FromStr for BalanceReportGrouping {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "status-balances" => Ok(Self::StatusBalances),
                "transaction-categories" => Ok(Self::TransactionCategories),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for BalanceReportGrouping {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for BalanceReportGrouping {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for BalanceReportGrouping {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The status of the balance.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status of the balance.",
    ///  "examples": [
    ///    "active"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "active",
    ///    "inactive"
    ///  ],
    ///  "x-enumDescriptions": {
    ///    "active": "The balance is operational and ready to be used.",
    ///    "inactive": "The account is being validated by our team, or the
    /// balance has been blocked. Contact us for more information."
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BalanceStatus {
        #[serde(rename = "active")]
        Active,
        #[serde(rename = "inactive")]
        Inactive,
    }

    impl ::std::convert::From<&Self> for BalanceStatus {
        fn from(value: &BalanceStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BalanceStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Active => f.write_str("active"),
                Self::Inactive => f.write_str("inactive"),
            }
        }
    }

    impl ::std::str::FromStr for BalanceStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "active" => Ok(Self::Active),
                "inactive" => Ok(Self::Inactive),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for BalanceStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for BalanceStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for BalanceStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`BalanceToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "bal_gVMhHKqSSRYJyPsuoPNFH"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct BalanceToken(pub ::std::string::String);
    impl ::std::ops::Deref for BalanceToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<BalanceToken> for ::std::string::String {
        fn from(value: BalanceToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&BalanceToken> for BalanceToken {
        fn from(value: &BalanceToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for BalanceToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for BalanceToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for BalanceToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`BalanceTransactionToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "baltr_QM24QwzUWR4ev4Xfgyt29d"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct BalanceTransactionToken(pub ::std::string::String);
    impl ::std::ops::Deref for BalanceTransactionToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<BalanceTransactionToken> for ::std::string::String {
        fn from(value: BalanceTransactionToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&BalanceTransactionToken> for BalanceTransactionToken {
        fn from(value: &BalanceTransactionToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for BalanceTransactionToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for BalanceTransactionToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for BalanceTransactionToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`BalanceTransactionType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "payment"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "application-fee",
    ///    "capture",
    ///    "chargeback",
    ///    "chargeback-reversal",
    ///    "failed-payment-fee",
    ///    "failed-payment",
    ///    "invoice-compensation",
    ///    "payment",
    ///    "payment-fee",
    ///    "payment-commission",
    ///    "refund",
    ///    "returned-refund",
    ///    "returned-transfer",
    ///    "split-payment",
    ///    "outgoing-transfer",
    ///    "capture-commission",
    ///    "canceled-outgoing-transfer",
    ///    "incoming-transfer",
    ///    "api-payment-rolling-reserve-release",
    ///    "capture-rolling-reserve-release",
    ///    "reimbursement-fee",
    ///    "balance-correction",
    ///    "unauthorized-direct-debit",
    ///    "bank-charged-failure-fee",
    ///    "platform-payment-refund",
    ///    "refund-compensation",
    ///    "returned-refund-compensation",
    ///    "returned-platform-payment-refund",
    ///    "platform-payment-chargeback",
    ///    "chargeback-compensation",
    ///    "reversed-platform-payment-chargeback",
    ///    "reversed-chargeback-compensation",
    ///    "failed-split-payment-platform",
    ///    "failed-split-payment-compensation",
    ///    "cash-advance-loan",
    ///    "platform-connected-organizations-fee",
    ///    "split-transaction",
    ///    "managed-fee",
    ///    "returned-managed-fee",
    ///    "topup",
    ///    "balance-reserve",
    ///    "balance-reserve-return",
    ///    "movement",
    ///    "post-payment-split-payment",
    ///    "cash-collateral-issuance",
    ///    "cash-collateral-release"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BalanceTransactionType {
        #[serde(rename = "application-fee")]
        ApplicationFee,
        #[serde(rename = "capture")]
        Capture,
        #[serde(rename = "chargeback")]
        Chargeback,
        #[serde(rename = "chargeback-reversal")]
        ChargebackReversal,
        #[serde(rename = "failed-payment-fee")]
        FailedPaymentFee,
        #[serde(rename = "failed-payment")]
        FailedPayment,
        #[serde(rename = "invoice-compensation")]
        InvoiceCompensation,
        #[serde(rename = "payment")]
        Payment,
        #[serde(rename = "payment-fee")]
        PaymentFee,
        #[serde(rename = "payment-commission")]
        PaymentCommission,
        #[serde(rename = "refund")]
        Refund,
        #[serde(rename = "returned-refund")]
        ReturnedRefund,
        #[serde(rename = "returned-transfer")]
        ReturnedTransfer,
        #[serde(rename = "split-payment")]
        SplitPayment,
        #[serde(rename = "outgoing-transfer")]
        OutgoingTransfer,
        #[serde(rename = "capture-commission")]
        CaptureCommission,
        #[serde(rename = "canceled-outgoing-transfer")]
        CanceledOutgoingTransfer,
        #[serde(rename = "incoming-transfer")]
        IncomingTransfer,
        #[serde(rename = "api-payment-rolling-reserve-release")]
        ApiPaymentRollingReserveRelease,
        #[serde(rename = "capture-rolling-reserve-release")]
        CaptureRollingReserveRelease,
        #[serde(rename = "reimbursement-fee")]
        ReimbursementFee,
        #[serde(rename = "balance-correction")]
        BalanceCorrection,
        #[serde(rename = "unauthorized-direct-debit")]
        UnauthorizedDirectDebit,
        #[serde(rename = "bank-charged-failure-fee")]
        BankChargedFailureFee,
        #[serde(rename = "platform-payment-refund")]
        PlatformPaymentRefund,
        #[serde(rename = "refund-compensation")]
        RefundCompensation,
        #[serde(rename = "returned-refund-compensation")]
        ReturnedRefundCompensation,
        #[serde(rename = "returned-platform-payment-refund")]
        ReturnedPlatformPaymentRefund,
        #[serde(rename = "platform-payment-chargeback")]
        PlatformPaymentChargeback,
        #[serde(rename = "chargeback-compensation")]
        ChargebackCompensation,
        #[serde(rename = "reversed-platform-payment-chargeback")]
        ReversedPlatformPaymentChargeback,
        #[serde(rename = "reversed-chargeback-compensation")]
        ReversedChargebackCompensation,
        #[serde(rename = "failed-split-payment-platform")]
        FailedSplitPaymentPlatform,
        #[serde(rename = "failed-split-payment-compensation")]
        FailedSplitPaymentCompensation,
        #[serde(rename = "cash-advance-loan")]
        CashAdvanceLoan,
        #[serde(rename = "platform-connected-organizations-fee")]
        PlatformConnectedOrganizationsFee,
        #[serde(rename = "split-transaction")]
        SplitTransaction,
        #[serde(rename = "managed-fee")]
        ManagedFee,
        #[serde(rename = "returned-managed-fee")]
        ReturnedManagedFee,
        #[serde(rename = "topup")]
        Topup,
        #[serde(rename = "balance-reserve")]
        BalanceReserve,
        #[serde(rename = "balance-reserve-return")]
        BalanceReserveReturn,
        #[serde(rename = "movement")]
        Movement,
        #[serde(rename = "post-payment-split-payment")]
        PostPaymentSplitPayment,
        #[serde(rename = "cash-collateral-issuance")]
        CashCollateralIssuance,
        #[serde(rename = "cash-collateral-release")]
        CashCollateralRelease,
    }

    impl ::std::convert::From<&Self> for BalanceTransactionType {
        fn from(value: &BalanceTransactionType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BalanceTransactionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ApplicationFee => f.write_str("application-fee"),
                Self::Capture => f.write_str("capture"),
                Self::Chargeback => f.write_str("chargeback"),
                Self::ChargebackReversal => f.write_str("chargeback-reversal"),
                Self::FailedPaymentFee => f.write_str("failed-payment-fee"),
                Self::FailedPayment => f.write_str("failed-payment"),
                Self::InvoiceCompensation => f.write_str("invoice-compensation"),
                Self::Payment => f.write_str("payment"),
                Self::PaymentFee => f.write_str("payment-fee"),
                Self::PaymentCommission => f.write_str("payment-commission"),
                Self::Refund => f.write_str("refund"),
                Self::ReturnedRefund => f.write_str("returned-refund"),
                Self::ReturnedTransfer => f.write_str("returned-transfer"),
                Self::SplitPayment => f.write_str("split-payment"),
                Self::OutgoingTransfer => f.write_str("outgoing-transfer"),
                Self::CaptureCommission => f.write_str("capture-commission"),
                Self::CanceledOutgoingTransfer => f.write_str("canceled-outgoing-transfer"),
                Self::IncomingTransfer => f.write_str("incoming-transfer"),
                Self::ApiPaymentRollingReserveRelease => {
                    f.write_str("api-payment-rolling-reserve-release")
                }
                Self::CaptureRollingReserveRelease => {
                    f.write_str("capture-rolling-reserve-release")
                }
                Self::ReimbursementFee => f.write_str("reimbursement-fee"),
                Self::BalanceCorrection => f.write_str("balance-correction"),
                Self::UnauthorizedDirectDebit => f.write_str("unauthorized-direct-debit"),
                Self::BankChargedFailureFee => f.write_str("bank-charged-failure-fee"),
                Self::PlatformPaymentRefund => f.write_str("platform-payment-refund"),
                Self::RefundCompensation => f.write_str("refund-compensation"),
                Self::ReturnedRefundCompensation => f.write_str("returned-refund-compensation"),
                Self::ReturnedPlatformPaymentRefund => {
                    f.write_str("returned-platform-payment-refund")
                }
                Self::PlatformPaymentChargeback => f.write_str("platform-payment-chargeback"),
                Self::ChargebackCompensation => f.write_str("chargeback-compensation"),
                Self::ReversedPlatformPaymentChargeback => {
                    f.write_str("reversed-platform-payment-chargeback")
                }
                Self::ReversedChargebackCompensation => {
                    f.write_str("reversed-chargeback-compensation")
                }
                Self::FailedSplitPaymentPlatform => f.write_str("failed-split-payment-platform"),
                Self::FailedSplitPaymentCompensation => {
                    f.write_str("failed-split-payment-compensation")
                }
                Self::CashAdvanceLoan => f.write_str("cash-advance-loan"),
                Self::PlatformConnectedOrganizationsFee => {
                    f.write_str("platform-connected-organizations-fee")
                }
                Self::SplitTransaction => f.write_str("split-transaction"),
                Self::ManagedFee => f.write_str("managed-fee"),
                Self::ReturnedManagedFee => f.write_str("returned-managed-fee"),
                Self::Topup => f.write_str("topup"),
                Self::BalanceReserve => f.write_str("balance-reserve"),
                Self::BalanceReserveReturn => f.write_str("balance-reserve-return"),
                Self::Movement => f.write_str("movement"),
                Self::PostPaymentSplitPayment => f.write_str("post-payment-split-payment"),
                Self::CashCollateralIssuance => f.write_str("cash-collateral-issuance"),
                Self::CashCollateralRelease => f.write_str("cash-collateral-release"),
            }
        }
    }

    impl ::std::str::FromStr for BalanceTransactionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "application-fee" => Ok(Self::ApplicationFee),
                "capture" => Ok(Self::Capture),
                "chargeback" => Ok(Self::Chargeback),
                "chargeback-reversal" => Ok(Self::ChargebackReversal),
                "failed-payment-fee" => Ok(Self::FailedPaymentFee),
                "failed-payment" => Ok(Self::FailedPayment),
                "invoice-compensation" => Ok(Self::InvoiceCompensation),
                "payment" => Ok(Self::Payment),
                "payment-fee" => Ok(Self::PaymentFee),
                "payment-commission" => Ok(Self::PaymentCommission),
                "refund" => Ok(Self::Refund),
                "returned-refund" => Ok(Self::ReturnedRefund),
                "returned-transfer" => Ok(Self::ReturnedTransfer),
                "split-payment" => Ok(Self::SplitPayment),
                "outgoing-transfer" => Ok(Self::OutgoingTransfer),
                "capture-commission" => Ok(Self::CaptureCommission),
                "canceled-outgoing-transfer" => Ok(Self::CanceledOutgoingTransfer),
                "incoming-transfer" => Ok(Self::IncomingTransfer),
                "api-payment-rolling-reserve-release" => Ok(Self::ApiPaymentRollingReserveRelease),
                "capture-rolling-reserve-release" => Ok(Self::CaptureRollingReserveRelease),
                "reimbursement-fee" => Ok(Self::ReimbursementFee),
                "balance-correction" => Ok(Self::BalanceCorrection),
                "unauthorized-direct-debit" => Ok(Self::UnauthorizedDirectDebit),
                "bank-charged-failure-fee" => Ok(Self::BankChargedFailureFee),
                "platform-payment-refund" => Ok(Self::PlatformPaymentRefund),
                "refund-compensation" => Ok(Self::RefundCompensation),
                "returned-refund-compensation" => Ok(Self::ReturnedRefundCompensation),
                "returned-platform-payment-refund" => Ok(Self::ReturnedPlatformPaymentRefund),
                "platform-payment-chargeback" => Ok(Self::PlatformPaymentChargeback),
                "chargeback-compensation" => Ok(Self::ChargebackCompensation),
                "reversed-platform-payment-chargeback" => {
                    Ok(Self::ReversedPlatformPaymentChargeback)
                }
                "reversed-chargeback-compensation" => Ok(Self::ReversedChargebackCompensation),
                "failed-split-payment-platform" => Ok(Self::FailedSplitPaymentPlatform),
                "failed-split-payment-compensation" => Ok(Self::FailedSplitPaymentCompensation),
                "cash-advance-loan" => Ok(Self::CashAdvanceLoan),
                "platform-connected-organizations-fee" => {
                    Ok(Self::PlatformConnectedOrganizationsFee)
                }
                "split-transaction" => Ok(Self::SplitTransaction),
                "managed-fee" => Ok(Self::ManagedFee),
                "returned-managed-fee" => Ok(Self::ReturnedManagedFee),
                "topup" => Ok(Self::Topup),
                "balance-reserve" => Ok(Self::BalanceReserve),
                "balance-reserve-return" => Ok(Self::BalanceReserveReturn),
                "movement" => Ok(Self::Movement),
                "post-payment-split-payment" => Ok(Self::PostPaymentSplitPayment),
                "cash-collateral-issuance" => Ok(Self::CashCollateralIssuance),
                "cash-collateral-release" => Ok(Self::CashCollateralRelease),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for BalanceTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for BalanceTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for BalanceTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The type of the transfer. Different fees may apply to different types of
    /// transfers.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of the transfer. Different fees may apply to
    /// different types of transfers.",
    ///  "examples": [
    ///    "invoice_collection"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "invoice_collection",
    ///    "purchase",
    ///    "chargeback",
    ///    "refund",
    ///    "service_penalty",
    ///    "discount_compensation",
    ///    "manual_correction",
    ///    "other_fee"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BalanceTransferCategory {
        #[serde(rename = "invoice_collection")]
        InvoiceCollection,
        #[serde(rename = "purchase")]
        Purchase,
        #[serde(rename = "chargeback")]
        Chargeback,
        #[serde(rename = "refund")]
        Refund,
        #[serde(rename = "service_penalty")]
        ServicePenalty,
        #[serde(rename = "discount_compensation")]
        DiscountCompensation,
        #[serde(rename = "manual_correction")]
        ManualCorrection,
        #[serde(rename = "other_fee")]
        OtherFee,
    }

    impl ::std::convert::From<&Self> for BalanceTransferCategory {
        fn from(value: &BalanceTransferCategory) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BalanceTransferCategory {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InvoiceCollection => f.write_str("invoice_collection"),
                Self::Purchase => f.write_str("purchase"),
                Self::Chargeback => f.write_str("chargeback"),
                Self::Refund => f.write_str("refund"),
                Self::ServicePenalty => f.write_str("service_penalty"),
                Self::DiscountCompensation => f.write_str("discount_compensation"),
                Self::ManualCorrection => f.write_str("manual_correction"),
                Self::OtherFee => f.write_str("other_fee"),
            }
        }
    }

    impl ::std::str::FromStr for BalanceTransferCategory {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "invoice_collection" => Ok(Self::InvoiceCollection),
                "purchase" => Ok(Self::Purchase),
                "chargeback" => Ok(Self::Chargeback),
                "refund" => Ok(Self::Refund),
                "service_penalty" => Ok(Self::ServicePenalty),
                "discount_compensation" => Ok(Self::DiscountCompensation),
                "manual_correction" => Ok(Self::ManualCorrection),
                "other_fee" => Ok(Self::OtherFee),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for BalanceTransferCategory {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for BalanceTransferCategory {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for BalanceTransferCategory {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The type of the transfer. Different fees may apply to different types of
    /// transfers.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of the transfer. Different fees may apply to
    /// different types of transfers.",
    ///  "examples": [
    ///    "invoice_collection"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "invoice_collection",
    ///    "purchase",
    ///    "chargeback",
    ///    "refund",
    ///    "service_penalty",
    ///    "discount_compensation",
    ///    "manual_correction",
    ///    "other_fee"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BalanceTransferCategoryResponse {
        #[serde(rename = "invoice_collection")]
        InvoiceCollection,
        #[serde(rename = "purchase")]
        Purchase,
        #[serde(rename = "chargeback")]
        Chargeback,
        #[serde(rename = "refund")]
        Refund,
        #[serde(rename = "service_penalty")]
        ServicePenalty,
        #[serde(rename = "discount_compensation")]
        DiscountCompensation,
        #[serde(rename = "manual_correction")]
        ManualCorrection,
        #[serde(rename = "other_fee")]
        OtherFee,
    }

    impl ::std::convert::From<&Self> for BalanceTransferCategoryResponse {
        fn from(value: &BalanceTransferCategoryResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BalanceTransferCategoryResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InvoiceCollection => f.write_str("invoice_collection"),
                Self::Purchase => f.write_str("purchase"),
                Self::Chargeback => f.write_str("chargeback"),
                Self::Refund => f.write_str("refund"),
                Self::ServicePenalty => f.write_str("service_penalty"),
                Self::DiscountCompensation => f.write_str("discount_compensation"),
                Self::ManualCorrection => f.write_str("manual_correction"),
                Self::OtherFee => f.write_str("other_fee"),
            }
        }
    }

    impl ::std::str::FromStr for BalanceTransferCategoryResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "invoice_collection" => Ok(Self::InvoiceCollection),
                "purchase" => Ok(Self::Purchase),
                "chargeback" => Ok(Self::Chargeback),
                "refund" => Ok(Self::Refund),
                "service_penalty" => Ok(Self::ServicePenalty),
                "discount_compensation" => Ok(Self::DiscountCompensation),
                "manual_correction" => Ok(Self::ManualCorrection),
                "other_fee" => Ok(Self::OtherFee),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for BalanceTransferCategoryResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for BalanceTransferCategoryResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for BalanceTransferCategoryResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The default destination of automatic scheduled transfers. Currently only
    /// `bank-account` is supported.
    ///
    /// * `bank-account` — Transfer the balance amount to an external bank
    ///   account
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The default destination of automatic scheduled
    /// transfers. Currently only `bank-account` is supported.\n\n*
    /// `bank-account` — Transfer the balance amount to an external bank
    /// account",
    ///  "examples": [
    ///    "bank-account"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "bank-account"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BalanceTransferDestinationType {
        #[serde(rename = "bank-account")]
        BankAccount,
    }

    impl ::std::convert::From<&Self> for BalanceTransferDestinationType {
        fn from(value: &BalanceTransferDestinationType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BalanceTransferDestinationType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::BankAccount => f.write_str("bank-account"),
            }
        }
    }

    impl ::std::str::FromStr for BalanceTransferDestinationType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bank-account" => Ok(Self::BankAccount),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for BalanceTransferDestinationType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for BalanceTransferDestinationType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for BalanceTransferDestinationType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The frequency with which the available amount on the balance will be
    /// settled to the configured transfer destination.
    ///
    ///Settlements created during weekends or on bank holidays will take place
    /// on the next business day.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The frequency with which the available amount on the
    /// balance will be settled to the configured
    /// transfer\ndestination.\n\nSettlements created during weekends or on bank
    /// holidays will take place on the next business day.",
    ///  "examples": [
    ///    "daily"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "daily",
    ///    "every-monday",
    ///    "every-tuesday",
    ///    "every-wednesday",
    ///    "every-thursday",
    ///    "every-friday",
    ///    "monthly",
    ///    "never"
    ///  ],
    ///  "x-enumDescriptions": {
    ///    "daily": "Every business day",
    ///    "every-friday": "Every Friday",
    ///    "every-monday": "Every Monday",
    ///    "every-thursday": "Every Thursday",
    ///    "every-tuesday": "Every Tuesday",
    ///    "every-wednesday": "Every Wednesday",
    ///    "monthly": "On the first of the month",
    ///    "never": "Automatic settlements are paused for this balance"
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BalanceTransferFrequency {
        #[serde(rename = "daily")]
        Daily,
        #[serde(rename = "every-monday")]
        EveryMonday,
        #[serde(rename = "every-tuesday")]
        EveryTuesday,
        #[serde(rename = "every-wednesday")]
        EveryWednesday,
        #[serde(rename = "every-thursday")]
        EveryThursday,
        #[serde(rename = "every-friday")]
        EveryFriday,
        #[serde(rename = "monthly")]
        Monthly,
        #[serde(rename = "never")]
        Never,
    }

    impl ::std::convert::From<&Self> for BalanceTransferFrequency {
        fn from(value: &BalanceTransferFrequency) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BalanceTransferFrequency {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Daily => f.write_str("daily"),
                Self::EveryMonday => f.write_str("every-monday"),
                Self::EveryTuesday => f.write_str("every-tuesday"),
                Self::EveryWednesday => f.write_str("every-wednesday"),
                Self::EveryThursday => f.write_str("every-thursday"),
                Self::EveryFriday => f.write_str("every-friday"),
                Self::Monthly => f.write_str("monthly"),
                Self::Never => f.write_str("never"),
            }
        }
    }

    impl ::std::str::FromStr for BalanceTransferFrequency {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "daily" => Ok(Self::Daily),
                "every-monday" => Ok(Self::EveryMonday),
                "every-tuesday" => Ok(Self::EveryTuesday),
                "every-wednesday" => Ok(Self::EveryWednesday),
                "every-thursday" => Ok(Self::EveryThursday),
                "every-friday" => Ok(Self::EveryFriday),
                "monthly" => Ok(Self::Monthly),
                "never" => Ok(Self::Never),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for BalanceTransferFrequency {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for BalanceTransferFrequency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for BalanceTransferFrequency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Defines the type of the party. At the moment, only `organization` is
    /// supported.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Defines the type of the party. At the moment, only
    /// `organization` is supported.",
    ///  "examples": [
    ///    "organization"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "organization"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BalanceTransferPartyType {
        #[serde(rename = "organization")]
        Organization,
    }

    impl ::std::convert::From<&Self> for BalanceTransferPartyType {
        fn from(value: &BalanceTransferPartyType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BalanceTransferPartyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Organization => f.write_str("organization"),
            }
        }
    }

    impl ::std::str::FromStr for BalanceTransferPartyType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "organization" => Ok(Self::Organization),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for BalanceTransferPartyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for BalanceTransferPartyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for BalanceTransferPartyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Defines the type of the party. At the moment, only `organization` is
    /// supported.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Defines the type of the party. At the moment, only
    /// `organization` is supported.",
    ///  "examples": [
    ///    "organization"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "organization"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BalanceTransferPartyTypeResponse {
        #[serde(rename = "organization")]
        Organization,
    }

    impl ::std::convert::From<&Self> for BalanceTransferPartyTypeResponse {
        fn from(value: &BalanceTransferPartyTypeResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BalanceTransferPartyTypeResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Organization => f.write_str("organization"),
            }
        }
    }

    impl ::std::str::FromStr for BalanceTransferPartyTypeResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "organization" => Ok(Self::Organization),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for BalanceTransferPartyTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for BalanceTransferPartyTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for BalanceTransferPartyTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The status of the transfer.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status of the transfer.",
    ///  "readOnly": true,
    ///  "examples": [
    ///    "created"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "created",
    ///    "failed",
    ///    "succeeded"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BalanceTransferStatus {
        #[serde(rename = "created")]
        Created,
        #[serde(rename = "failed")]
        Failed,
        #[serde(rename = "succeeded")]
        Succeeded,
    }

    impl ::std::convert::From<&Self> for BalanceTransferStatus {
        fn from(value: &BalanceTransferStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BalanceTransferStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Created => f.write_str("created"),
                Self::Failed => f.write_str("failed"),
                Self::Succeeded => f.write_str("succeeded"),
            }
        }
    }

    impl ::std::str::FromStr for BalanceTransferStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "created" => Ok(Self::Created),
                "failed" => Ok(Self::Failed),
                "succeeded" => Ok(Self::Succeeded),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for BalanceTransferStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for BalanceTransferStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for BalanceTransferStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A machine-readable code that indicates the reason for the transfer's
    /// status.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A machine-readable code that indicates the reason for
    /// the transfer's status.",
    ///  "examples": [
    ///    "insufficient_funds"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "request_created",
    ///    "success",
    ///    "source_not_allowed",
    ///    "destination_not_allowed",
    ///    "insufficient_funds",
    ///    "invalid_source_balance",
    ///    "invalid_destination_balance",
    ///    "transfer_request_expired",
    ///    "transfer_limit_reached"
    ///  ],
    ///  "x-enumDescriptions": {
    ///    "destination_not_allowed": "Balance transfers to the destination
    /// organization are not allowed.",
    ///    "insufficient_funds": "Source does not have enough balance.",
    ///    "invalid_destination_balance": "Invalid balance for destination
    /// organization.",
    ///    "invalid_source_balance": "Invalid balance for source organization.",
    ///    "request_created": "Balance transfer request was created.",
    ///    "source_not_allowed": "Balance transfers from the source organization
    /// are not allowed.",
    ///    "success": "Balance transfer completed successfully.",
    ///    "transfer_limit_reached": "Transfer limit has been exceeded.",
    ///    "transfer_request_expired": "Request for balance transfer has
    /// expired."
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BalanceTransferStatusReason {
        #[serde(rename = "request_created")]
        RequestCreated,
        #[serde(rename = "success")]
        Success,
        #[serde(rename = "source_not_allowed")]
        SourceNotAllowed,
        #[serde(rename = "destination_not_allowed")]
        DestinationNotAllowed,
        #[serde(rename = "insufficient_funds")]
        InsufficientFunds,
        #[serde(rename = "invalid_source_balance")]
        InvalidSourceBalance,
        #[serde(rename = "invalid_destination_balance")]
        InvalidDestinationBalance,
        #[serde(rename = "transfer_request_expired")]
        TransferRequestExpired,
        #[serde(rename = "transfer_limit_reached")]
        TransferLimitReached,
    }

    impl ::std::convert::From<&Self> for BalanceTransferStatusReason {
        fn from(value: &BalanceTransferStatusReason) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BalanceTransferStatusReason {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::RequestCreated => f.write_str("request_created"),
                Self::Success => f.write_str("success"),
                Self::SourceNotAllowed => f.write_str("source_not_allowed"),
                Self::DestinationNotAllowed => f.write_str("destination_not_allowed"),
                Self::InsufficientFunds => f.write_str("insufficient_funds"),
                Self::InvalidSourceBalance => f.write_str("invalid_source_balance"),
                Self::InvalidDestinationBalance => f.write_str("invalid_destination_balance"),
                Self::TransferRequestExpired => f.write_str("transfer_request_expired"),
                Self::TransferLimitReached => f.write_str("transfer_limit_reached"),
            }
        }
    }

    impl ::std::str::FromStr for BalanceTransferStatusReason {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "request_created" => Ok(Self::RequestCreated),
                "success" => Ok(Self::Success),
                "source_not_allowed" => Ok(Self::SourceNotAllowed),
                "destination_not_allowed" => Ok(Self::DestinationNotAllowed),
                "insufficient_funds" => Ok(Self::InsufficientFunds),
                "invalid_source_balance" => Ok(Self::InvalidSourceBalance),
                "invalid_destination_balance" => Ok(Self::InvalidDestinationBalance),
                "transfer_request_expired" => Ok(Self::TransferRequestExpired),
                "transfer_limit_reached" => Ok(Self::TransferLimitReached),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for BalanceTransferStatusReason {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for BalanceTransferStatusReason {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for BalanceTransferStatusReason {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A machine-readable code that indicates the reason for the transfer's
    /// status.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A machine-readable code that indicates the reason for
    /// the transfer's status.",
    ///  "examples": [
    ///    "insufficient_funds"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "request_created",
    ///    "success",
    ///    "source_not_allowed",
    ///    "destination_not_allowed",
    ///    "insufficient_funds",
    ///    "invalid_source_balance",
    ///    "invalid_destination_balance",
    ///    "transfer_request_expired",
    ///    "transfer_limit_reached"
    ///  ],
    ///  "x-enumDescriptions": {
    ///    "destination_not_allowed": "Balance transfers to the destination
    /// organization are not allowed.",
    ///    "insufficient_funds": "Source does not have enough balance.",
    ///    "invalid_destination_balance": "Invalid balance for destination
    /// organization.",
    ///    "invalid_source_balance": "Invalid balance for source organization.",
    ///    "request_created": "Balance transfer request was created.",
    ///    "source_not_allowed": "Balance transfers from the source organization
    /// are not allowed.",
    ///    "success": "Balance transfer completed successfully.",
    ///    "transfer_limit_reached": "Transfer limit has been exceeded.",
    ///    "transfer_request_expired": "Request for balance transfer has
    /// expired."
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BalanceTransferStatusReasonResponse {
        #[serde(rename = "request_created")]
        RequestCreated,
        #[serde(rename = "success")]
        Success,
        #[serde(rename = "source_not_allowed")]
        SourceNotAllowed,
        #[serde(rename = "destination_not_allowed")]
        DestinationNotAllowed,
        #[serde(rename = "insufficient_funds")]
        InsufficientFunds,
        #[serde(rename = "invalid_source_balance")]
        InvalidSourceBalance,
        #[serde(rename = "invalid_destination_balance")]
        InvalidDestinationBalance,
        #[serde(rename = "transfer_request_expired")]
        TransferRequestExpired,
        #[serde(rename = "transfer_limit_reached")]
        TransferLimitReached,
    }

    impl ::std::convert::From<&Self> for BalanceTransferStatusReasonResponse {
        fn from(value: &BalanceTransferStatusReasonResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BalanceTransferStatusReasonResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::RequestCreated => f.write_str("request_created"),
                Self::Success => f.write_str("success"),
                Self::SourceNotAllowed => f.write_str("source_not_allowed"),
                Self::DestinationNotAllowed => f.write_str("destination_not_allowed"),
                Self::InsufficientFunds => f.write_str("insufficient_funds"),
                Self::InvalidSourceBalance => f.write_str("invalid_source_balance"),
                Self::InvalidDestinationBalance => f.write_str("invalid_destination_balance"),
                Self::TransferRequestExpired => f.write_str("transfer_request_expired"),
                Self::TransferLimitReached => f.write_str("transfer_limit_reached"),
            }
        }
    }

    impl ::std::str::FromStr for BalanceTransferStatusReasonResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "request_created" => Ok(Self::RequestCreated),
                "success" => Ok(Self::Success),
                "source_not_allowed" => Ok(Self::SourceNotAllowed),
                "destination_not_allowed" => Ok(Self::DestinationNotAllowed),
                "insufficient_funds" => Ok(Self::InsufficientFunds),
                "invalid_source_balance" => Ok(Self::InvalidSourceBalance),
                "invalid_destination_balance" => Ok(Self::InvalidDestinationBalance),
                "transfer_request_expired" => Ok(Self::TransferRequestExpired),
                "transfer_limit_reached" => Ok(Self::TransferLimitReached),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for BalanceTransferStatusReasonResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for BalanceTransferStatusReasonResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for BalanceTransferStatusReasonResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`BillingAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The customer's billing address details. We advise to
    /// provide these details to improve fraud protection
    /// and\nconversion.\n\nShould include `email` or a valid postal address
    /// consisting of `streetAndNumber`, `postalCode`, `city`
    /// and\n`country`.\n\nRequired for payment method `in3`, `klarna`, `billie`
    /// and `riverty`.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/payment-address"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "organizationName": {
    ///          "description": "The name of the organization, in case the addressee is an organization.\n\nRequired for payment method `billie`."
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct BillingAddress(pub PaymentAddress);
    impl ::std::ops::Deref for BillingAddress {
        type Target = PaymentAddress;
        fn deref(&self) -> &PaymentAddress {
            &self.0
        }
    }

    impl ::std::convert::From<BillingAddress> for PaymentAddress {
        fn from(value: BillingAddress) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&BillingAddress> for BillingAddress {
        fn from(value: &BillingAddress) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<PaymentAddress> for BillingAddress {
        fn from(value: PaymentAddress) -> Self {
            Self(value)
        }
    }

    ///`CancelPaymentBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CancelPaymentBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
    }

    impl ::std::convert::From<&CancelPaymentBody> for CancelPaymentBody {
        fn from(value: &CancelPaymentBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CancelPaymentBody {
        fn default() -> Self {
            Self {
                testmode: Default::default(),
            }
        }
    }

    ///`CancelSubscriptionBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CancelSubscriptionBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<Testmode>,
    }

    impl ::std::convert::From<&CancelSubscriptionBody> for CancelSubscriptionBody {
        fn from(value: &CancelSubscriptionBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CancelSubscriptionBody {
        fn default() -> Self {
            Self {
                testmode: Default::default(),
            }
        }
    }

    ///The URL your customer will be redirected to when the customer explicitly
    /// cancels the payment. If this URL is not provided, the customer will
    /// be redirected to the `redirectUrl` instead — see above.
    ///
    ///Mollie will always give you status updates via webhooks, including for
    /// the canceled status. This parameter is therefore entirely optional,
    /// but can be useful when implementing a dedicated customer-facing flow to
    /// handle payment cancellations.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The URL your customer will be redirected to when the
    /// customer explicitly cancels the payment. If this URL is not\nprovided,
    /// the customer will be redirected to the `redirectUrl` instead — see
    /// above.\n\nMollie will always give you status updates via webhooks,
    /// including for the canceled status. This parameter is\ntherefore entirely
    /// optional, but can be useful when implementing a dedicated
    /// customer-facing flow to handle\npayment cancellations.",
    ///  "examples": [
    ///    "https://example.org/cancel"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct CancelUrl(pub ::std::option::Option<::std::string::String>);
    impl ::std::ops::Deref for CancelUrl {
        type Target = ::std::option::Option<::std::string::String>;
        fn deref(&self) -> &::std::option::Option<::std::string::String> {
            &self.0
        }
    }

    impl ::std::convert::From<CancelUrl> for ::std::option::Option<::std::string::String> {
        fn from(value: CancelUrl) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CancelUrl> for CancelUrl {
        fn from(value: &CancelUrl) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<::std::string::String>> for CancelUrl {
        fn from(value: ::std::option::Option<::std::string::String>) -> Self {
            Self(value)
        }
    }

    ///The status of the requirement depends on its due date.
    ///If no due date is given, the status will be `requested`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status of the requirement depends on its due
    /// date.\nIf no due date is given, the status will be `requested`.",
    ///  "examples": [
    ///    "past-due"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "currently-due",
    ///    "past-due",
    ///    "requested"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CapabilityRequirementStatus {
        #[serde(rename = "currently-due")]
        CurrentlyDue,
        #[serde(rename = "past-due")]
        PastDue,
        #[serde(rename = "requested")]
        Requested,
    }

    impl ::std::convert::From<&Self> for CapabilityRequirementStatus {
        fn from(value: &CapabilityRequirementStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CapabilityRequirementStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::CurrentlyDue => f.write_str("currently-due"),
                Self::PastDue => f.write_str("past-due"),
                Self::Requested => f.write_str("requested"),
            }
        }
    }

    impl ::std::str::FromStr for CapabilityRequirementStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "currently-due" => Ok(Self::CurrentlyDue),
                "past-due" => Ok(Self::PastDue),
                "requested" => Ok(Self::Requested),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CapabilityRequirementStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CapabilityRequirementStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CapabilityRequirementStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`CapabilityStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "pending"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "unrequested",
    ///    "enabled",
    ///    "disabled",
    ///    "pending"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CapabilityStatus {
        #[serde(rename = "unrequested")]
        Unrequested,
        #[serde(rename = "enabled")]
        Enabled,
        #[serde(rename = "disabled")]
        Disabled,
        #[serde(rename = "pending")]
        Pending,
    }

    impl ::std::convert::From<&Self> for CapabilityStatus {
        fn from(value: &CapabilityStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CapabilityStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Unrequested => f.write_str("unrequested"),
                Self::Enabled => f.write_str("enabled"),
                Self::Disabled => f.write_str("disabled"),
                Self::Pending => f.write_str("pending"),
            }
        }
    }

    impl ::std::str::FromStr for CapabilityStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "unrequested" => Ok(Self::Unrequested),
                "enabled" => Ok(Self::Enabled),
                "disabled" => Ok(Self::Disabled),
                "pending" => Ok(Self::Pending),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CapabilityStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CapabilityStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CapabilityStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`CapabilityStatusReason`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "requirement-past-due"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "requirement-past-due",
    ///    "onboarding-information-needed"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CapabilityStatusReason {
        #[serde(rename = "requirement-past-due")]
        RequirementPastDue,
        #[serde(rename = "onboarding-information-needed")]
        OnboardingInformationNeeded,
    }

    impl ::std::convert::From<&Self> for CapabilityStatusReason {
        fn from(value: &CapabilityStatusReason) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CapabilityStatusReason {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::RequirementPastDue => f.write_str("requirement-past-due"),
                Self::OnboardingInformationNeeded => f.write_str("onboarding-information-needed"),
            }
        }
    }

    impl ::std::str::FromStr for CapabilityStatusReason {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "requirement-past-due" => Ok(Self::RequirementPastDue),
                "onboarding-information-needed" => Ok(Self::OnboardingInformationNeeded),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CapabilityStatusReason {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CapabilityStatusReason {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CapabilityStatusReason {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
    ///and capture at a later time.
    ///
    ///This field needs to be set to `manual` for method `riverty`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) \nand capture at a later time.\n\nThis field needs to be set to `manual` for method `riverty`.",
    ///  "examples": [
    ///    "manual"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "automatic",
    ///    "manual"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct CaptureMode(pub ::std::option::Option<CaptureModeInner>);
    impl ::std::ops::Deref for CaptureMode {
        type Target = ::std::option::Option<CaptureModeInner>;
        fn deref(&self) -> &::std::option::Option<CaptureModeInner> {
            &self.0
        }
    }

    impl ::std::convert::From<CaptureMode> for ::std::option::Option<CaptureModeInner> {
        fn from(value: CaptureMode) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CaptureMode> for CaptureMode {
        fn from(value: &CaptureMode) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<CaptureModeInner>> for CaptureMode {
        fn from(value: ::std::option::Option<CaptureModeInner>) -> Self {
            Self(value)
        }
    }

    ///Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
    ///and capture at a later time.
    ///
    ///This field needs to be set to `manual` for method `riverty`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) \nand capture at a later time.\n\nThis field needs to be set to `manual` for method `riverty`.",
    ///  "examples": [
    ///    "manual"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "automatic",
    ///    "manual"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CaptureModeInner {
        #[serde(rename = "automatic")]
        Automatic,
        #[serde(rename = "manual")]
        Manual,
    }

    impl ::std::convert::From<&Self> for CaptureModeInner {
        fn from(value: &CaptureModeInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CaptureModeInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Automatic => f.write_str("automatic"),
                Self::Manual => f.write_str("manual"),
            }
        }
    }

    impl ::std::str::FromStr for CaptureModeInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "automatic" => Ok(Self::Automatic),
                "manual" => Ok(Self::Manual),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CaptureModeInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CaptureModeInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CaptureModeInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
    ///and capture at a later time.
    ///
    ///This field needs to be set to `manual` for method `riverty`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) \nand capture at a later time.\n\nThis field needs to be set to `manual` for method `riverty`.",
    ///  "examples": [
    ///    "manual"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "automatic",
    ///    "manual"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct CaptureModeResponse(pub ::std::option::Option<CaptureModeResponseInner>);
    impl ::std::ops::Deref for CaptureModeResponse {
        type Target = ::std::option::Option<CaptureModeResponseInner>;
        fn deref(&self) -> &::std::option::Option<CaptureModeResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<CaptureModeResponse> for ::std::option::Option<CaptureModeResponseInner> {
        fn from(value: CaptureModeResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CaptureModeResponse> for CaptureModeResponse {
        fn from(value: &CaptureModeResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<CaptureModeResponseInner>> for CaptureModeResponse {
        fn from(value: ::std::option::Option<CaptureModeResponseInner>) -> Self {
            Self(value)
        }
    }

    ///Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
    ///and capture at a later time.
    ///
    ///This field needs to be set to `manual` for method `riverty`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) \nand capture at a later time.\n\nThis field needs to be set to `manual` for method `riverty`.",
    ///  "examples": [
    ///    "manual"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "automatic",
    ///    "manual"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CaptureModeResponseInner {
        #[serde(rename = "automatic")]
        Automatic,
        #[serde(rename = "manual")]
        Manual,
    }

    impl ::std::convert::From<&Self> for CaptureModeResponseInner {
        fn from(value: &CaptureModeResponseInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CaptureModeResponseInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Automatic => f.write_str("automatic"),
                Self::Manual => f.write_str("manual"),
            }
        }
    }

    impl ::std::str::FromStr for CaptureModeResponseInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "automatic" => Ok(Self::Automatic),
                "manual" => Ok(Self::Manual),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CaptureModeResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CaptureModeResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CaptureModeResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`CaptureResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/entity-capture-response"
    ///    }
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct CaptureResponse(pub EntityCaptureResponse);
    impl ::std::ops::Deref for CaptureResponse {
        type Target = EntityCaptureResponse;
        fn deref(&self) -> &EntityCaptureResponse {
            &self.0
        }
    }

    impl ::std::convert::From<CaptureResponse> for EntityCaptureResponse {
        fn from(value: CaptureResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CaptureResponse> for CaptureResponse {
        fn from(value: &CaptureResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<EntityCaptureResponse> for CaptureResponse {
        fn from(value: EntityCaptureResponse) -> Self {
            Self(value)
        }
    }

    ///The capture's status.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The capture's status.",
    ///  "examples": [
    ///    "succeeded"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "pending",
    ///    "succeeded",
    ///    "failed"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CaptureStatus {
        #[serde(rename = "pending")]
        Pending,
        #[serde(rename = "succeeded")]
        Succeeded,
        #[serde(rename = "failed")]
        Failed,
    }

    impl ::std::convert::From<&Self> for CaptureStatus {
        fn from(value: &CaptureStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CaptureStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Pending => f.write_str("pending"),
                Self::Succeeded => f.write_str("succeeded"),
                Self::Failed => f.write_str("failed"),
            }
        }
    }

    impl ::std::str::FromStr for CaptureStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "pending" => Ok(Self::Pending),
                "succeeded" => Ok(Self::Succeeded),
                "failed" => Ok(Self::Failed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CaptureStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CaptureStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CaptureStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`CaptureToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "cpt_vytxeTZskVKR7C7WgdSP3d"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct CaptureToken(pub ::std::string::String);
    impl ::std::ops::Deref for CaptureToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CaptureToken> for ::std::string::String {
        fn from(value: CaptureToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CaptureToken> for CaptureToken {
        fn from(value: &CaptureToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for CaptureToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for CaptureToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for CaptureToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`ChargebackToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "chb_xFzwUN4ci8HAmSGUACS4J"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct ChargebackToken(pub ::std::string::String);
    impl ::std::ops::Deref for ChargebackToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<ChargebackToken> for ::std::string::String {
        fn from(value: ChargebackToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&ChargebackToken> for ChargebackToken {
        fn from(value: &ChargebackToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for ChargebackToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for ChargebackToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for ChargebackToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`ComponentsSubTotals`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "cardAudience": {
    ///      "description": "In case of payments trnsactions with card, the card
    /// audience will be available.",
    ///      "examples": [
    ///        "other"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "enum": [
    ///        "corporate",
    ///        "other"
    ///      ]
    ///    },
    ///    "cardIssuer": {
    ///      "description": "In case of payments transactions with card, the
    /// card issuer will be available",
    ///      "examples": [
    ///        "amex"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "enum": [
    ///        "amex",
    ///        "maestro",
    ///        "carte-bancaire",
    ///        "other"
    ///      ]
    ///    },
    ///    "cardRegion": {
    ///      "description": "In case of payments transactions with card, the
    /// card region will be available.",
    ///      "examples": [
    ///        "domestic"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "enum": [
    ///        "intra-eea",
    ///        "intra-eu",
    ///        "domestic",
    ///        "other"
    ///      ]
    ///    },
    ///    "count": {
    ///      "description": "Number of transactions of this type",
    ///      "examples": [
    ///        50
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "feeType": {
    ///      "description": "Present when the transaction represents a fee.",
    ///      "examples": [
    ///        "payment-fee"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "enum": [
    ///        "payment-fee",
    ///        "direct-debit-failure-fee",
    ///        "unauthorized-direct-debit-fee",
    ///        "bank-charged-direct-debit-failure-fee",
    ///        "partner-commission",
    ///        "application-fee",
    ///        "capture-fee",
    ///        "refund-fee",
    ///        "chargeback-fee",
    ///        "payment-notification-fee",
    ///        "transfer-notification-fee",
    ///        "payout-fee",
    ///        "fee-discount",
    ///        "fee-reimbursement",
    ///        "platform-volume-fee",
    ///        "platform-connected-organizations-fee",
    ///        "balance-charge-fee",
    ///        "3ds-authentication-attempt-fee",
    ///        "terminal-monthly-fee",
    ///        "acceptance-risk-fee",
    ///        "top-up-fee",
    ///        "payment-gateway-fee",
    ///        "mastercard-specialty-merchant-program-processing-fee",
    ///        "mastercard-specialty-merchant-program-registration-fee",
    ///        "visa-integrity-risk-program-processing-fee",
    ///        "visa-integrity-risk-program-registration-fee",
    ///        "minimum-invoice-amount-fee"
    ///      ]
    ///    },
    ///    "method": {
    ///      "$ref": "#/components/schemas/payment-method"
    ///    },
    ///    "prepaymentPartType": {
    ///      "description": "Prepayment part: fee itself, reimbursement,
    /// discount, VAT or rounding compensation.",
    ///      "examples": [
    ///        "fee"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "enum": [
    ///        "fee",
    ///        "fee-reimbursement",
    ///        "fee-discount",
    ///        "fee-vat",
    ///        "fee-rounding-compensation"
    ///      ]
    ///    },
    ///    "sub-totals": {
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/sub-totals"
    ///      }
    ///    },
    ///    "transactionType": {
    ///      "description": "Represents the transaction type",
    ///      "examples": [
    ///        "payment"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "enum": [
    ///        "payment",
    ///        "split-payment",
    ///        "failed-payment",
    ///        "failed-platform-split-payment",
    ///        "failed-split-payment-compensation",
    ///        "capture",
    ///        "split-transaction",
    ///        "refund",
    ///        "platform-payment-refund",
    ///        "returned-platform-payment-refund",
    ///        "refund-compensation",
    ///        "returned-refund-compensation",
    ///        "returned-refund",
    ///        "chargeback",
    ///        "chargeback-reversal",
    ///        "chargeback-compensation",
    ///        "reversed-chargeback-compensation",
    ///        "platform-payment-chargeback",
    ///        "reversed-platform-payment-chargeback",
    ///        "fee-prepayment",
    ///        "outgoing-transfer",
    ///        "incoming-transfer",
    ///        "canceled-transfer",
    ///        "returned-transfer",
    ///        "balance-reserve",
    ///        "balance-reserve-return",
    ///        "invoice-rounding-compensation",
    ///        "rolling-reserve-hold",
    ///        "rolling-reserve-release",
    ///        "balance-correction",
    ///        "repayment",
    ///        "loan",
    ///        "balance-topup",
    ///        "cash-collateral-issuance';",
    ///        "cash-collateral-release",
    ///        "pending-rolling-reserve",
    ///        "to-be-released-rolling-reserve",
    ///        "held-rolling-reserve",
    ///        "released-rolling-reserve"
    ///      ]
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ComponentsSubTotals {
        ///In case of payments trnsactions with card, the card audience will be
        /// available.
        #[serde(
            rename = "cardAudience",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_audience: ::std::option::Option<ComponentsSubTotalsCardAudience>,
        ///In case of payments transactions with card, the card issuer will be
        /// available
        #[serde(
            rename = "cardIssuer",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_issuer: ::std::option::Option<ComponentsSubTotalsCardIssuer>,
        ///In case of payments transactions with card, the card region will be
        /// available.
        #[serde(
            rename = "cardRegion",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_region: ::std::option::Option<ComponentsSubTotalsCardRegion>,
        ///Number of transactions of this type
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<i64>,
        ///Present when the transaction represents a fee.
        #[serde(
            rename = "feeType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub fee_type: ::std::option::Option<ComponentsSubTotalsFeeType>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub method: ::std::option::Option<PaymentMethod>,
        ///Prepayment part: fee itself, reimbursement, discount, VAT or
        /// rounding compensation.
        #[serde(
            rename = "prepaymentPartType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub prepayment_part_type: ::std::option::Option<ComponentsSubTotalsPrepaymentPartType>,
        #[serde(
            rename = "sub-totals",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub sub_totals: ::std::option::Option<::std::vec::Vec<SubTotals>>,
        ///Represents the transaction type
        #[serde(
            rename = "transactionType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub transaction_type: ::std::option::Option<ComponentsSubTotalsTransactionType>,
    }

    impl ::std::convert::From<&ComponentsSubTotals> for ComponentsSubTotals {
        fn from(value: &ComponentsSubTotals) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ComponentsSubTotals {
        fn default() -> Self {
            Self {
                card_audience: Default::default(),
                card_issuer: Default::default(),
                card_region: Default::default(),
                count: Default::default(),
                fee_type: Default::default(),
                method: Default::default(),
                prepayment_part_type: Default::default(),
                sub_totals: Default::default(),
                transaction_type: Default::default(),
            }
        }
    }

    ///In case of payments trnsactions with card, the card audience will be
    /// available.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "In case of payments trnsactions with card, the card
    /// audience will be available.",
    ///  "examples": [
    ///    "other"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "corporate",
    ///    "other"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ComponentsSubTotalsCardAudience {
        #[serde(rename = "corporate")]
        Corporate,
        #[serde(rename = "other")]
        Other,
    }

    impl ::std::convert::From<&Self> for ComponentsSubTotalsCardAudience {
        fn from(value: &ComponentsSubTotalsCardAudience) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ComponentsSubTotalsCardAudience {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Corporate => f.write_str("corporate"),
                Self::Other => f.write_str("other"),
            }
        }
    }

    impl ::std::str::FromStr for ComponentsSubTotalsCardAudience {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "corporate" => Ok(Self::Corporate),
                "other" => Ok(Self::Other),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ComponentsSubTotalsCardAudience {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ComponentsSubTotalsCardAudience {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ComponentsSubTotalsCardAudience {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///In case of payments transactions with card, the card issuer will be
    /// available
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "In case of payments transactions with card, the card
    /// issuer will be available",
    ///  "examples": [
    ///    "amex"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "amex",
    ///    "maestro",
    ///    "carte-bancaire",
    ///    "other"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ComponentsSubTotalsCardIssuer {
        #[serde(rename = "amex")]
        Amex,
        #[serde(rename = "maestro")]
        Maestro,
        #[serde(rename = "carte-bancaire")]
        CarteBancaire,
        #[serde(rename = "other")]
        Other,
    }

    impl ::std::convert::From<&Self> for ComponentsSubTotalsCardIssuer {
        fn from(value: &ComponentsSubTotalsCardIssuer) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ComponentsSubTotalsCardIssuer {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Amex => f.write_str("amex"),
                Self::Maestro => f.write_str("maestro"),
                Self::CarteBancaire => f.write_str("carte-bancaire"),
                Self::Other => f.write_str("other"),
            }
        }
    }

    impl ::std::str::FromStr for ComponentsSubTotalsCardIssuer {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "amex" => Ok(Self::Amex),
                "maestro" => Ok(Self::Maestro),
                "carte-bancaire" => Ok(Self::CarteBancaire),
                "other" => Ok(Self::Other),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ComponentsSubTotalsCardIssuer {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ComponentsSubTotalsCardIssuer {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ComponentsSubTotalsCardIssuer {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///In case of payments transactions with card, the card region will be
    /// available.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "In case of payments transactions with card, the card
    /// region will be available.",
    ///  "examples": [
    ///    "domestic"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "intra-eea",
    ///    "intra-eu",
    ///    "domestic",
    ///    "other"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ComponentsSubTotalsCardRegion {
        #[serde(rename = "intra-eea")]
        IntraEea,
        #[serde(rename = "intra-eu")]
        IntraEu,
        #[serde(rename = "domestic")]
        Domestic,
        #[serde(rename = "other")]
        Other,
    }

    impl ::std::convert::From<&Self> for ComponentsSubTotalsCardRegion {
        fn from(value: &ComponentsSubTotalsCardRegion) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ComponentsSubTotalsCardRegion {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::IntraEea => f.write_str("intra-eea"),
                Self::IntraEu => f.write_str("intra-eu"),
                Self::Domestic => f.write_str("domestic"),
                Self::Other => f.write_str("other"),
            }
        }
    }

    impl ::std::str::FromStr for ComponentsSubTotalsCardRegion {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "intra-eea" => Ok(Self::IntraEea),
                "intra-eu" => Ok(Self::IntraEu),
                "domestic" => Ok(Self::Domestic),
                "other" => Ok(Self::Other),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ComponentsSubTotalsCardRegion {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ComponentsSubTotalsCardRegion {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ComponentsSubTotalsCardRegion {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Present when the transaction represents a fee.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Present when the transaction represents a fee.",
    ///  "examples": [
    ///    "payment-fee"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "payment-fee",
    ///    "direct-debit-failure-fee",
    ///    "unauthorized-direct-debit-fee",
    ///    "bank-charged-direct-debit-failure-fee",
    ///    "partner-commission",
    ///    "application-fee",
    ///    "capture-fee",
    ///    "refund-fee",
    ///    "chargeback-fee",
    ///    "payment-notification-fee",
    ///    "transfer-notification-fee",
    ///    "payout-fee",
    ///    "fee-discount",
    ///    "fee-reimbursement",
    ///    "platform-volume-fee",
    ///    "platform-connected-organizations-fee",
    ///    "balance-charge-fee",
    ///    "3ds-authentication-attempt-fee",
    ///    "terminal-monthly-fee",
    ///    "acceptance-risk-fee",
    ///    "top-up-fee",
    ///    "payment-gateway-fee",
    ///    "mastercard-specialty-merchant-program-processing-fee",
    ///    "mastercard-specialty-merchant-program-registration-fee",
    ///    "visa-integrity-risk-program-processing-fee",
    ///    "visa-integrity-risk-program-registration-fee",
    ///    "minimum-invoice-amount-fee"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ComponentsSubTotalsFeeType {
        #[serde(rename = "payment-fee")]
        PaymentFee,
        #[serde(rename = "direct-debit-failure-fee")]
        DirectDebitFailureFee,
        #[serde(rename = "unauthorized-direct-debit-fee")]
        UnauthorizedDirectDebitFee,
        #[serde(rename = "bank-charged-direct-debit-failure-fee")]
        BankChargedDirectDebitFailureFee,
        #[serde(rename = "partner-commission")]
        PartnerCommission,
        #[serde(rename = "application-fee")]
        ApplicationFee,
        #[serde(rename = "capture-fee")]
        CaptureFee,
        #[serde(rename = "refund-fee")]
        RefundFee,
        #[serde(rename = "chargeback-fee")]
        ChargebackFee,
        #[serde(rename = "payment-notification-fee")]
        PaymentNotificationFee,
        #[serde(rename = "transfer-notification-fee")]
        TransferNotificationFee,
        #[serde(rename = "payout-fee")]
        PayoutFee,
        #[serde(rename = "fee-discount")]
        FeeDiscount,
        #[serde(rename = "fee-reimbursement")]
        FeeReimbursement,
        #[serde(rename = "platform-volume-fee")]
        PlatformVolumeFee,
        #[serde(rename = "platform-connected-organizations-fee")]
        PlatformConnectedOrganizationsFee,
        #[serde(rename = "balance-charge-fee")]
        BalanceChargeFee,
        #[serde(rename = "3ds-authentication-attempt-fee")]
        X3dsAuthenticationAttemptFee,
        #[serde(rename = "terminal-monthly-fee")]
        TerminalMonthlyFee,
        #[serde(rename = "acceptance-risk-fee")]
        AcceptanceRiskFee,
        #[serde(rename = "top-up-fee")]
        TopUpFee,
        #[serde(rename = "payment-gateway-fee")]
        PaymentGatewayFee,
        #[serde(rename = "mastercard-specialty-merchant-program-processing-fee")]
        MastercardSpecialtyMerchantProgramProcessingFee,
        #[serde(rename = "mastercard-specialty-merchant-program-registration-fee")]
        MastercardSpecialtyMerchantProgramRegistrationFee,
        #[serde(rename = "visa-integrity-risk-program-processing-fee")]
        VisaIntegrityRiskProgramProcessingFee,
        #[serde(rename = "visa-integrity-risk-program-registration-fee")]
        VisaIntegrityRiskProgramRegistrationFee,
        #[serde(rename = "minimum-invoice-amount-fee")]
        MinimumInvoiceAmountFee,
    }

    impl ::std::convert::From<&Self> for ComponentsSubTotalsFeeType {
        fn from(value: &ComponentsSubTotalsFeeType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ComponentsSubTotalsFeeType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PaymentFee => f.write_str("payment-fee"),
                Self::DirectDebitFailureFee => f.write_str("direct-debit-failure-fee"),
                Self::UnauthorizedDirectDebitFee => f.write_str("unauthorized-direct-debit-fee"),
                Self::BankChargedDirectDebitFailureFee => {
                    f.write_str("bank-charged-direct-debit-failure-fee")
                }
                Self::PartnerCommission => f.write_str("partner-commission"),
                Self::ApplicationFee => f.write_str("application-fee"),
                Self::CaptureFee => f.write_str("capture-fee"),
                Self::RefundFee => f.write_str("refund-fee"),
                Self::ChargebackFee => f.write_str("chargeback-fee"),
                Self::PaymentNotificationFee => f.write_str("payment-notification-fee"),
                Self::TransferNotificationFee => f.write_str("transfer-notification-fee"),
                Self::PayoutFee => f.write_str("payout-fee"),
                Self::FeeDiscount => f.write_str("fee-discount"),
                Self::FeeReimbursement => f.write_str("fee-reimbursement"),
                Self::PlatformVolumeFee => f.write_str("platform-volume-fee"),
                Self::PlatformConnectedOrganizationsFee => {
                    f.write_str("platform-connected-organizations-fee")
                }
                Self::BalanceChargeFee => f.write_str("balance-charge-fee"),
                Self::X3dsAuthenticationAttemptFee => f.write_str("3ds-authentication-attempt-fee"),
                Self::TerminalMonthlyFee => f.write_str("terminal-monthly-fee"),
                Self::AcceptanceRiskFee => f.write_str("acceptance-risk-fee"),
                Self::TopUpFee => f.write_str("top-up-fee"),
                Self::PaymentGatewayFee => f.write_str("payment-gateway-fee"),
                Self::MastercardSpecialtyMerchantProgramProcessingFee => {
                    f.write_str("mastercard-specialty-merchant-program-processing-fee")
                }
                Self::MastercardSpecialtyMerchantProgramRegistrationFee => {
                    f.write_str("mastercard-specialty-merchant-program-registration-fee")
                }
                Self::VisaIntegrityRiskProgramProcessingFee => {
                    f.write_str("visa-integrity-risk-program-processing-fee")
                }
                Self::VisaIntegrityRiskProgramRegistrationFee => {
                    f.write_str("visa-integrity-risk-program-registration-fee")
                }
                Self::MinimumInvoiceAmountFee => f.write_str("minimum-invoice-amount-fee"),
            }
        }
    }

    impl ::std::str::FromStr for ComponentsSubTotalsFeeType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "payment-fee" => Ok(Self::PaymentFee),
                "direct-debit-failure-fee" => Ok(Self::DirectDebitFailureFee),
                "unauthorized-direct-debit-fee" => Ok(Self::UnauthorizedDirectDebitFee),
                "bank-charged-direct-debit-failure-fee" => {
                    Ok(Self::BankChargedDirectDebitFailureFee)
                }
                "partner-commission" => Ok(Self::PartnerCommission),
                "application-fee" => Ok(Self::ApplicationFee),
                "capture-fee" => Ok(Self::CaptureFee),
                "refund-fee" => Ok(Self::RefundFee),
                "chargeback-fee" => Ok(Self::ChargebackFee),
                "payment-notification-fee" => Ok(Self::PaymentNotificationFee),
                "transfer-notification-fee" => Ok(Self::TransferNotificationFee),
                "payout-fee" => Ok(Self::PayoutFee),
                "fee-discount" => Ok(Self::FeeDiscount),
                "fee-reimbursement" => Ok(Self::FeeReimbursement),
                "platform-volume-fee" => Ok(Self::PlatformVolumeFee),
                "platform-connected-organizations-fee" => {
                    Ok(Self::PlatformConnectedOrganizationsFee)
                }
                "balance-charge-fee" => Ok(Self::BalanceChargeFee),
                "3ds-authentication-attempt-fee" => Ok(Self::X3dsAuthenticationAttemptFee),
                "terminal-monthly-fee" => Ok(Self::TerminalMonthlyFee),
                "acceptance-risk-fee" => Ok(Self::AcceptanceRiskFee),
                "top-up-fee" => Ok(Self::TopUpFee),
                "payment-gateway-fee" => Ok(Self::PaymentGatewayFee),
                "mastercard-specialty-merchant-program-processing-fee" => {
                    Ok(Self::MastercardSpecialtyMerchantProgramProcessingFee)
                }
                "mastercard-specialty-merchant-program-registration-fee" => {
                    Ok(Self::MastercardSpecialtyMerchantProgramRegistrationFee)
                }
                "visa-integrity-risk-program-processing-fee" => {
                    Ok(Self::VisaIntegrityRiskProgramProcessingFee)
                }
                "visa-integrity-risk-program-registration-fee" => {
                    Ok(Self::VisaIntegrityRiskProgramRegistrationFee)
                }
                "minimum-invoice-amount-fee" => Ok(Self::MinimumInvoiceAmountFee),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ComponentsSubTotalsFeeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ComponentsSubTotalsFeeType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ComponentsSubTotalsFeeType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Prepayment part: fee itself, reimbursement, discount, VAT or rounding
    /// compensation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Prepayment part: fee itself, reimbursement, discount,
    /// VAT or rounding compensation.",
    ///  "examples": [
    ///    "fee"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "fee",
    ///    "fee-reimbursement",
    ///    "fee-discount",
    ///    "fee-vat",
    ///    "fee-rounding-compensation"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ComponentsSubTotalsPrepaymentPartType {
        #[serde(rename = "fee")]
        Fee,
        #[serde(rename = "fee-reimbursement")]
        FeeReimbursement,
        #[serde(rename = "fee-discount")]
        FeeDiscount,
        #[serde(rename = "fee-vat")]
        FeeVat,
        #[serde(rename = "fee-rounding-compensation")]
        FeeRoundingCompensation,
    }

    impl ::std::convert::From<&Self> for ComponentsSubTotalsPrepaymentPartType {
        fn from(value: &ComponentsSubTotalsPrepaymentPartType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ComponentsSubTotalsPrepaymentPartType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Fee => f.write_str("fee"),
                Self::FeeReimbursement => f.write_str("fee-reimbursement"),
                Self::FeeDiscount => f.write_str("fee-discount"),
                Self::FeeVat => f.write_str("fee-vat"),
                Self::FeeRoundingCompensation => f.write_str("fee-rounding-compensation"),
            }
        }
    }

    impl ::std::str::FromStr for ComponentsSubTotalsPrepaymentPartType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "fee" => Ok(Self::Fee),
                "fee-reimbursement" => Ok(Self::FeeReimbursement),
                "fee-discount" => Ok(Self::FeeDiscount),
                "fee-vat" => Ok(Self::FeeVat),
                "fee-rounding-compensation" => Ok(Self::FeeRoundingCompensation),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ComponentsSubTotalsPrepaymentPartType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ComponentsSubTotalsPrepaymentPartType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ComponentsSubTotalsPrepaymentPartType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents the transaction type
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the transaction type",
    ///  "examples": [
    ///    "payment"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "payment",
    ///    "split-payment",
    ///    "failed-payment",
    ///    "failed-platform-split-payment",
    ///    "failed-split-payment-compensation",
    ///    "capture",
    ///    "split-transaction",
    ///    "refund",
    ///    "platform-payment-refund",
    ///    "returned-platform-payment-refund",
    ///    "refund-compensation",
    ///    "returned-refund-compensation",
    ///    "returned-refund",
    ///    "chargeback",
    ///    "chargeback-reversal",
    ///    "chargeback-compensation",
    ///    "reversed-chargeback-compensation",
    ///    "platform-payment-chargeback",
    ///    "reversed-platform-payment-chargeback",
    ///    "fee-prepayment",
    ///    "outgoing-transfer",
    ///    "incoming-transfer",
    ///    "canceled-transfer",
    ///    "returned-transfer",
    ///    "balance-reserve",
    ///    "balance-reserve-return",
    ///    "invoice-rounding-compensation",
    ///    "rolling-reserve-hold",
    ///    "rolling-reserve-release",
    ///    "balance-correction",
    ///    "repayment",
    ///    "loan",
    ///    "balance-topup",
    ///    "cash-collateral-issuance';",
    ///    "cash-collateral-release",
    ///    "pending-rolling-reserve",
    ///    "to-be-released-rolling-reserve",
    ///    "held-rolling-reserve",
    ///    "released-rolling-reserve"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ComponentsSubTotalsTransactionType {
        #[serde(rename = "payment")]
        Payment,
        #[serde(rename = "split-payment")]
        SplitPayment,
        #[serde(rename = "failed-payment")]
        FailedPayment,
        #[serde(rename = "failed-platform-split-payment")]
        FailedPlatformSplitPayment,
        #[serde(rename = "failed-split-payment-compensation")]
        FailedSplitPaymentCompensation,
        #[serde(rename = "capture")]
        Capture,
        #[serde(rename = "split-transaction")]
        SplitTransaction,
        #[serde(rename = "refund")]
        Refund,
        #[serde(rename = "platform-payment-refund")]
        PlatformPaymentRefund,
        #[serde(rename = "returned-platform-payment-refund")]
        ReturnedPlatformPaymentRefund,
        #[serde(rename = "refund-compensation")]
        RefundCompensation,
        #[serde(rename = "returned-refund-compensation")]
        ReturnedRefundCompensation,
        #[serde(rename = "returned-refund")]
        ReturnedRefund,
        #[serde(rename = "chargeback")]
        Chargeback,
        #[serde(rename = "chargeback-reversal")]
        ChargebackReversal,
        #[serde(rename = "chargeback-compensation")]
        ChargebackCompensation,
        #[serde(rename = "reversed-chargeback-compensation")]
        ReversedChargebackCompensation,
        #[serde(rename = "platform-payment-chargeback")]
        PlatformPaymentChargeback,
        #[serde(rename = "reversed-platform-payment-chargeback")]
        ReversedPlatformPaymentChargeback,
        #[serde(rename = "fee-prepayment")]
        FeePrepayment,
        #[serde(rename = "outgoing-transfer")]
        OutgoingTransfer,
        #[serde(rename = "incoming-transfer")]
        IncomingTransfer,
        #[serde(rename = "canceled-transfer")]
        CanceledTransfer,
        #[serde(rename = "returned-transfer")]
        ReturnedTransfer,
        #[serde(rename = "balance-reserve")]
        BalanceReserve,
        #[serde(rename = "balance-reserve-return")]
        BalanceReserveReturn,
        #[serde(rename = "invoice-rounding-compensation")]
        InvoiceRoundingCompensation,
        #[serde(rename = "rolling-reserve-hold")]
        RollingReserveHold,
        #[serde(rename = "rolling-reserve-release")]
        RollingReserveRelease,
        #[serde(rename = "balance-correction")]
        BalanceCorrection,
        #[serde(rename = "repayment")]
        Repayment,
        #[serde(rename = "loan")]
        Loan,
        #[serde(rename = "balance-topup")]
        BalanceTopup,
        #[serde(rename = "cash-collateral-issuance';")]
        CashCollateralIssuance,
        #[serde(rename = "cash-collateral-release")]
        CashCollateralRelease,
        #[serde(rename = "pending-rolling-reserve")]
        PendingRollingReserve,
        #[serde(rename = "to-be-released-rolling-reserve")]
        ToBeReleasedRollingReserve,
        #[serde(rename = "held-rolling-reserve")]
        HeldRollingReserve,
        #[serde(rename = "released-rolling-reserve")]
        ReleasedRollingReserve,
    }

    impl ::std::convert::From<&Self> for ComponentsSubTotalsTransactionType {
        fn from(value: &ComponentsSubTotalsTransactionType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ComponentsSubTotalsTransactionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Payment => f.write_str("payment"),
                Self::SplitPayment => f.write_str("split-payment"),
                Self::FailedPayment => f.write_str("failed-payment"),
                Self::FailedPlatformSplitPayment => f.write_str("failed-platform-split-payment"),
                Self::FailedSplitPaymentCompensation => {
                    f.write_str("failed-split-payment-compensation")
                }
                Self::Capture => f.write_str("capture"),
                Self::SplitTransaction => f.write_str("split-transaction"),
                Self::Refund => f.write_str("refund"),
                Self::PlatformPaymentRefund => f.write_str("platform-payment-refund"),
                Self::ReturnedPlatformPaymentRefund => {
                    f.write_str("returned-platform-payment-refund")
                }
                Self::RefundCompensation => f.write_str("refund-compensation"),
                Self::ReturnedRefundCompensation => f.write_str("returned-refund-compensation"),
                Self::ReturnedRefund => f.write_str("returned-refund"),
                Self::Chargeback => f.write_str("chargeback"),
                Self::ChargebackReversal => f.write_str("chargeback-reversal"),
                Self::ChargebackCompensation => f.write_str("chargeback-compensation"),
                Self::ReversedChargebackCompensation => {
                    f.write_str("reversed-chargeback-compensation")
                }
                Self::PlatformPaymentChargeback => f.write_str("platform-payment-chargeback"),
                Self::ReversedPlatformPaymentChargeback => {
                    f.write_str("reversed-platform-payment-chargeback")
                }
                Self::FeePrepayment => f.write_str("fee-prepayment"),
                Self::OutgoingTransfer => f.write_str("outgoing-transfer"),
                Self::IncomingTransfer => f.write_str("incoming-transfer"),
                Self::CanceledTransfer => f.write_str("canceled-transfer"),
                Self::ReturnedTransfer => f.write_str("returned-transfer"),
                Self::BalanceReserve => f.write_str("balance-reserve"),
                Self::BalanceReserveReturn => f.write_str("balance-reserve-return"),
                Self::InvoiceRoundingCompensation => f.write_str("invoice-rounding-compensation"),
                Self::RollingReserveHold => f.write_str("rolling-reserve-hold"),
                Self::RollingReserveRelease => f.write_str("rolling-reserve-release"),
                Self::BalanceCorrection => f.write_str("balance-correction"),
                Self::Repayment => f.write_str("repayment"),
                Self::Loan => f.write_str("loan"),
                Self::BalanceTopup => f.write_str("balance-topup"),
                Self::CashCollateralIssuance => f.write_str("cash-collateral-issuance';"),
                Self::CashCollateralRelease => f.write_str("cash-collateral-release"),
                Self::PendingRollingReserve => f.write_str("pending-rolling-reserve"),
                Self::ToBeReleasedRollingReserve => f.write_str("to-be-released-rolling-reserve"),
                Self::HeldRollingReserve => f.write_str("held-rolling-reserve"),
                Self::ReleasedRollingReserve => f.write_str("released-rolling-reserve"),
            }
        }
    }

    impl ::std::str::FromStr for ComponentsSubTotalsTransactionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "payment" => Ok(Self::Payment),
                "split-payment" => Ok(Self::SplitPayment),
                "failed-payment" => Ok(Self::FailedPayment),
                "failed-platform-split-payment" => Ok(Self::FailedPlatformSplitPayment),
                "failed-split-payment-compensation" => Ok(Self::FailedSplitPaymentCompensation),
                "capture" => Ok(Self::Capture),
                "split-transaction" => Ok(Self::SplitTransaction),
                "refund" => Ok(Self::Refund),
                "platform-payment-refund" => Ok(Self::PlatformPaymentRefund),
                "returned-platform-payment-refund" => Ok(Self::ReturnedPlatformPaymentRefund),
                "refund-compensation" => Ok(Self::RefundCompensation),
                "returned-refund-compensation" => Ok(Self::ReturnedRefundCompensation),
                "returned-refund" => Ok(Self::ReturnedRefund),
                "chargeback" => Ok(Self::Chargeback),
                "chargeback-reversal" => Ok(Self::ChargebackReversal),
                "chargeback-compensation" => Ok(Self::ChargebackCompensation),
                "reversed-chargeback-compensation" => Ok(Self::ReversedChargebackCompensation),
                "platform-payment-chargeback" => Ok(Self::PlatformPaymentChargeback),
                "reversed-platform-payment-chargeback" => {
                    Ok(Self::ReversedPlatformPaymentChargeback)
                }
                "fee-prepayment" => Ok(Self::FeePrepayment),
                "outgoing-transfer" => Ok(Self::OutgoingTransfer),
                "incoming-transfer" => Ok(Self::IncomingTransfer),
                "canceled-transfer" => Ok(Self::CanceledTransfer),
                "returned-transfer" => Ok(Self::ReturnedTransfer),
                "balance-reserve" => Ok(Self::BalanceReserve),
                "balance-reserve-return" => Ok(Self::BalanceReserveReturn),
                "invoice-rounding-compensation" => Ok(Self::InvoiceRoundingCompensation),
                "rolling-reserve-hold" => Ok(Self::RollingReserveHold),
                "rolling-reserve-release" => Ok(Self::RollingReserveRelease),
                "balance-correction" => Ok(Self::BalanceCorrection),
                "repayment" => Ok(Self::Repayment),
                "loan" => Ok(Self::Loan),
                "balance-topup" => Ok(Self::BalanceTopup),
                "cash-collateral-issuance';" => Ok(Self::CashCollateralIssuance),
                "cash-collateral-release" => Ok(Self::CashCollateralRelease),
                "pending-rolling-reserve" => Ok(Self::PendingRollingReserve),
                "to-be-released-rolling-reserve" => Ok(Self::ToBeReleasedRollingReserve),
                "held-rolling-reserve" => Ok(Self::HeldRollingReserve),
                "released-rolling-reserve" => Ok(Self::ReleasedRollingReserve),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ComponentsSubTotalsTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ComponentsSubTotalsTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ComponentsSubTotalsTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ConnectBalanceTransferToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "cbtr_j8NvRAM2WNZtsykpLEX8J"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct ConnectBalanceTransferToken(pub ::std::string::String);
    impl ::std::ops::Deref for ConnectBalanceTransferToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<ConnectBalanceTransferToken> for ::std::string::String {
        fn from(value: ConnectBalanceTransferToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&ConnectBalanceTransferToken> for ConnectBalanceTransferToken {
        fn from(value: &ConnectBalanceTransferToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for ConnectBalanceTransferToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for ConnectBalanceTransferToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for ConnectBalanceTransferToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`ConnectRouteToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "crt_dyARQ3JzCgtPDhU2Pbq3J"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct ConnectRouteToken(pub ::std::string::String);
    impl ::std::ops::Deref for ConnectRouteToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<ConnectRouteToken> for ::std::string::String {
        fn from(value: ConnectRouteToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&ConnectRouteToken> for ConnectRouteToken {
        fn from(value: &ConnectRouteToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for ConnectRouteToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for ConnectRouteToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for ConnectRouteToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`CreatePaymentLinkBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "required": [
    ///    "description"
    ///  ],
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "paymentLink",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "paymentLink": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "allowedMethods": {
    ///      "$ref": "#/components/schemas/payment-link-methods"
    ///    },
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "applicationFee": {
    ///      "description": "With Mollie Connect you can charge fees on payment
    /// links that your app is processing on behalf of other
    /// Mollie\nmerchants.\n\nIf you use OAuth to create payment links on a
    /// connected merchant's account, you can charge a fee using
    /// this\n`applicationFee` parameter. If a payment on the payment link
    /// succeeds, the fee will be deducted from the merchant's balance and
    /// sent\nto your own account balance.",
    ///      "type": "object",
    ///      "required": [
    ///        "amount",
    ///        "description"
    ///      ],
    ///      "properties": {
    ///        "amount": {
    ///          "$ref": "#/components/schemas/amount"
    ///        },
    ///        "description": {
    ///          "description": "The description of the application fee. This
    /// will appear on settlement reports towards both you and the\nconnected
    /// merchant.",
    ///          "examples": [
    ///            "Platform fee"
    ///          ],
    ///          "type": "string",
    ///          "maxLength": 255
    ///        }
    ///      }
    ///    },
    ///    "archived": {
    ///      "description": "Whether the payment link is archived. Customers
    /// will not be able to complete payments on archived payment links.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "billingAddress": {
    ///      "$ref": "#/components/schemas/payment-address"
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "customerId": {
    ///      "description": "**Only relevant when `sequenceType` is set to
    /// `first`**\n\nThe ID of the [customer](get-customer) the payment link is
    /// being created for. If a value is not provided,\nthe customer will be
    /// required to input relevant information which will be used to establish a
    /// mandate after\nthe payment is made.",
    ///      "examples": [
    ///        "cst_XimFHuaEzd"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "description": {
    ///      "description": "A short description of the payment link. The
    /// description is visible in the Dashboard and will be shown on
    /// the\ncustomer's bank or card statement when possible.",
    ///      "examples": [
    ///        "Chess Board"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "expiresAt": {
    ///      "description": "The date and time the payment link is set to
    /// expire, in ISO 8601 format. If no expiry date was provided up
    /// front,\nthe payment link will not expire automatically.",
    ///      "examples": [
    ///        "2025-12-24T11:00:16+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/paymentLinkToken"
    ///    },
    ///    "lines": {
    ///      "description": "Optionally provide the order lines for the payment.
    /// Each line contains details such as a description of the item\nordered
    /// and its price.\n\nAll lines must have the same currency as the
    /// payment.\n\nRequired for payment methods `billie`, `in3`, `klarna`,
    /// `riverty` and `voucher`.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/payment-line-item"
    ///      }
    ///    },
    ///    "minimumAmount": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "paidAt": {
    ///      "description": "The date and time the payment link became paid, in
    /// ISO 8601 format.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2025-12-24T11:00:16+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "profileId": {
    ///      "description": "The identifier referring to the
    /// [profile](get-profile) this entity belongs to.\n\nMost API credentials
    /// are linked to a single profile. In these cases the `profileId` can be
    /// omitted in the creation\nrequest. For organization-level credentials
    /// such as OAuth access tokens however, the `profileId` parameter
    /// is\nrequired.",
    ///      "examples": [
    ///        "pfl_QkEhN94Ba"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "redirectUrl": {
    ///      "description": "The URL your customer will be redirected to after completing the payment process. If no redirect URL is provided,\nthe customer will be shown a generic message after completing the payment.",
    ///      "examples": [
    ///        "https://webshop.example.org/payment-links/redirect/"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a payment link
    /// object. Will always contain the string `payment-link` for
    /// this\nendpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "payment-link"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "reusable": {
    ///      "description": "Indicates whether the payment link is reusable. If
    /// this field is set to `true`, customers can make multiple\npayments using
    /// the same link.\n\nIf no value is specified, the field defaults to
    /// `false`, allowing only a single payment per link.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "sequenceType": {
    ///      "$ref": "#/components/schemas/payment-link-sequence-type"
    ///    },
    ///    "shippingAddress": {
    ///      "$ref": "#/components/schemas/payment-address"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    },
    ///    "webhookUrl": {
    ///      "description": "The webhook URL where we will send payment status
    /// updates to.\n\nThe webhookUrl is optional, but without a webhook you
    /// will miss out on important status changes to any payments\nresulting
    /// from the payment link.\n\nThe webhookUrl must be reachable from Mollie's
    /// point of view, so you cannot use `localhost`. If you want to
    /// use\nwebhook during development on `localhost`, you must use a tool like
    /// ngrok to have the webhooks delivered to your\nlocal machine.",
    ///      "examples": [
    ///        "https://webshop.example.org/payment-links/webhook/"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreatePaymentLinkBody {
        #[serde(
            rename = "allowedMethods",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub allowed_methods: ::std::option::Option<PaymentLinkMethods>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<AmountNullable>,
        #[serde(
            rename = "applicationFee",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub application_fee: ::std::option::Option<CreatePaymentLinkBodyApplicationFee>,
        ///Whether the payment link is archived. Customers will not be able to
        /// complete payments on archived payment links.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub archived: ::std::option::Option<bool>,
        #[serde(
            rename = "billingAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub billing_address: ::std::option::Option<PaymentAddress>,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        ///**Only relevant when `sequenceType` is set to `first`**
        ///
        ///The ID of the [customer](get-customer) the payment link is being
        /// created for. If a value is not provided, the customer will
        /// be required to input relevant information which will be used to
        /// establish a mandate after the payment is made.
        #[serde(
            rename = "customerId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub customer_id: ::std::option::Option<::std::string::String>,
        ///A short description of the payment link. The description is visible
        /// in the Dashboard and will be shown on the customer's bank or
        /// card statement when possible.
        pub description: CreatePaymentLinkBodyDescription,
        ///The date and time the payment link is set to expire, in ISO 8601
        /// format. If no expiry date was provided up front, the payment
        /// link will not expire automatically.
        #[serde(
            rename = "expiresAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub expires_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<PaymentLinkToken>,
        ///Optionally provide the order lines for the payment. Each line
        /// contains details such as a description of the item
        /// ordered and its price.
        ///
        ///All lines must have the same currency as the payment.
        ///
        ///Required for payment methods `billie`, `in3`, `klarna`, `riverty`
        /// and `voucher`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub lines: ::std::option::Option<::std::vec::Vec<PaymentLineItem>>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<CreatePaymentLinkBodyLinks>,
        #[serde(
            rename = "minimumAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub minimum_amount: ::std::option::Option<AmountNullable>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<Mode>,
        ///The date and time the payment link became paid, in ISO 8601 format.
        #[serde(
            rename = "paidAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paid_at: ::std::option::Option<::std::string::String>,
        ///The identifier referring to the [profile](get-profile) this entity
        /// belongs to.
        ///
        ///Most API credentials are linked to a single profile. In these cases
        /// the `profileId` can be omitted in the creation request. For
        /// organization-level credentials such as OAuth access tokens however,
        /// the `profileId` parameter is required.
        #[serde(
            rename = "profileId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub profile_id: ::std::option::Option<::std::string::String>,
        ///The URL your customer will be redirected to after completing the
        /// payment process. If no redirect URL is provided,
        /// the customer will be shown a generic message after completing the
        /// payment.
        #[serde(
            rename = "redirectUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub redirect_url: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a payment link object. Will always
        /// contain the string `payment-link` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        ///Indicates whether the payment link is reusable. If this field is set
        /// to `true`, customers can make multiple payments using the
        /// same link.
        ///
        ///If no value is specified, the field defaults to `false`, allowing
        /// only a single payment per link.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub reusable: ::std::option::Option<bool>,
        #[serde(
            rename = "sequenceType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub sequence_type: ::std::option::Option<PaymentLinkSequenceType>,
        #[serde(
            rename = "shippingAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub shipping_address: ::std::option::Option<PaymentAddress>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
        ///The webhook URL where we will send payment status updates to.
        ///
        ///The webhookUrl is optional, but without a webhook you will miss out
        /// on important status changes to any payments resulting from
        /// the payment link.
        ///
        ///The webhookUrl must be reachable from Mollie's point of view, so you
        /// cannot use `localhost`. If you want to use webhook during
        /// development on `localhost`, you must use a tool like ngrok to have
        /// the webhooks delivered to your local machine.
        #[serde(
            rename = "webhookUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub webhook_url: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&CreatePaymentLinkBody> for CreatePaymentLinkBody {
        fn from(value: &CreatePaymentLinkBody) -> Self {
            value.clone()
        }
    }

    ///With Mollie Connect you can charge fees on payment links that your app
    /// is processing on behalf of other Mollie merchants.
    ///
    ///If you use OAuth to create payment links on a connected merchant's
    /// account, you can charge a fee using this `applicationFee` parameter.
    /// If a payment on the payment link succeeds, the fee will be deducted from
    /// the merchant's balance and sent to your own account balance.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "With Mollie Connect you can charge fees on payment
    /// links that your app is processing on behalf of other
    /// Mollie\nmerchants.\n\nIf you use OAuth to create payment links on a
    /// connected merchant's account, you can charge a fee using
    /// this\n`applicationFee` parameter. If a payment on the payment link
    /// succeeds, the fee will be deducted from the merchant's balance and
    /// sent\nto your own account balance.",
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "description"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "description": {
    ///      "description": "The description of the application fee. This will
    /// appear on settlement reports towards both you and the\nconnected
    /// merchant.",
    ///      "examples": [
    ///        "Platform fee"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreatePaymentLinkBodyApplicationFee {
        pub amount: Amount,
        ///The description of the application fee. This will appear on
        /// settlement reports towards both you and the
        /// connected merchant.
        pub description: CreatePaymentLinkBodyApplicationFeeDescription,
    }

    impl ::std::convert::From<&CreatePaymentLinkBodyApplicationFee>
        for CreatePaymentLinkBodyApplicationFee
    {
        fn from(value: &CreatePaymentLinkBodyApplicationFee) -> Self {
            value.clone()
        }
    }

    ///The description of the application fee. This will appear on settlement
    /// reports towards both you and the connected merchant.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The description of the application fee. This will
    /// appear on settlement reports towards both you and the\nconnected
    /// merchant.",
    ///  "examples": [
    ///    "Platform fee"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreatePaymentLinkBodyApplicationFeeDescription(::std::string::String);
    impl ::std::ops::Deref for CreatePaymentLinkBodyApplicationFeeDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreatePaymentLinkBodyApplicationFeeDescription>
        for ::std::string::String
    {
        fn from(value: CreatePaymentLinkBodyApplicationFeeDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreatePaymentLinkBodyApplicationFeeDescription>
        for CreatePaymentLinkBodyApplicationFeeDescription
    {
        fn from(value: &CreatePaymentLinkBodyApplicationFeeDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreatePaymentLinkBodyApplicationFeeDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreatePaymentLinkBodyApplicationFeeDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreatePaymentLinkBodyApplicationFeeDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for CreatePaymentLinkBodyApplicationFeeDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreatePaymentLinkBodyApplicationFeeDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///A short description of the payment link. The description is visible in
    /// the Dashboard and will be shown on the customer's bank or card
    /// statement when possible.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A short description of the payment link. The
    /// description is visible in the Dashboard and will be shown on
    /// the\ncustomer's bank or card statement when possible.",
    ///  "examples": [
    ///    "Chess Board"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreatePaymentLinkBodyDescription(::std::string::String);
    impl ::std::ops::Deref for CreatePaymentLinkBodyDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreatePaymentLinkBodyDescription> for ::std::string::String {
        fn from(value: CreatePaymentLinkBodyDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreatePaymentLinkBodyDescription> for CreatePaymentLinkBodyDescription {
        fn from(value: &CreatePaymentLinkBodyDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreatePaymentLinkBodyDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreatePaymentLinkBodyDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreatePaymentLinkBodyDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreatePaymentLinkBodyDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreatePaymentLinkBodyDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "paymentLink",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "paymentLink": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreatePaymentLinkBodyLinks {
        #[serde(rename = "paymentLink")]
        pub payment_link: Url,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&CreatePaymentLinkBodyLinks> for CreatePaymentLinkBodyLinks {
        fn from(value: &CreatePaymentLinkBodyLinks) -> Self {
            value.clone()
        }
    }

    ///`CreateWebhook`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_links",
    ///    "createdAt",
    ///    "eventTypes",
    ///    "id",
    ///    "mode",
    ///    "name",
    ///    "profileId",
    ///    "resource",
    ///    "status",
    ///    "url",
    ///    "webhookSecret"
    ///  ],
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "documentation",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "createdAt": {
    ///      "description": "The subscription's date time of creation.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2023-01-01T12:00:00Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "eventTypes": {
    ///      "description": "The events types that are subscribed.",
    ///      "examples": [
    ///        [
    ///          "sales-invoice.paid, sales-invoice.canceled"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/webhook-event-types-response"
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "The identifier uniquely referring to this
    /// subscription.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "hook_tNP6fpF9fLJpFWziRcgiH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "name": {
    ///      "description": "The subscription's name.",
    ///      "examples": [
    ///        "Profile Updates Webhook"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "profileId": {
    ///      "description": "The identifier uniquely referring to the profile
    /// that created the subscription.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "pfl_YyoaNFjtHc"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a webhook
    /// subscription object. Will always contain the string `webhook` for this
    /// endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "webhook"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/webhook-status"
    ///    },
    ///    "url": {
    ///      "description": "The subscription's events destination.",
    ///      "examples": [
    ///        "https://example.com/webhook-endpoint"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "webhookSecret": {
    ///      "description": "The subscription's secret.",
    ///      "examples": [
    ///        "secret"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateWebhook {
        ///The subscription's date time of creation.
        #[serde(rename = "createdAt")]
        pub created_at: ::std::string::String,
        ///The events types that are subscribed.
        #[serde(rename = "eventTypes")]
        pub event_types: ::std::vec::Vec<WebhookEventTypesResponse>,
        ///The identifier uniquely referring to this subscription.
        pub id: ::std::string::String,
        #[serde(rename = "_links")]
        pub links: CreateWebhookLinks,
        pub mode: Mode,
        ///The subscription's name.
        pub name: ::std::string::String,
        ///The identifier uniquely referring to the profile that created the
        /// subscription.
        #[serde(rename = "profileId")]
        pub profile_id: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a webhook subscription object. Will
        /// always contain the string `webhook` for this endpoint.
        pub resource: ::std::string::String,
        pub status: WebhookStatus,
        ///The subscription's events destination.
        pub url: ::std::string::String,
        ///The subscription's secret.
        #[serde(rename = "webhookSecret")]
        pub webhook_secret: ::std::string::String,
    }

    impl ::std::convert::From<&CreateWebhook> for CreateWebhook {
        fn from(value: &CreateWebhook) -> Self {
            value.clone()
        }
    }

    ///`CreateWebhookBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "eventTypes",
    ///    "name",
    ///    "url"
    ///  ],
    ///  "properties": {
    ///    "eventTypes": {
    ///      "$ref": "#/components/schemas/webhook-event-types"
    ///    },
    ///    "name": {
    ///      "description": "A name that identifies the webhook.",
    ///      "examples": [
    ///        "Webhook #1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    },
    ///    "url": {
    ///      "description": "The URL Mollie will send the events to. This URL
    /// must be publicly accessible.",
    ///      "examples": [
    ///        "https://mollie.com/"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateWebhookBody {
        #[serde(rename = "eventTypes")]
        pub event_types: WebhookEventTypes,
        ///A name that identifies the webhook.
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
        ///The URL Mollie will send the events to. This URL must be publicly
        /// accessible.
        pub url: ::std::string::String,
    }

    impl ::std::convert::From<&CreateWebhookBody> for CreateWebhookBody {
        fn from(value: &CreateWebhookBody) -> Self {
            value.clone()
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "documentation",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateWebhookLinks {
        pub documentation: Url,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&CreateWebhookLinks> for CreateWebhookLinks {
        fn from(value: &CreateWebhookLinks) -> Self {
            value.clone()
        }
    }

    ///The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.",
    ///  "readOnly": true,
    ///  "examples": [
    ///    "2024-03-20T09:13:37.0Z"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct CreatedAt(pub ::std::string::String);
    impl ::std::ops::Deref for CreatedAt {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreatedAt> for ::std::string::String {
        fn from(value: CreatedAt) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreatedAt> for CreatedAt {
        fn from(value: &CreatedAt) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for CreatedAt {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for CreatedAt {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for CreatedAt {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`Currencies`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "EUR"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "EUR",
    ///    "GBP",
    ///    "CHF",
    ///    "DKK",
    ///    "NOK",
    ///    "PLN",
    ///    "SEK",
    ///    "USD",
    ///    "CZK",
    ///    "HUF",
    ///    "AUD",
    ///    "CAD"
    ///  ],
    ///  "x-enumDescriptions": {
    ///    "AUD": "Australian Dollar",
    ///    "CAD": "Canadian Dollar",
    ///    "CHF": "Swiss Franc",
    ///    "CZK": "Czech Koruna",
    ///    "DKK": "Danish Krone",
    ///    "EUR": "Euro",
    ///    "GBP": "British Pound",
    ///    "HUF": "Hungarian Forint",
    ///    "NOK": "Norwegian Krone",
    ///    "PLN": "Polish złoty",
    ///    "SEK": "Swedish Krona",
    ///    "USD": "United States Dollar"
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum Currencies {
        #[serde(rename = "EUR")]
        Eur,
        #[serde(rename = "GBP")]
        Gbp,
        #[serde(rename = "CHF")]
        Chf,
        #[serde(rename = "DKK")]
        Dkk,
        #[serde(rename = "NOK")]
        Nok,
        #[serde(rename = "PLN")]
        Pln,
        #[serde(rename = "SEK")]
        Sek,
        #[serde(rename = "USD")]
        Usd,
        #[serde(rename = "CZK")]
        Czk,
        #[serde(rename = "HUF")]
        Huf,
        #[serde(rename = "AUD")]
        Aud,
        #[serde(rename = "CAD")]
        Cad,
    }

    impl ::std::convert::From<&Self> for Currencies {
        fn from(value: &Currencies) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for Currencies {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Eur => f.write_str("EUR"),
                Self::Gbp => f.write_str("GBP"),
                Self::Chf => f.write_str("CHF"),
                Self::Dkk => f.write_str("DKK"),
                Self::Nok => f.write_str("NOK"),
                Self::Pln => f.write_str("PLN"),
                Self::Sek => f.write_str("SEK"),
                Self::Usd => f.write_str("USD"),
                Self::Czk => f.write_str("CZK"),
                Self::Huf => f.write_str("HUF"),
                Self::Aud => f.write_str("AUD"),
                Self::Cad => f.write_str("CAD"),
            }
        }
    }

    impl ::std::str::FromStr for Currencies {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "EUR" => Ok(Self::Eur),
                "GBP" => Ok(Self::Gbp),
                "CHF" => Ok(Self::Chf),
                "DKK" => Ok(Self::Dkk),
                "NOK" => Ok(Self::Nok),
                "PLN" => Ok(Self::Pln),
                "SEK" => Ok(Self::Sek),
                "USD" => Ok(Self::Usd),
                "CZK" => Ok(Self::Czk),
                "HUF" => Ok(Self::Huf),
                "AUD" => Ok(Self::Aud),
                "CAD" => Ok(Self::Cad),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for Currencies {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for Currencies {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for Currencies {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`CustomerResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/entity-customer-response"
    ///    }
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct CustomerResponse(pub EntityCustomerResponse);
    impl ::std::ops::Deref for CustomerResponse {
        type Target = EntityCustomerResponse;
        fn deref(&self) -> &EntityCustomerResponse {
            &self.0
        }
    }

    impl ::std::convert::From<CustomerResponse> for EntityCustomerResponse {
        fn from(value: CustomerResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CustomerResponse> for CustomerResponse {
        fn from(value: &CustomerResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<EntityCustomerResponse> for CustomerResponse {
        fn from(value: EntityCustomerResponse) -> Self {
            Self(value)
        }
    }

    ///`CustomerToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "cst_5B8cwPMGnU"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct CustomerToken(pub ::std::string::String);
    impl ::std::ops::Deref for CustomerToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CustomerToken> for ::std::string::String {
        fn from(value: CustomerToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CustomerToken> for CustomerToken {
        fn from(value: &CustomerToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for CustomerToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for CustomerToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for CustomerToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`DeleteCustomerBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeleteCustomerBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<Testmode>,
    }

    impl ::std::convert::From<&DeleteCustomerBody> for DeleteCustomerBody {
        fn from(value: &DeleteCustomerBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DeleteCustomerBody {
        fn default() -> Self {
            Self {
                testmode: Default::default(),
            }
        }
    }

    ///`DeletePaymentLinkBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeletePaymentLinkBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<Testmode>,
    }

    impl ::std::convert::From<&DeletePaymentLinkBody> for DeletePaymentLinkBody {
        fn from(value: &DeletePaymentLinkBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DeletePaymentLinkBody {
        fn default() -> Self {
            Self {
                testmode: Default::default(),
            }
        }
    }

    ///`DeleteValuesSalesInvoice`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeleteValuesSalesInvoice {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<Testmode>,
    }

    impl ::std::convert::From<&DeleteValuesSalesInvoice> for DeleteValuesSalesInvoice {
        fn from(value: &DeleteValuesSalesInvoice) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DeleteValuesSalesInvoice {
        fn default() -> Self {
            Self {
                testmode: Default::default(),
            }
        }
    }

    ///`DeleteWebhookBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeleteWebhookBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<Testmode>,
    }

    impl ::std::convert::From<&DeleteWebhookBody> for DeleteWebhookBody {
        fn from(value: &DeleteWebhookBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DeleteWebhookBody {
        fn default() -> Self {
            Self {
                testmode: Default::default(),
            }
        }
    }

    ///The description of the payment. This will be shown to your customer on
    /// their card or bank statement when possible. We truncate the
    /// description automatically according to the limits of the used payment
    /// method. The description is also visible in any exports you generate.
    ///
    ///We recommend you use a unique identifier so that you can always link the
    /// payment to the order in your back office. This is particularly
    /// useful for bookkeeping.
    ///
    ///The maximum length of the description field differs per payment method,
    /// with the absolute maximum being 255 characters. The API will not
    /// reject strings longer than the maximum length but it will truncate them
    /// to fit.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The description of the payment. This will be shown to
    /// your customer on their card or bank statement when possible.\nWe
    /// truncate the description automatically according to the limits of the
    /// used payment method. The description is\nalso visible in any exports you
    /// generate.\n\nWe recommend you use a unique identifier so that you can
    /// always link the payment to the order in your back office.\nThis is
    /// particularly useful for bookkeeping.\n\nThe maximum length of the
    /// description field differs per payment method, with the absolute maximum
    /// being 255\ncharacters. The API will not reject strings longer than the
    /// maximum length but it will truncate them to fit.",
    ///  "examples": [
    ///    "Chess Board"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct Description(::std::string::String);
    impl ::std::ops::Deref for Description {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<Description> for ::std::string::String {
        fn from(value: Description) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&Description> for Description {
        fn from(value: &Description) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Description {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Description {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for Description {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for Description {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Description {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`DisableMethodIssuerProfileId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/profileToken"
    ///    },
    ///    {
    ///      "examples": [
    ///        "me"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "me"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum DisableMethodIssuerProfileId {
        Variant0(ProfileToken),
        Variant1(DisableMethodIssuerProfileIdVariant1),
    }

    impl ::std::convert::From<&Self> for DisableMethodIssuerProfileId {
        fn from(value: &DisableMethodIssuerProfileId) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for DisableMethodIssuerProfileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<ProfileToken> for DisableMethodIssuerProfileId {
        fn from(value: ProfileToken) -> Self {
            Self::Variant0(value)
        }
    }

    impl ::std::convert::From<DisableMethodIssuerProfileIdVariant1> for DisableMethodIssuerProfileId {
        fn from(value: DisableMethodIssuerProfileIdVariant1) -> Self {
            Self::Variant1(value)
        }
    }

    ///`DisableMethodIssuerProfileIdVariant1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "me"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "me"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum DisableMethodIssuerProfileIdVariant1 {
        #[serde(rename = "me")]
        Me,
    }

    impl ::std::convert::From<&Self> for DisableMethodIssuerProfileIdVariant1 {
        fn from(value: &DisableMethodIssuerProfileIdVariant1) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for DisableMethodIssuerProfileIdVariant1 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Me => f.write_str("me"),
            }
        }
    }

    impl ::std::str::FromStr for DisableMethodIssuerProfileIdVariant1 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "me" => Ok(Self::Me),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for DisableMethodIssuerProfileIdVariant1 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for DisableMethodIssuerProfileIdVariant1 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for DisableMethodIssuerProfileIdVariant1 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`DisableMethodProfileId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/profileToken"
    ///    },
    ///    {
    ///      "examples": [
    ///        "me"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "me"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum DisableMethodProfileId {
        Variant0(ProfileToken),
        Variant1(DisableMethodProfileIdVariant1),
    }

    impl ::std::convert::From<&Self> for DisableMethodProfileId {
        fn from(value: &DisableMethodProfileId) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for DisableMethodProfileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<ProfileToken> for DisableMethodProfileId {
        fn from(value: ProfileToken) -> Self {
            Self::Variant0(value)
        }
    }

    impl ::std::convert::From<DisableMethodProfileIdVariant1> for DisableMethodProfileId {
        fn from(value: DisableMethodProfileIdVariant1) -> Self {
            Self::Variant1(value)
        }
    }

    ///`DisableMethodProfileIdVariant1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "me"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "me"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum DisableMethodProfileIdVariant1 {
        #[serde(rename = "me")]
        Me,
    }

    impl ::std::convert::From<&Self> for DisableMethodProfileIdVariant1 {
        fn from(value: &DisableMethodProfileIdVariant1) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for DisableMethodProfileIdVariant1 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Me => f.write_str("me"),
            }
        }
    }

    impl ::std::str::FromStr for DisableMethodProfileIdVariant1 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "me" => Ok(Self::Me),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for DisableMethodProfileIdVariant1 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for DisableMethodProfileIdVariant1 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for DisableMethodProfileIdVariant1 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The date by which the payment should be completed in `YYYY-MM-DD` format
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The date by which the payment should be completed in
    /// `YYYY-MM-DD` format",
    ///  "writeOnly": true,
    ///  "examples": [
    ///    "2025-01-01"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct DueDate(pub ::std::string::String);
    impl ::std::ops::Deref for DueDate {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<DueDate> for ::std::string::String {
        fn from(value: DueDate) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&DueDate> for DueDate {
        fn from(value: &DueDate) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for DueDate {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for DueDate {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for DueDate {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`EnableMethodIssuerBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "contractId": {
    ///      "description": "When enabling a voucher issuer, an inbetween party
    /// may be involved which you have a contract with.\nProvide the contract ID
    /// for the first time you enable an issuer via this contractor.\n\nYou can
    /// update the contract ID as long as it is not approved yet, by repeating
    /// the API call with a\ndifferent contract ID.",
    ///      "examples": [
    ///        "ideal"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EnableMethodIssuerBody {
        ///When enabling a voucher issuer, an inbetween party may be involved
        /// which you have a contract with. Provide the contract ID for
        /// the first time you enable an issuer via this contractor.
        ///
        ///You can update the contract ID as long as it is not approved yet, by
        /// repeating the API call with a different contract ID.
        #[serde(
            rename = "contractId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub contract_id: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EnableMethodIssuerBody> for EnableMethodIssuerBody {
        fn from(value: &EnableMethodIssuerBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EnableMethodIssuerBody {
        fn default() -> Self {
            Self {
                contract_id: Default::default(),
            }
        }
    }

    ///`EnableMethodIssuerProfileId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/profileToken"
    ///    },
    ///    {
    ///      "examples": [
    ///        "me"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "me"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EnableMethodIssuerProfileId {
        Variant0(ProfileToken),
        Variant1(EnableMethodIssuerProfileIdVariant1),
    }

    impl ::std::convert::From<&Self> for EnableMethodIssuerProfileId {
        fn from(value: &EnableMethodIssuerProfileId) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EnableMethodIssuerProfileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<ProfileToken> for EnableMethodIssuerProfileId {
        fn from(value: ProfileToken) -> Self {
            Self::Variant0(value)
        }
    }

    impl ::std::convert::From<EnableMethodIssuerProfileIdVariant1> for EnableMethodIssuerProfileId {
        fn from(value: EnableMethodIssuerProfileIdVariant1) -> Self {
            Self::Variant1(value)
        }
    }

    ///`EnableMethodIssuerProfileIdVariant1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "me"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "me"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EnableMethodIssuerProfileIdVariant1 {
        #[serde(rename = "me")]
        Me,
    }

    impl ::std::convert::From<&Self> for EnableMethodIssuerProfileIdVariant1 {
        fn from(value: &EnableMethodIssuerProfileIdVariant1) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EnableMethodIssuerProfileIdVariant1 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Me => f.write_str("me"),
            }
        }
    }

    impl ::std::str::FromStr for EnableMethodIssuerProfileIdVariant1 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "me" => Ok(Self::Me),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EnableMethodIssuerProfileIdVariant1 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EnableMethodIssuerProfileIdVariant1 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EnableMethodIssuerProfileIdVariant1 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EnableMethodIssuerResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/giftcard"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/voucher"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EnableMethodIssuerResponse {
        Giftcard(Giftcard),
        Voucher(Voucher),
    }

    impl ::std::convert::From<&Self> for EnableMethodIssuerResponse {
        fn from(value: &EnableMethodIssuerResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<Giftcard> for EnableMethodIssuerResponse {
        fn from(value: Giftcard) -> Self {
            Self::Giftcard(value)
        }
    }

    impl ::std::convert::From<Voucher> for EnableMethodIssuerResponse {
        fn from(value: Voucher) -> Self {
            Self::Voucher(value)
        }
    }

    ///`EnableMethodProfileId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/profileToken"
    ///    },
    ///    {
    ///      "examples": [
    ///        "me"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "me"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EnableMethodProfileId {
        Variant0(ProfileToken),
        Variant1(EnableMethodProfileIdVariant1),
    }

    impl ::std::convert::From<&Self> for EnableMethodProfileId {
        fn from(value: &EnableMethodProfileId) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EnableMethodProfileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<ProfileToken> for EnableMethodProfileId {
        fn from(value: ProfileToken) -> Self {
            Self::Variant0(value)
        }
    }

    impl ::std::convert::From<EnableMethodProfileIdVariant1> for EnableMethodProfileId {
        fn from(value: EnableMethodProfileIdVariant1) -> Self {
            Self::Variant1(value)
        }
    }

    ///`EnableMethodProfileIdVariant1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "me"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "me"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EnableMethodProfileIdVariant1 {
        #[serde(rename = "me")]
        Me,
    }

    impl ::std::convert::From<&Self> for EnableMethodProfileIdVariant1 {
        fn from(value: &EnableMethodProfileIdVariant1) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EnableMethodProfileIdVariant1 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Me => f.write_str("me"),
            }
        }
    }

    impl ::std::str::FromStr for EnableMethodProfileIdVariant1 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "me" => Ok(Self::Me),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EnableMethodProfileIdVariant1 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EnableMethodProfileIdVariant1 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EnableMethodProfileIdVariant1 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EntityBalance`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "availableAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "currency": {
    ///      "$ref": "#/components/schemas/currencies"
    ///    },
    ///    "description": {
    ///      "description": "The description or name of the balance. Can be used
    /// to denote the purpose of the balance.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "Balance description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/balanceToken"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "pendingAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a balance object.
    /// Will always contain the string `balance` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "balance"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/balance-status"
    ///    },
    ///    "transferDestination": {
    ///      "description": "The destination where the available amount will be
    /// automatically transferred to according to the configured\ntransfer
    /// frequency.",
    ///      "readOnly": true,
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "bankAccount": {
    ///          "description": "The configured bank account number of the
    /// beneficiary the balance amount is to be transferred to.",
    ///          "examples": [
    ///            123456
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "beneficiaryName": {
    ///          "description": "The full name of the beneficiary the balance
    /// amount is to be transferred to.",
    ///          "examples": [
    ///            "John Doe"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "$ref":
    /// "#/components/schemas/balance-transfer-destination-type"
    ///        }
    ///      }
    ///    },
    ///    "transferFrequency": {
    ///      "$ref": "#/components/schemas/balance-transfer-frequency"
    ///    },
    ///    "transferReference": {
    ///      "description": "The transfer reference set to be included in all
    /// the transfers for this balance.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "RF12-3456-7890-1234"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "transferThreshold": {
    ///      "$ref": "#/components/schemas/amount"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalance {
        #[serde(
            rename = "availableAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub available_amount: ::std::option::Option<Amount>,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub currency: ::std::option::Option<Currencies>,
        ///The description or name of the balance. Can be used to denote the
        /// purpose of the balance.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<BalanceToken>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityBalanceLinks>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<Mode>,
        #[serde(
            rename = "pendingAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub pending_amount: ::std::option::Option<Amount>,
        ///Indicates the response contains a balance object. Will always
        /// contain the string `balance` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<BalanceStatus>,
        ///The destination where the available amount will be automatically
        /// transferred to according to the configured
        /// transfer frequency.
        #[serde(
            rename = "transferDestination",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub transfer_destination: ::std::option::Option<EntityBalanceTransferDestination>,
        #[serde(
            rename = "transferFrequency",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub transfer_frequency: ::std::option::Option<BalanceTransferFrequency>,
        ///The transfer reference set to be included in all the transfers for
        /// this balance.
        #[serde(
            rename = "transferReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub transfer_reference: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "transferThreshold",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub transfer_threshold: ::std::option::Option<Amount>,
    }

    impl ::std::convert::From<&EntityBalance> for EntityBalance {
        fn from(value: &EntityBalance) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalance {
        fn default() -> Self {
            Self {
                available_amount: Default::default(),
                created_at: Default::default(),
                currency: Default::default(),
                description: Default::default(),
                id: Default::default(),
                links: Default::default(),
                mode: Default::default(),
                pending_amount: Default::default(),
                resource: Default::default(),
                status: Default::default(),
                transfer_destination: Default::default(),
                transfer_frequency: Default::default(),
                transfer_reference: Default::default(),
                transfer_threshold: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&EntityBalanceLinks> for EntityBalanceLinks {
        fn from(value: &EntityBalanceLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceLinks {
        fn default() -> Self {
            Self {
                documentation: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///`EntityBalanceReport`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "balanceId": {
    ///      "$ref": "#/components/schemas/balanceToken"
    ///    },
    ///    "from": {
    ///      "description": "The start date of the report, in `YYYY-MM-DD`
    /// format. The from date is 'inclusive', and in Central European
    /// Time.\nThis means a report with for example `from=2024-01-01` will
    /// include movements of 2024-01-01 00:00:00 CET and\nonwards.",
    ///      "examples": [
    ///        "2025-03-31"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "grouping": {
    ///      "$ref": "#/components/schemas/balance-report-grouping"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a balance report
    /// object. Will always contain the string `balance-report` for
    /// this\nendpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "balance-report"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timeZone": {
    ///      "description": "The time zone used for the from and until parameters. Currently only time zone `Europe/Amsterdam` is supported.",
    ///      "examples": [
    ///        "Europe/Amsterdam"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totals": {
    ///      "description": "Totals are grouped according to the chosen grouping
    /// rule. The example response should give a good idea of what a\ntypical
    /// grouping looks like.\n\nIf grouping `status-balances` is chosen, the
    /// main grouping is as follows:\n\n* `pendingBalance` containing an `open`,
    /// `pending`, `movedToAvailable`, and `close` sub-group\n*
    /// `availableBalance` containing an `open`, `movedFromPending`,
    /// `immediatelyAvailable`, and `close` sub-group\n\nIf grouping
    /// `transaction-categories` is chosen, the main grouping is as
    /// follows:\n\n* `open` and `close` groups, each containing a `pending` and
    /// `available` sub-group\n* Transaction type groups such as `payments`,
    /// `refunds`, `chargebacks`, `capital`, `transfers`, `fee-prepayments`,
    /// `corrections`, `topups`\neach containing a `pending`,
    /// `movedToAvailable`, and\n`immediatelyAvailable` sub-group\n\nEach
    /// sub-group typically has:\n\n* An `amount` object containing the group's
    /// total amount\n* A `count` integer if relevant (for example, counting the
    /// number of refunds)\n* A `subtotals` array containing more sub-group
    /// objects if applicable",
    ///      "type": "object",
    ///      "properties": {
    ///        "availableBalance": {
    ///          "description": "The available balance. Only available if
    /// grouping is `status-balances`.",
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "close": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "immediatelyAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "movedFromPending": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "open": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            }
    ///          }
    ///        },
    ///        "capital": {
    ///          "description": "Only available on `transaction-categories`
    /// grouping.",
    ///          "type": "object",
    ///          "properties": {
    ///            "immediatelyAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "movedToAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "pending": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            }
    ///          }
    ///        },
    ///        "chargebacks": {
    ///          "description": "Only available on `transaction-categories`
    /// grouping.",
    ///          "type": "object",
    ///          "properties": {
    ///            "immediatelyAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "movedToAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "pending": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            }
    ///          }
    ///        },
    ///        "close": {
    ///          "description": "Only available on `transaction-categories`
    /// grouping.",
    ///          "type": "object",
    ///          "properties": {
    ///            "available": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "pending": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            }
    ///          }
    ///        },
    ///        "corrections": {
    ///          "description": "Only available on `transaction-categories`
    /// grouping.",
    ///          "type": "object",
    ///          "properties": {
    ///            "immediatelyAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "movedToAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "pending": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            }
    ///          }
    ///        },
    ///        "fee-prepayments": {
    ///          "description": "Only available on `transaction-categories`
    /// grouping.",
    ///          "type": "object",
    ///          "properties": {
    ///            "immediatelyAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "movedToAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "pending": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            }
    ///          }
    ///        },
    ///        "open": {
    ///          "description": "Only available on `transaction-categories`
    /// grouping.",
    ///          "type": "object",
    ///          "properties": {
    ///            "available": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "pending": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            }
    ///          }
    ///        },
    ///        "payments": {
    ///          "description": "Only available on `transaction-categories`
    /// grouping.",
    ///          "type": "object",
    ///          "properties": {
    ///            "immediatelyAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "movedToAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "pending": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            }
    ///          }
    ///        },
    ///        "pendingBalance": {
    ///          "description": "The pending balance. Only available if grouping
    /// is `status-balances`.",
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "close": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "movedToAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "open": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "pending": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            }
    ///          }
    ///        },
    ///        "refunds": {
    ///          "description": "Only available on `transaction-categories`
    /// grouping.",
    ///          "type": "object",
    ///          "properties": {
    ///            "immediatelyAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "movedToAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "pending": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            }
    ///          }
    ///        },
    ///        "topups": {
    ///          "description": "Only available on `transaction-categories`
    /// grouping.",
    ///          "type": "object",
    ///          "properties": {
    ///            "immediatelyAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "movedToAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "pending": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            }
    ///          }
    ///        },
    ///        "transfers": {
    ///          "description": "Only available on `transaction-categories`
    /// grouping.",
    ///          "type": "object",
    ///          "properties": {
    ///            "immediatelyAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "movedToAvailable": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            },
    ///            "pending": {
    ///              "$ref": "#/components/schemas/sub-group"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "until": {
    ///      "description": "The end date of the report, in `YYYY-MM-DD` format.
    /// The until date is 'exclusive', and in Central European Time.\nThis means
    /// a report with for example `until=2024-02-01` will include movements up
    /// until 2024-01-31 23:59:59 CET.",
    ///      "examples": [
    ///        "2025-03-31"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceReport {
        #[serde(
            rename = "balanceId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub balance_id: ::std::option::Option<BalanceToken>,
        ///The start date of the report, in `YYYY-MM-DD` format. The from date
        /// is 'inclusive', and in Central European Time. This means a
        /// report with for example `from=2024-01-01` will include movements of
        /// 2024-01-01 00:00:00 CET and onwards.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub from: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub grouping: ::std::option::Option<BalanceReportGrouping>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityBalanceReportLinks>,
        ///Indicates the response contains a balance report object. Will always
        /// contain the string `balance-report` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        ///The time zone used for the from and until parameters. Currently only
        /// time zone `Europe/Amsterdam` is supported.
        #[serde(
            rename = "timeZone",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub time_zone: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub totals: ::std::option::Option<EntityBalanceReportTotals>,
        ///The end date of the report, in `YYYY-MM-DD` format. The until date
        /// is 'exclusive', and in Central European Time. This means a
        /// report with for example `until=2024-02-01` will include movements up
        /// until 2024-01-31 23:59:59 CET.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub until: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityBalanceReport> for EntityBalanceReport {
        fn from(value: &EntityBalanceReport) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceReport {
        fn default() -> Self {
            Self {
                balance_id: Default::default(),
                from: Default::default(),
                grouping: Default::default(),
                links: Default::default(),
                resource: Default::default(),
                time_zone: Default::default(),
                totals: Default::default(),
                until: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceReportLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&EntityBalanceReportLinks> for EntityBalanceReportLinks {
        fn from(value: &EntityBalanceReportLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceReportLinks {
        fn default() -> Self {
            Self {
                documentation: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///Totals are grouped according to the chosen grouping rule. The example
    /// response should give a good idea of what a typical grouping looks
    /// like.
    ///
    ///If grouping `status-balances` is chosen, the main grouping is as
    /// follows:
    ///
    /// * `pendingBalance` containing an `open`, `pending`, `movedToAvailable`,
    ///   and `close` sub-group
    /// * `availableBalance` containing an `open`, `movedFromPending`,
    ///   `immediatelyAvailable`, and `close` sub-group
    ///
    ///If grouping `transaction-categories` is chosen, the main grouping is as
    /// follows:
    ///
    /// * `open` and `close` groups, each containing a `pending` and `available`
    ///   sub-group
    /// * Transaction type groups such as `payments`, `refunds`, `chargebacks`,
    ///   `capital`, `transfers`, `fee-prepayments`, `corrections`, `topups`
    ///each containing a `pending`, `movedToAvailable`, and
    ///`immediatelyAvailable` sub-group
    ///
    ///Each sub-group typically has:
    ///
    /// * An `amount` object containing the group's total amount
    /// * A `count` integer if relevant (for example, counting the number of
    ///   refunds)
    /// * A `subtotals` array containing more sub-group objects if applicable
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Totals are grouped according to the chosen grouping
    /// rule. The example response should give a good idea of what a\ntypical
    /// grouping looks like.\n\nIf grouping `status-balances` is chosen, the
    /// main grouping is as follows:\n\n* `pendingBalance` containing an `open`,
    /// `pending`, `movedToAvailable`, and `close` sub-group\n*
    /// `availableBalance` containing an `open`, `movedFromPending`,
    /// `immediatelyAvailable`, and `close` sub-group\n\nIf grouping
    /// `transaction-categories` is chosen, the main grouping is as
    /// follows:\n\n* `open` and `close` groups, each containing a `pending` and
    /// `available` sub-group\n* Transaction type groups such as `payments`,
    /// `refunds`, `chargebacks`, `capital`, `transfers`, `fee-prepayments`,
    /// `corrections`, `topups`\neach containing a `pending`,
    /// `movedToAvailable`, and\n`immediatelyAvailable` sub-group\n\nEach
    /// sub-group typically has:\n\n* An `amount` object containing the group's
    /// total amount\n* A `count` integer if relevant (for example, counting the
    /// number of refunds)\n* A `subtotals` array containing more sub-group
    /// objects if applicable",
    ///  "type": "object",
    ///  "properties": {
    ///    "availableBalance": {
    ///      "description": "The available balance. Only available if grouping
    /// is `status-balances`.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "close": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "immediatelyAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "movedFromPending": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "open": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        }
    ///      }
    ///    },
    ///    "capital": {
    ///      "description": "Only available on `transaction-categories`
    /// grouping.",
    ///      "type": "object",
    ///      "properties": {
    ///        "immediatelyAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "movedToAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "pending": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        }
    ///      }
    ///    },
    ///    "chargebacks": {
    ///      "description": "Only available on `transaction-categories`
    /// grouping.",
    ///      "type": "object",
    ///      "properties": {
    ///        "immediatelyAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "movedToAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "pending": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        }
    ///      }
    ///    },
    ///    "close": {
    ///      "description": "Only available on `transaction-categories`
    /// grouping.",
    ///      "type": "object",
    ///      "properties": {
    ///        "available": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "pending": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        }
    ///      }
    ///    },
    ///    "corrections": {
    ///      "description": "Only available on `transaction-categories`
    /// grouping.",
    ///      "type": "object",
    ///      "properties": {
    ///        "immediatelyAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "movedToAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "pending": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        }
    ///      }
    ///    },
    ///    "fee-prepayments": {
    ///      "description": "Only available on `transaction-categories`
    /// grouping.",
    ///      "type": "object",
    ///      "properties": {
    ///        "immediatelyAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "movedToAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "pending": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        }
    ///      }
    ///    },
    ///    "open": {
    ///      "description": "Only available on `transaction-categories`
    /// grouping.",
    ///      "type": "object",
    ///      "properties": {
    ///        "available": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "pending": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        }
    ///      }
    ///    },
    ///    "payments": {
    ///      "description": "Only available on `transaction-categories`
    /// grouping.",
    ///      "type": "object",
    ///      "properties": {
    ///        "immediatelyAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "movedToAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "pending": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        }
    ///      }
    ///    },
    ///    "pendingBalance": {
    ///      "description": "The pending balance. Only available if grouping is
    /// `status-balances`.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "close": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "movedToAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "open": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "pending": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        }
    ///      }
    ///    },
    ///    "refunds": {
    ///      "description": "Only available on `transaction-categories`
    /// grouping.",
    ///      "type": "object",
    ///      "properties": {
    ///        "immediatelyAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "movedToAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "pending": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        }
    ///      }
    ///    },
    ///    "topups": {
    ///      "description": "Only available on `transaction-categories`
    /// grouping.",
    ///      "type": "object",
    ///      "properties": {
    ///        "immediatelyAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "movedToAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "pending": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        }
    ///      }
    ///    },
    ///    "transfers": {
    ///      "description": "Only available on `transaction-categories`
    /// grouping.",
    ///      "type": "object",
    ///      "properties": {
    ///        "immediatelyAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "movedToAvailable": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        },
    ///        "pending": {
    ///          "$ref": "#/components/schemas/sub-group"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceReportTotals {
        ///The available balance. Only available if grouping is
        /// `status-balances`.
        #[serde(
            rename = "availableBalance",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub available_balance: ::std::option::Option<EntityBalanceReportTotalsAvailableBalance>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub capital: ::std::option::Option<EntityBalanceReportTotalsCapital>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chargebacks: ::std::option::Option<EntityBalanceReportTotalsChargebacks>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub close: ::std::option::Option<EntityBalanceReportTotalsClose>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub corrections: ::std::option::Option<EntityBalanceReportTotalsCorrections>,
        #[serde(
            rename = "fee-prepayments",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub fee_prepayments: ::std::option::Option<EntityBalanceReportTotalsFeePrepayments>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub open: ::std::option::Option<EntityBalanceReportTotalsOpen>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payments: ::std::option::Option<EntityBalanceReportTotalsPayments>,
        ///The pending balance. Only available if grouping is
        /// `status-balances`.
        #[serde(
            rename = "pendingBalance",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub pending_balance: ::std::option::Option<EntityBalanceReportTotalsPendingBalance>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub refunds: ::std::option::Option<EntityBalanceReportTotalsRefunds>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub topups: ::std::option::Option<EntityBalanceReportTotalsTopups>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transfers: ::std::option::Option<EntityBalanceReportTotalsTransfers>,
    }

    impl ::std::convert::From<&EntityBalanceReportTotals> for EntityBalanceReportTotals {
        fn from(value: &EntityBalanceReportTotals) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceReportTotals {
        fn default() -> Self {
            Self {
                available_balance: Default::default(),
                capital: Default::default(),
                chargebacks: Default::default(),
                close: Default::default(),
                corrections: Default::default(),
                fee_prepayments: Default::default(),
                open: Default::default(),
                payments: Default::default(),
                pending_balance: Default::default(),
                refunds: Default::default(),
                topups: Default::default(),
                transfers: Default::default(),
            }
        }
    }

    ///The available balance. Only available if grouping is `status-balances`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The available balance. Only available if grouping is
    /// `status-balances`.",
    ///  "type": "object",
    ///  "properties": {
    ///    "close": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "immediatelyAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "movedFromPending": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "open": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceReportTotalsAvailableBalance {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub close: ::std::option::Option<SubGroup>,
        #[serde(
            rename = "immediatelyAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub immediately_available: ::std::option::Option<SubGroup>,
        #[serde(
            rename = "movedFromPending",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub moved_from_pending: ::std::option::Option<SubGroup>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub open: ::std::option::Option<SubGroup>,
    }

    impl ::std::convert::From<&EntityBalanceReportTotalsAvailableBalance>
        for EntityBalanceReportTotalsAvailableBalance
    {
        fn from(value: &EntityBalanceReportTotalsAvailableBalance) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceReportTotalsAvailableBalance {
        fn default() -> Self {
            Self {
                close: Default::default(),
                immediately_available: Default::default(),
                moved_from_pending: Default::default(),
                open: Default::default(),
            }
        }
    }

    ///Only available on `transaction-categories` grouping.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Only available on `transaction-categories` grouping.",
    ///  "type": "object",
    ///  "properties": {
    ///    "immediatelyAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "movedToAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "pending": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceReportTotalsCapital {
        #[serde(
            rename = "immediatelyAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub immediately_available: ::std::option::Option<SubGroup>,
        #[serde(
            rename = "movedToAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub moved_to_available: ::std::option::Option<SubGroup>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pending: ::std::option::Option<SubGroup>,
    }

    impl ::std::convert::From<&EntityBalanceReportTotalsCapital> for EntityBalanceReportTotalsCapital {
        fn from(value: &EntityBalanceReportTotalsCapital) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceReportTotalsCapital {
        fn default() -> Self {
            Self {
                immediately_available: Default::default(),
                moved_to_available: Default::default(),
                pending: Default::default(),
            }
        }
    }

    ///Only available on `transaction-categories` grouping.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Only available on `transaction-categories` grouping.",
    ///  "type": "object",
    ///  "properties": {
    ///    "immediatelyAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "movedToAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "pending": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceReportTotalsChargebacks {
        #[serde(
            rename = "immediatelyAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub immediately_available: ::std::option::Option<SubGroup>,
        #[serde(
            rename = "movedToAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub moved_to_available: ::std::option::Option<SubGroup>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pending: ::std::option::Option<SubGroup>,
    }

    impl ::std::convert::From<&EntityBalanceReportTotalsChargebacks>
        for EntityBalanceReportTotalsChargebacks
    {
        fn from(value: &EntityBalanceReportTotalsChargebacks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceReportTotalsChargebacks {
        fn default() -> Self {
            Self {
                immediately_available: Default::default(),
                moved_to_available: Default::default(),
                pending: Default::default(),
            }
        }
    }

    ///Only available on `transaction-categories` grouping.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Only available on `transaction-categories` grouping.",
    ///  "type": "object",
    ///  "properties": {
    ///    "available": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "pending": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceReportTotalsClose {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub available: ::std::option::Option<SubGroup>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pending: ::std::option::Option<SubGroup>,
    }

    impl ::std::convert::From<&EntityBalanceReportTotalsClose> for EntityBalanceReportTotalsClose {
        fn from(value: &EntityBalanceReportTotalsClose) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceReportTotalsClose {
        fn default() -> Self {
            Self {
                available: Default::default(),
                pending: Default::default(),
            }
        }
    }

    ///Only available on `transaction-categories` grouping.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Only available on `transaction-categories` grouping.",
    ///  "type": "object",
    ///  "properties": {
    ///    "immediatelyAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "movedToAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "pending": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceReportTotalsCorrections {
        #[serde(
            rename = "immediatelyAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub immediately_available: ::std::option::Option<SubGroup>,
        #[serde(
            rename = "movedToAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub moved_to_available: ::std::option::Option<SubGroup>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pending: ::std::option::Option<SubGroup>,
    }

    impl ::std::convert::From<&EntityBalanceReportTotalsCorrections>
        for EntityBalanceReportTotalsCorrections
    {
        fn from(value: &EntityBalanceReportTotalsCorrections) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceReportTotalsCorrections {
        fn default() -> Self {
            Self {
                immediately_available: Default::default(),
                moved_to_available: Default::default(),
                pending: Default::default(),
            }
        }
    }

    ///Only available on `transaction-categories` grouping.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Only available on `transaction-categories` grouping.",
    ///  "type": "object",
    ///  "properties": {
    ///    "immediatelyAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "movedToAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "pending": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceReportTotalsFeePrepayments {
        #[serde(
            rename = "immediatelyAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub immediately_available: ::std::option::Option<SubGroup>,
        #[serde(
            rename = "movedToAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub moved_to_available: ::std::option::Option<SubGroup>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pending: ::std::option::Option<SubGroup>,
    }

    impl ::std::convert::From<&EntityBalanceReportTotalsFeePrepayments>
        for EntityBalanceReportTotalsFeePrepayments
    {
        fn from(value: &EntityBalanceReportTotalsFeePrepayments) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceReportTotalsFeePrepayments {
        fn default() -> Self {
            Self {
                immediately_available: Default::default(),
                moved_to_available: Default::default(),
                pending: Default::default(),
            }
        }
    }

    ///Only available on `transaction-categories` grouping.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Only available on `transaction-categories` grouping.",
    ///  "type": "object",
    ///  "properties": {
    ///    "available": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "pending": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceReportTotalsOpen {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub available: ::std::option::Option<SubGroup>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pending: ::std::option::Option<SubGroup>,
    }

    impl ::std::convert::From<&EntityBalanceReportTotalsOpen> for EntityBalanceReportTotalsOpen {
        fn from(value: &EntityBalanceReportTotalsOpen) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceReportTotalsOpen {
        fn default() -> Self {
            Self {
                available: Default::default(),
                pending: Default::default(),
            }
        }
    }

    ///Only available on `transaction-categories` grouping.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Only available on `transaction-categories` grouping.",
    ///  "type": "object",
    ///  "properties": {
    ///    "immediatelyAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "movedToAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "pending": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceReportTotalsPayments {
        #[serde(
            rename = "immediatelyAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub immediately_available: ::std::option::Option<SubGroup>,
        #[serde(
            rename = "movedToAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub moved_to_available: ::std::option::Option<SubGroup>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pending: ::std::option::Option<SubGroup>,
    }

    impl ::std::convert::From<&EntityBalanceReportTotalsPayments>
        for EntityBalanceReportTotalsPayments
    {
        fn from(value: &EntityBalanceReportTotalsPayments) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceReportTotalsPayments {
        fn default() -> Self {
            Self {
                immediately_available: Default::default(),
                moved_to_available: Default::default(),
                pending: Default::default(),
            }
        }
    }

    ///The pending balance. Only available if grouping is `status-balances`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The pending balance. Only available if grouping is
    /// `status-balances`.",
    ///  "type": "object",
    ///  "properties": {
    ///    "close": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "movedToAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "open": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "pending": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceReportTotalsPendingBalance {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub close: ::std::option::Option<SubGroup>,
        #[serde(
            rename = "movedToAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub moved_to_available: ::std::option::Option<SubGroup>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub open: ::std::option::Option<SubGroup>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pending: ::std::option::Option<SubGroup>,
    }

    impl ::std::convert::From<&EntityBalanceReportTotalsPendingBalance>
        for EntityBalanceReportTotalsPendingBalance
    {
        fn from(value: &EntityBalanceReportTotalsPendingBalance) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceReportTotalsPendingBalance {
        fn default() -> Self {
            Self {
                close: Default::default(),
                moved_to_available: Default::default(),
                open: Default::default(),
                pending: Default::default(),
            }
        }
    }

    ///Only available on `transaction-categories` grouping.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Only available on `transaction-categories` grouping.",
    ///  "type": "object",
    ///  "properties": {
    ///    "immediatelyAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "movedToAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "pending": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceReportTotalsRefunds {
        #[serde(
            rename = "immediatelyAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub immediately_available: ::std::option::Option<SubGroup>,
        #[serde(
            rename = "movedToAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub moved_to_available: ::std::option::Option<SubGroup>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pending: ::std::option::Option<SubGroup>,
    }

    impl ::std::convert::From<&EntityBalanceReportTotalsRefunds> for EntityBalanceReportTotalsRefunds {
        fn from(value: &EntityBalanceReportTotalsRefunds) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceReportTotalsRefunds {
        fn default() -> Self {
            Self {
                immediately_available: Default::default(),
                moved_to_available: Default::default(),
                pending: Default::default(),
            }
        }
    }

    ///Only available on `transaction-categories` grouping.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Only available on `transaction-categories` grouping.",
    ///  "type": "object",
    ///  "properties": {
    ///    "immediatelyAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "movedToAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "pending": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceReportTotalsTopups {
        #[serde(
            rename = "immediatelyAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub immediately_available: ::std::option::Option<SubGroup>,
        #[serde(
            rename = "movedToAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub moved_to_available: ::std::option::Option<SubGroup>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pending: ::std::option::Option<SubGroup>,
    }

    impl ::std::convert::From<&EntityBalanceReportTotalsTopups> for EntityBalanceReportTotalsTopups {
        fn from(value: &EntityBalanceReportTotalsTopups) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceReportTotalsTopups {
        fn default() -> Self {
            Self {
                immediately_available: Default::default(),
                moved_to_available: Default::default(),
                pending: Default::default(),
            }
        }
    }

    ///Only available on `transaction-categories` grouping.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Only available on `transaction-categories` grouping.",
    ///  "type": "object",
    ///  "properties": {
    ///    "immediatelyAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "movedToAvailable": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    },
    ///    "pending": {
    ///      "$ref": "#/components/schemas/sub-group"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceReportTotalsTransfers {
        #[serde(
            rename = "immediatelyAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub immediately_available: ::std::option::Option<SubGroup>,
        #[serde(
            rename = "movedToAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub moved_to_available: ::std::option::Option<SubGroup>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pending: ::std::option::Option<SubGroup>,
    }

    impl ::std::convert::From<&EntityBalanceReportTotalsTransfers>
        for EntityBalanceReportTotalsTransfers
    {
        fn from(value: &EntityBalanceReportTotalsTransfers) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceReportTotalsTransfers {
        fn default() -> Self {
            Self {
                immediately_available: Default::default(),
                moved_to_available: Default::default(),
                pending: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransaction`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "context": {
    ///      "description": "Depending on the type of the balance transaction,
    /// we will try to give more context about the specific event
    /// that\ntriggered it. For example, the context object for a payment
    /// transaction will look like\n`{\"paymentId\":
    /// \"tr_5B8cwPMGnU6qLbRvo7qEZo\", \"paymentDescription\":
    /// \"Description\"}`.\n\nBelow is a complete list of the context values
    /// that each type of transaction will have.\n\n* Type `payment`:
    /// `paymentId`, `paymentDescription`\n* Type `capture`: `paymentId`
    /// `captureId`, `paymentDescription`, `captureDescription`\n* Type
    /// `capture-commission`: `paymentId`, `paymentDescription`,
    /// `organizationId`\n* Type `capture-rolling-reserve-release`: `paymentId`,
    /// `paymentDescription`, `captureId`, `captureDescription`\n* Type
    /// `unauthorized-direct-debit`: `paymentId`, `paymentDescription`\n* Type
    /// `failed-payment`: `paymentId`, `paymentDescription`\n* Type `refund`:
    /// `paymentId` `refundId`, `paymentDescription`, `refundDescription`\n*
    /// Type `refund-compensation`: `paymentId` `refundId`,
    /// `paymentDescription`, `refundDescription`\n* Type `returned-refund`:
    /// `paymentId` `refundId`, `paymentDescription`, `refundDescription`\n*
    /// Type `returned-refund-compensation`: `paymentId` `refundId`,
    /// `paymentDescription`, `refundDescription`\n* Type `chargeback`:
    /// `paymentId` `chargebackId`, `paymentDescription`,
    /// `chargebackDescription`\n* Type `chargeback-reversal`: `paymentId`,
    /// `chargebackId`, `paymentDescription`, `chargebackDescription`\n* Type
    /// `chargeback-compensation`: `paymentId`, `chargebackId`,
    /// `paymentDescription`, `chargebackDescription`\n* Type
    /// `reversed-chargeback-compensation`: `paymentId`, `chargebackId`,
    /// `paymentDescription`, `chargebackDescription`\n* Type
    /// `outgoing-transfer`: `settlementId` `transferId`\n* Type
    /// `canceled-outgoing-transfer`: `settlementId` `transferId`\n* Type
    /// `returned-transfer`: `settlementId` `transferId`\n* Type
    /// `invoice-compensation`: `invoiceId`\n* Type `balance-correction`:
    /// none\n* Type `application-fee`: `paymentId`, `paymentDescription`,
    /// `payingOwner`\n* Type `split-payment`: `paymentId`,
    /// `paymentDescription`, `paymentOwner`\n* Type `platform-payment-refund`:
    /// `paymentId` `refundId`, `paymentDescription`, `refundDescription`\n*
    /// Type `returned-platform-payment-refund`: `paymentId` `refundId`,
    /// `paymentDescription`, `refundDescription`\n* Type
    /// `platform-payment-chargeback`: `paymentId` `chargebackId`,
    /// `paymentDescription`, `chargebackDescription`\n* Type
    /// `reversed-platform-payment-chargeback`: `paymentId` `chargebackId`,
    /// `paymentDescription`, `chargebackDescription`\n* Type
    /// `payment-commission`: `paymentId`, `paymentDescription`,
    /// `organizationId`\n* Type `reimbursement-fee`: `paymentId`,
    /// `paymentDescription`\n* Type `failed-payment-fee`: `paymentId`,
    /// `paymentDescription`\n* Type `payment-fee`: `paymentId`,
    /// `paymentDescription`\n* Type `cash-advance-loan`: none\n* Type
    /// `platform-connected-organizations-fee`: none\n* Type `managed-fee`:
    /// `feeType`, `<name of the fee>Id`\n* Type `returned-managed-fee`:
    /// `feeType`, `<name of the fee>Id`\n* Type `topup`: none\n* Type
    /// `balance-reserve`: none\n* Type `balance-reserve-return`: none\n* Type
    /// `movement`: none\n* Type `post-payment-split-payment`: `paymentId`\n*
    /// Type `cash-collateral-issuance`: none\n* Type `cash-collateral-release`:
    /// none",
    ///      "type": "object",
    ///      "properties": {
    ///        "application-fee": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "payingOwner": {
    ///              "$ref": "#/components/schemas/organizationToken"
    ///            },
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        },
    ///        "canceled-outgoing-transfer": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "settlementId": {
    ///              "$ref": "#/components/schemas/settlementToken"
    ///            },
    ///            "transferId": {
    ///              "$ref": "#/components/schemas/transferToken"
    ///            }
    ///          }
    ///        },
    ///        "capture": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "captureDescription": {
    ///              "examples": [
    ///                "Capture Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "captureId": {
    ///              "$ref": "#/components/schemas/captureToken"
    ///            },
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        },
    ///        "capture-commision": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "captureDescription": {
    ///              "examples": [
    ///                "Capture Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "captureId": {
    ///              "$ref": "#/components/schemas/captureToken"
    ///            },
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        },
    ///        "capture-rolling-reserve-release": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "captureDescription": {
    ///              "examples": [
    ///                "Capture Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "captureId": {
    ///              "$ref": "#/components/schemas/captureToken"
    ///            },
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        },
    ///        "chargeback": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "chargebackDescription": {
    ///              "examples": [
    ///                "Chargeback Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "chargebackId": {
    ///              "$ref": "#/components/schemas/chargebackToken"
    ///            },
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        },
    ///        "chargeback-compensation": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "chargebackDescription": {
    ///              "examples": [
    ///                "Chargeback Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "chargebackId": {
    ///              "$ref": "#/components/schemas/chargebackToken"
    ///            },
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        },
    ///        "chargeback-reversal": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "chargebackDescription": {
    ///              "examples": [
    ///                "Chargeback Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "chargebackId": {
    ///              "$ref": "#/components/schemas/chargebackToken"
    ///            },
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        },
    ///        "failed-payment": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        },
    ///        "failed-payment-fee": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        },
    ///        "invoice-compensation": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "invoiceId": {
    ///              "$ref": "#/components/schemas/invoiceToken"
    ///            }
    ///          }
    ///        },
    ///        "managed-fee": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "feeId": {
    ///              "examples": [
    ///                "feeId"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "feeType": {
    ///              "examples": [
    ///                "feeType"
    ///              ],
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        "outgoing-transfer": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "settlementId": {
    ///              "$ref": "#/components/schemas/settlementToken"
    ///            },
    ///            "transferId": {
    ///              "$ref": "#/components/schemas/transferToken"
    ///            }
    ///          }
    ///        },
    ///        "payment": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        },
    ///        "payment-commission": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "organizationId": {
    ///              "$ref": "#/components/schemas/organizationToken"
    ///            },
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        },
    ///        "payment-fee": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        },
    ///        "platform-payment-chargeback": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "chargebackDescription": {
    ///              "examples": [
    ///                "Chargeback Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "chargebackId": {
    ///              "$ref": "#/components/schemas/chargebackToken"
    ///            },
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        },
    ///        "platform-payment-refund": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            },
    ///            "refundDescription": {
    ///              "examples": [
    ///                "Refund Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "refundId": {
    ///              "$ref": "#/components/schemas/refundToken"
    ///            }
    ///          }
    ///        },
    ///        "post-payment-split-payment": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        },
    ///        "refund": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            },
    ///            "refundDescription": {
    ///              "examples": [
    ///                "Refund Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "refundId": {
    ///              "$ref": "#/components/schemas/refundToken"
    ///            }
    ///          }
    ///        },
    ///        "refund-compensation": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            },
    ///            "refundDescription": {
    ///              "examples": [
    ///                "Refund Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "refundId": {
    ///              "$ref": "#/components/schemas/refundToken"
    ///            }
    ///          }
    ///        },
    ///        "reimbursement-fee": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        },
    ///        "returned-managed-fee": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "feeId": {
    ///              "examples": [
    ///                "feeId"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "feeType": {
    ///              "examples": [
    ///                "feeType"
    ///              ],
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        "returned-platform-payment-refund": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            },
    ///            "refundDescription": {
    ///              "examples": [
    ///                "Refund Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "refundId": {
    ///              "$ref": "#/components/schemas/refundToken"
    ///            }
    ///          }
    ///        },
    ///        "returned-refund": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            },
    ///            "refundDescription": {
    ///              "examples": [
    ///                "Refund Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "refundId": {
    ///              "$ref": "#/components/schemas/refundToken"
    ///            }
    ///          }
    ///        },
    ///        "returned-refund-compensation": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            },
    ///            "refundDescription": {
    ///              "examples": [
    ///                "Refund Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "refundId": {
    ///              "$ref": "#/components/schemas/refundToken"
    ///            }
    ///          }
    ///        },
    ///        "returned-transfer": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "settlementId": {
    ///              "examples": [
    ///                "stl_s3hcSM2hKP"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "transferId": {
    ///              "examples": [
    ///                "trf_nyjwa2"
    ///              ],
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        "reversed-chargeback-compensation": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "chargebackDescription": {
    ///              "examples": [
    ///                "Chargeback Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "chargebackId": {
    ///              "$ref": "#/components/schemas/chargebackToken"
    ///            },
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        },
    ///        "reversed-platform-payment-chargeback": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "chargebackDescription": {
    ///              "examples": [
    ///                "Chargeback Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "chargebackId": {
    ///              "$ref": "#/components/schemas/chargebackToken"
    ///            },
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        },
    ///        "split-payment": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            },
    ///            "paymentOnwer": {
    ///              "$ref": "#/components/schemas/organizationToken"
    ///            }
    ///          }
    ///        },
    ///        "unauthorized-direct-debit": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "paymentDescription": {
    ///              "examples": [
    ///                "Payment Description"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "paymentId": {
    ///              "$ref": "#/components/schemas/paymentToken"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "deductions": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/balanceTransactionToken"
    ///    },
    ///    "initialAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a balance
    /// transaction object. Will always contain the string
    /// `balance-transaction`\nfor this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "balance-transaction"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "resultAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/balance-transaction-type"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransaction {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub context: ::std::option::Option<EntityBalanceTransactionContext>,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub deductions: ::std::option::Option<AmountNullable>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<BalanceTransactionToken>,
        #[serde(
            rename = "initialAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub initial_amount: ::std::option::Option<Amount>,
        ///Indicates the response contains a balance transaction object. Will
        /// always contain the string `balance-transaction`
        /// for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "resultAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub result_amount: ::std::option::Option<Amount>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<BalanceTransactionType>,
    }

    impl ::std::convert::From<&EntityBalanceTransaction> for EntityBalanceTransaction {
        fn from(value: &EntityBalanceTransaction) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransaction {
        fn default() -> Self {
            Self {
                context: Default::default(),
                created_at: Default::default(),
                deductions: Default::default(),
                id: Default::default(),
                initial_amount: Default::default(),
                resource: Default::default(),
                result_amount: Default::default(),
                type_: Default::default(),
            }
        }
    }

    ///Depending on the type of the balance transaction, we will try to give
    /// more context about the specific event that triggered it. For
    /// example, the context object for a payment transaction will look like
    /// `{"paymentId": "tr_5B8cwPMGnU6qLbRvo7qEZo", "paymentDescription":
    /// "Description"}`.
    ///
    ///Below is a complete list of the context values that each type of
    /// transaction will have.
    ///
    /// * Type `payment`: `paymentId`, `paymentDescription`
    /// * Type `capture`: `paymentId` `captureId`, `paymentDescription`,
    ///   `captureDescription`
    /// * Type `capture-commission`: `paymentId`, `paymentDescription`,
    ///   `organizationId`
    /// * Type `capture-rolling-reserve-release`: `paymentId`,
    ///   `paymentDescription`, `captureId`, `captureDescription`
    /// * Type `unauthorized-direct-debit`: `paymentId`, `paymentDescription`
    /// * Type `failed-payment`: `paymentId`, `paymentDescription`
    /// * Type `refund`: `paymentId` `refundId`, `paymentDescription`,
    ///   `refundDescription`
    /// * Type `refund-compensation`: `paymentId` `refundId`,
    ///   `paymentDescription`, `refundDescription`
    /// * Type `returned-refund`: `paymentId` `refundId`, `paymentDescription`,
    ///   `refundDescription`
    /// * Type `returned-refund-compensation`: `paymentId` `refundId`,
    ///   `paymentDescription`, `refundDescription`
    /// * Type `chargeback`: `paymentId` `chargebackId`, `paymentDescription`,
    ///   `chargebackDescription`
    /// * Type `chargeback-reversal`: `paymentId`, `chargebackId`,
    ///   `paymentDescription`, `chargebackDescription`
    /// * Type `chargeback-compensation`: `paymentId`, `chargebackId`,
    ///   `paymentDescription`, `chargebackDescription`
    /// * Type `reversed-chargeback-compensation`: `paymentId`, `chargebackId`,
    ///   `paymentDescription`, `chargebackDescription`
    /// * Type `outgoing-transfer`: `settlementId` `transferId`
    /// * Type `canceled-outgoing-transfer`: `settlementId` `transferId`
    /// * Type `returned-transfer`: `settlementId` `transferId`
    /// * Type `invoice-compensation`: `invoiceId`
    /// * Type `balance-correction`: none
    /// * Type `application-fee`: `paymentId`, `paymentDescription`,
    ///   `payingOwner`
    /// * Type `split-payment`: `paymentId`, `paymentDescription`,
    ///   `paymentOwner`
    /// * Type `platform-payment-refund`: `paymentId` `refundId`,
    ///   `paymentDescription`, `refundDescription`
    /// * Type `returned-platform-payment-refund`: `paymentId` `refundId`,
    ///   `paymentDescription`, `refundDescription`
    /// * Type `platform-payment-chargeback`: `paymentId` `chargebackId`,
    ///   `paymentDescription`, `chargebackDescription`
    /// * Type `reversed-platform-payment-chargeback`: `paymentId`
    ///   `chargebackId`, `paymentDescription`, `chargebackDescription`
    /// * Type `payment-commission`: `paymentId`, `paymentDescription`,
    ///   `organizationId`
    /// * Type `reimbursement-fee`: `paymentId`, `paymentDescription`
    /// * Type `failed-payment-fee`: `paymentId`, `paymentDescription`
    /// * Type `payment-fee`: `paymentId`, `paymentDescription`
    /// * Type `cash-advance-loan`: none
    /// * Type `platform-connected-organizations-fee`: none
    /// * Type `managed-fee`: `feeType`, `<name of the fee>Id`
    /// * Type `returned-managed-fee`:  `feeType`, `<name of the fee>Id`
    /// * Type `topup`: none
    /// * Type `balance-reserve`: none
    /// * Type `balance-reserve-return`: none
    /// * Type `movement`: none
    /// * Type `post-payment-split-payment`: `paymentId`
    /// * Type `cash-collateral-issuance`: none
    /// * Type `cash-collateral-release`: none
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Depending on the type of the balance transaction, we
    /// will try to give more context about the specific event that\ntriggered
    /// it. For example, the context object for a payment transaction will look
    /// like\n`{\"paymentId\": \"tr_5B8cwPMGnU6qLbRvo7qEZo\",
    /// \"paymentDescription\": \"Description\"}`.\n\nBelow is a complete list
    /// of the context values that each type of transaction will have.\n\n* Type
    /// `payment`: `paymentId`, `paymentDescription`\n* Type `capture`:
    /// `paymentId` `captureId`, `paymentDescription`, `captureDescription`\n*
    /// Type `capture-commission`: `paymentId`, `paymentDescription`,
    /// `organizationId`\n* Type `capture-rolling-reserve-release`: `paymentId`,
    /// `paymentDescription`, `captureId`, `captureDescription`\n* Type
    /// `unauthorized-direct-debit`: `paymentId`, `paymentDescription`\n* Type
    /// `failed-payment`: `paymentId`, `paymentDescription`\n* Type `refund`:
    /// `paymentId` `refundId`, `paymentDescription`, `refundDescription`\n*
    /// Type `refund-compensation`: `paymentId` `refundId`,
    /// `paymentDescription`, `refundDescription`\n* Type `returned-refund`:
    /// `paymentId` `refundId`, `paymentDescription`, `refundDescription`\n*
    /// Type `returned-refund-compensation`: `paymentId` `refundId`,
    /// `paymentDescription`, `refundDescription`\n* Type `chargeback`:
    /// `paymentId` `chargebackId`, `paymentDescription`,
    /// `chargebackDescription`\n* Type `chargeback-reversal`: `paymentId`,
    /// `chargebackId`, `paymentDescription`, `chargebackDescription`\n* Type
    /// `chargeback-compensation`: `paymentId`, `chargebackId`,
    /// `paymentDescription`, `chargebackDescription`\n* Type
    /// `reversed-chargeback-compensation`: `paymentId`, `chargebackId`,
    /// `paymentDescription`, `chargebackDescription`\n* Type
    /// `outgoing-transfer`: `settlementId` `transferId`\n* Type
    /// `canceled-outgoing-transfer`: `settlementId` `transferId`\n* Type
    /// `returned-transfer`: `settlementId` `transferId`\n* Type
    /// `invoice-compensation`: `invoiceId`\n* Type `balance-correction`:
    /// none\n* Type `application-fee`: `paymentId`, `paymentDescription`,
    /// `payingOwner`\n* Type `split-payment`: `paymentId`,
    /// `paymentDescription`, `paymentOwner`\n* Type `platform-payment-refund`:
    /// `paymentId` `refundId`, `paymentDescription`, `refundDescription`\n*
    /// Type `returned-platform-payment-refund`: `paymentId` `refundId`,
    /// `paymentDescription`, `refundDescription`\n* Type
    /// `platform-payment-chargeback`: `paymentId` `chargebackId`,
    /// `paymentDescription`, `chargebackDescription`\n* Type
    /// `reversed-platform-payment-chargeback`: `paymentId` `chargebackId`,
    /// `paymentDescription`, `chargebackDescription`\n* Type
    /// `payment-commission`: `paymentId`, `paymentDescription`,
    /// `organizationId`\n* Type `reimbursement-fee`: `paymentId`,
    /// `paymentDescription`\n* Type `failed-payment-fee`: `paymentId`,
    /// `paymentDescription`\n* Type `payment-fee`: `paymentId`,
    /// `paymentDescription`\n* Type `cash-advance-loan`: none\n* Type
    /// `platform-connected-organizations-fee`: none\n* Type `managed-fee`:
    /// `feeType`, `<name of the fee>Id`\n* Type `returned-managed-fee`:
    /// `feeType`, `<name of the fee>Id`\n* Type `topup`: none\n* Type
    /// `balance-reserve`: none\n* Type `balance-reserve-return`: none\n* Type
    /// `movement`: none\n* Type `post-payment-split-payment`: `paymentId`\n*
    /// Type `cash-collateral-issuance`: none\n* Type `cash-collateral-release`:
    /// none",
    ///  "type": "object",
    ///  "properties": {
    ///    "application-fee": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "payingOwner": {
    ///          "$ref": "#/components/schemas/organizationToken"
    ///        },
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    },
    ///    "canceled-outgoing-transfer": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "settlementId": {
    ///          "$ref": "#/components/schemas/settlementToken"
    ///        },
    ///        "transferId": {
    ///          "$ref": "#/components/schemas/transferToken"
    ///        }
    ///      }
    ///    },
    ///    "capture": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "captureDescription": {
    ///          "examples": [
    ///            "Capture Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "captureId": {
    ///          "$ref": "#/components/schemas/captureToken"
    ///        },
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    },
    ///    "capture-commision": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "captureDescription": {
    ///          "examples": [
    ///            "Capture Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "captureId": {
    ///          "$ref": "#/components/schemas/captureToken"
    ///        },
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    },
    ///    "capture-rolling-reserve-release": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "captureDescription": {
    ///          "examples": [
    ///            "Capture Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "captureId": {
    ///          "$ref": "#/components/schemas/captureToken"
    ///        },
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    },
    ///    "chargeback": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "chargebackDescription": {
    ///          "examples": [
    ///            "Chargeback Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "chargebackId": {
    ///          "$ref": "#/components/schemas/chargebackToken"
    ///        },
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    },
    ///    "chargeback-compensation": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "chargebackDescription": {
    ///          "examples": [
    ///            "Chargeback Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "chargebackId": {
    ///          "$ref": "#/components/schemas/chargebackToken"
    ///        },
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    },
    ///    "chargeback-reversal": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "chargebackDescription": {
    ///          "examples": [
    ///            "Chargeback Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "chargebackId": {
    ///          "$ref": "#/components/schemas/chargebackToken"
    ///        },
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    },
    ///    "failed-payment": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    },
    ///    "failed-payment-fee": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    },
    ///    "invoice-compensation": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "invoiceId": {
    ///          "$ref": "#/components/schemas/invoiceToken"
    ///        }
    ///      }
    ///    },
    ///    "managed-fee": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "feeId": {
    ///          "examples": [
    ///            "feeId"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "feeType": {
    ///          "examples": [
    ///            "feeType"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "outgoing-transfer": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "settlementId": {
    ///          "$ref": "#/components/schemas/settlementToken"
    ///        },
    ///        "transferId": {
    ///          "$ref": "#/components/schemas/transferToken"
    ///        }
    ///      }
    ///    },
    ///    "payment": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    },
    ///    "payment-commission": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "organizationId": {
    ///          "$ref": "#/components/schemas/organizationToken"
    ///        },
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    },
    ///    "payment-fee": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    },
    ///    "platform-payment-chargeback": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "chargebackDescription": {
    ///          "examples": [
    ///            "Chargeback Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "chargebackId": {
    ///          "$ref": "#/components/schemas/chargebackToken"
    ///        },
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    },
    ///    "platform-payment-refund": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        },
    ///        "refundDescription": {
    ///          "examples": [
    ///            "Refund Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "refundId": {
    ///          "$ref": "#/components/schemas/refundToken"
    ///        }
    ///      }
    ///    },
    ///    "post-payment-split-payment": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    },
    ///    "refund": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        },
    ///        "refundDescription": {
    ///          "examples": [
    ///            "Refund Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "refundId": {
    ///          "$ref": "#/components/schemas/refundToken"
    ///        }
    ///      }
    ///    },
    ///    "refund-compensation": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        },
    ///        "refundDescription": {
    ///          "examples": [
    ///            "Refund Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "refundId": {
    ///          "$ref": "#/components/schemas/refundToken"
    ///        }
    ///      }
    ///    },
    ///    "reimbursement-fee": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    },
    ///    "returned-managed-fee": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "feeId": {
    ///          "examples": [
    ///            "feeId"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "feeType": {
    ///          "examples": [
    ///            "feeType"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "returned-platform-payment-refund": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        },
    ///        "refundDescription": {
    ///          "examples": [
    ///            "Refund Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "refundId": {
    ///          "$ref": "#/components/schemas/refundToken"
    ///        }
    ///      }
    ///    },
    ///    "returned-refund": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        },
    ///        "refundDescription": {
    ///          "examples": [
    ///            "Refund Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "refundId": {
    ///          "$ref": "#/components/schemas/refundToken"
    ///        }
    ///      }
    ///    },
    ///    "returned-refund-compensation": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        },
    ///        "refundDescription": {
    ///          "examples": [
    ///            "Refund Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "refundId": {
    ///          "$ref": "#/components/schemas/refundToken"
    ///        }
    ///      }
    ///    },
    ///    "returned-transfer": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "settlementId": {
    ///          "examples": [
    ///            "stl_s3hcSM2hKP"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "transferId": {
    ///          "examples": [
    ///            "trf_nyjwa2"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "reversed-chargeback-compensation": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "chargebackDescription": {
    ///          "examples": [
    ///            "Chargeback Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "chargebackId": {
    ///          "$ref": "#/components/schemas/chargebackToken"
    ///        },
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    },
    ///    "reversed-platform-payment-chargeback": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "chargebackDescription": {
    ///          "examples": [
    ///            "Chargeback Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "chargebackId": {
    ///          "$ref": "#/components/schemas/chargebackToken"
    ///        },
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    },
    ///    "split-payment": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        },
    ///        "paymentOnwer": {
    ///          "$ref": "#/components/schemas/organizationToken"
    ///        }
    ///      }
    ///    },
    ///    "unauthorized-direct-debit": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "paymentDescription": {
    ///          "examples": [
    ///            "Payment Description"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "paymentId": {
    ///          "$ref": "#/components/schemas/paymentToken"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContext {
        #[serde(
            rename = "application-fee",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub application_fee: ::std::option::Option<EntityBalanceTransactionContextApplicationFee>,
        #[serde(
            rename = "canceled-outgoing-transfer",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub canceled_outgoing_transfer:
            ::std::option::Option<EntityBalanceTransactionContextCanceledOutgoingTransfer>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub capture: ::std::option::Option<EntityBalanceTransactionContextCapture>,
        #[serde(
            rename = "capture-commision",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub capture_commision:
            ::std::option::Option<EntityBalanceTransactionContextCaptureCommision>,
        #[serde(
            rename = "capture-rolling-reserve-release",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub capture_rolling_reserve_release:
            ::std::option::Option<EntityBalanceTransactionContextCaptureRollingReserveRelease>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chargeback: ::std::option::Option<EntityBalanceTransactionContextChargeback>,
        #[serde(
            rename = "chargeback-compensation",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub chargeback_compensation:
            ::std::option::Option<EntityBalanceTransactionContextChargebackCompensation>,
        #[serde(
            rename = "chargeback-reversal",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub chargeback_reversal:
            ::std::option::Option<EntityBalanceTransactionContextChargebackReversal>,
        #[serde(
            rename = "failed-payment",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub failed_payment: ::std::option::Option<EntityBalanceTransactionContextFailedPayment>,
        #[serde(
            rename = "failed-payment-fee",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub failed_payment_fee:
            ::std::option::Option<EntityBalanceTransactionContextFailedPaymentFee>,
        #[serde(
            rename = "invoice-compensation",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub invoice_compensation:
            ::std::option::Option<EntityBalanceTransactionContextInvoiceCompensation>,
        #[serde(
            rename = "managed-fee",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub managed_fee: ::std::option::Option<EntityBalanceTransactionContextManagedFee>,
        #[serde(
            rename = "outgoing-transfer",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub outgoing_transfer:
            ::std::option::Option<EntityBalanceTransactionContextOutgoingTransfer>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payment: ::std::option::Option<EntityBalanceTransactionContextPayment>,
        #[serde(
            rename = "payment-commission",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_commission:
            ::std::option::Option<EntityBalanceTransactionContextPaymentCommission>,
        #[serde(
            rename = "payment-fee",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_fee: ::std::option::Option<EntityBalanceTransactionContextPaymentFee>,
        #[serde(
            rename = "platform-payment-chargeback",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub platform_payment_chargeback:
            ::std::option::Option<EntityBalanceTransactionContextPlatformPaymentChargeback>,
        #[serde(
            rename = "platform-payment-refund",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub platform_payment_refund:
            ::std::option::Option<EntityBalanceTransactionContextPlatformPaymentRefund>,
        #[serde(
            rename = "post-payment-split-payment",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub post_payment_split_payment:
            ::std::option::Option<EntityBalanceTransactionContextPostPaymentSplitPayment>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub refund: ::std::option::Option<EntityBalanceTransactionContextRefund>,
        #[serde(
            rename = "refund-compensation",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub refund_compensation:
            ::std::option::Option<EntityBalanceTransactionContextRefundCompensation>,
        #[serde(
            rename = "reimbursement-fee",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub reimbursement_fee:
            ::std::option::Option<EntityBalanceTransactionContextReimbursementFee>,
        #[serde(
            rename = "returned-managed-fee",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub returned_managed_fee:
            ::std::option::Option<EntityBalanceTransactionContextReturnedManagedFee>,
        #[serde(
            rename = "returned-platform-payment-refund",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub returned_platform_payment_refund:
            ::std::option::Option<EntityBalanceTransactionContextReturnedPlatformPaymentRefund>,
        #[serde(
            rename = "returned-refund",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub returned_refund: ::std::option::Option<EntityBalanceTransactionContextReturnedRefund>,
        #[serde(
            rename = "returned-refund-compensation",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub returned_refund_compensation:
            ::std::option::Option<EntityBalanceTransactionContextReturnedRefundCompensation>,
        #[serde(
            rename = "returned-transfer",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub returned_transfer:
            ::std::option::Option<EntityBalanceTransactionContextReturnedTransfer>,
        #[serde(
            rename = "reversed-chargeback-compensation",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub reversed_chargeback_compensation:
            ::std::option::Option<EntityBalanceTransactionContextReversedChargebackCompensation>,
        #[serde(
            rename = "reversed-platform-payment-chargeback",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub reversed_platform_payment_chargeback:
            ::std::option::Option<EntityBalanceTransactionContextReversedPlatformPaymentChargeback>,
        #[serde(
            rename = "split-payment",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub split_payment: ::std::option::Option<EntityBalanceTransactionContextSplitPayment>,
        #[serde(
            rename = "unauthorized-direct-debit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub unauthorized_direct_debit:
            ::std::option::Option<EntityBalanceTransactionContextUnauthorizedDirectDebit>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContext> for EntityBalanceTransactionContext {
        fn from(value: &EntityBalanceTransactionContext) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContext {
        fn default() -> Self {
            Self {
                application_fee: Default::default(),
                canceled_outgoing_transfer: Default::default(),
                capture: Default::default(),
                capture_commision: Default::default(),
                capture_rolling_reserve_release: Default::default(),
                chargeback: Default::default(),
                chargeback_compensation: Default::default(),
                chargeback_reversal: Default::default(),
                failed_payment: Default::default(),
                failed_payment_fee: Default::default(),
                invoice_compensation: Default::default(),
                managed_fee: Default::default(),
                outgoing_transfer: Default::default(),
                payment: Default::default(),
                payment_commission: Default::default(),
                payment_fee: Default::default(),
                platform_payment_chargeback: Default::default(),
                platform_payment_refund: Default::default(),
                post_payment_split_payment: Default::default(),
                refund: Default::default(),
                refund_compensation: Default::default(),
                reimbursement_fee: Default::default(),
                returned_managed_fee: Default::default(),
                returned_platform_payment_refund: Default::default(),
                returned_refund: Default::default(),
                returned_refund_compensation: Default::default(),
                returned_transfer: Default::default(),
                reversed_chargeback_compensation: Default::default(),
                reversed_platform_payment_chargeback: Default::default(),
                split_payment: Default::default(),
                unauthorized_direct_debit: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextApplicationFee`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "payingOwner": {
    ///      "$ref": "#/components/schemas/organizationToken"
    ///    },
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextApplicationFee {
        #[serde(
            rename = "payingOwner",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paying_owner: ::std::option::Option<OrganizationToken>,
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextApplicationFee>
        for EntityBalanceTransactionContextApplicationFee
    {
        fn from(value: &EntityBalanceTransactionContextApplicationFee) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextApplicationFee {
        fn default() -> Self {
            Self {
                paying_owner: Default::default(),
                payment_description: Default::default(),
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextCanceledOutgoingTransfer`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "settlementId": {
    ///      "$ref": "#/components/schemas/settlementToken"
    ///    },
    ///    "transferId": {
    ///      "$ref": "#/components/schemas/transferToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextCanceledOutgoingTransfer {
        #[serde(
            rename = "settlementId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_id: ::std::option::Option<SettlementToken>,
        #[serde(
            rename = "transferId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub transfer_id: ::std::option::Option<TransferToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextCanceledOutgoingTransfer>
        for EntityBalanceTransactionContextCanceledOutgoingTransfer
    {
        fn from(value: &EntityBalanceTransactionContextCanceledOutgoingTransfer) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextCanceledOutgoingTransfer {
        fn default() -> Self {
            Self {
                settlement_id: Default::default(),
                transfer_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextCapture`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "captureDescription": {
    ///      "examples": [
    ///        "Capture Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "captureId": {
    ///      "$ref": "#/components/schemas/captureToken"
    ///    },
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextCapture {
        #[serde(
            rename = "captureDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub capture_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "captureId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub capture_id: ::std::option::Option<CaptureToken>,
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextCapture>
        for EntityBalanceTransactionContextCapture
    {
        fn from(value: &EntityBalanceTransactionContextCapture) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextCapture {
        fn default() -> Self {
            Self {
                capture_description: Default::default(),
                capture_id: Default::default(),
                payment_description: Default::default(),
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextCaptureCommision`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "captureDescription": {
    ///      "examples": [
    ///        "Capture Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "captureId": {
    ///      "$ref": "#/components/schemas/captureToken"
    ///    },
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextCaptureCommision {
        #[serde(
            rename = "captureDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub capture_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "captureId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub capture_id: ::std::option::Option<CaptureToken>,
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextCaptureCommision>
        for EntityBalanceTransactionContextCaptureCommision
    {
        fn from(value: &EntityBalanceTransactionContextCaptureCommision) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextCaptureCommision {
        fn default() -> Self {
            Self {
                capture_description: Default::default(),
                capture_id: Default::default(),
                payment_description: Default::default(),
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextCaptureRollingReserveRelease`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "captureDescription": {
    ///      "examples": [
    ///        "Capture Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "captureId": {
    ///      "$ref": "#/components/schemas/captureToken"
    ///    },
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextCaptureRollingReserveRelease {
        #[serde(
            rename = "captureDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub capture_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "captureId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub capture_id: ::std::option::Option<CaptureToken>,
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextCaptureRollingReserveRelease>
        for EntityBalanceTransactionContextCaptureRollingReserveRelease
    {
        fn from(value: &EntityBalanceTransactionContextCaptureRollingReserveRelease) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextCaptureRollingReserveRelease {
        fn default() -> Self {
            Self {
                capture_description: Default::default(),
                capture_id: Default::default(),
                payment_description: Default::default(),
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextChargeback`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "chargebackDescription": {
    ///      "examples": [
    ///        "Chargeback Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "chargebackId": {
    ///      "$ref": "#/components/schemas/chargebackToken"
    ///    },
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextChargeback {
        #[serde(
            rename = "chargebackDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub chargeback_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "chargebackId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub chargeback_id: ::std::option::Option<ChargebackToken>,
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextChargeback>
        for EntityBalanceTransactionContextChargeback
    {
        fn from(value: &EntityBalanceTransactionContextChargeback) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextChargeback {
        fn default() -> Self {
            Self {
                chargeback_description: Default::default(),
                chargeback_id: Default::default(),
                payment_description: Default::default(),
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextChargebackCompensation`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "chargebackDescription": {
    ///      "examples": [
    ///        "Chargeback Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "chargebackId": {
    ///      "$ref": "#/components/schemas/chargebackToken"
    ///    },
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextChargebackCompensation {
        #[serde(
            rename = "chargebackDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub chargeback_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "chargebackId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub chargeback_id: ::std::option::Option<ChargebackToken>,
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextChargebackCompensation>
        for EntityBalanceTransactionContextChargebackCompensation
    {
        fn from(value: &EntityBalanceTransactionContextChargebackCompensation) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextChargebackCompensation {
        fn default() -> Self {
            Self {
                chargeback_description: Default::default(),
                chargeback_id: Default::default(),
                payment_description: Default::default(),
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextChargebackReversal`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "chargebackDescription": {
    ///      "examples": [
    ///        "Chargeback Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "chargebackId": {
    ///      "$ref": "#/components/schemas/chargebackToken"
    ///    },
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextChargebackReversal {
        #[serde(
            rename = "chargebackDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub chargeback_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "chargebackId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub chargeback_id: ::std::option::Option<ChargebackToken>,
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextChargebackReversal>
        for EntityBalanceTransactionContextChargebackReversal
    {
        fn from(value: &EntityBalanceTransactionContextChargebackReversal) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextChargebackReversal {
        fn default() -> Self {
            Self {
                chargeback_description: Default::default(),
                chargeback_id: Default::default(),
                payment_description: Default::default(),
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextFailedPayment`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextFailedPayment {
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextFailedPayment>
        for EntityBalanceTransactionContextFailedPayment
    {
        fn from(value: &EntityBalanceTransactionContextFailedPayment) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextFailedPayment {
        fn default() -> Self {
            Self {
                payment_description: Default::default(),
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextFailedPaymentFee`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextFailedPaymentFee {
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextFailedPaymentFee>
        for EntityBalanceTransactionContextFailedPaymentFee
    {
        fn from(value: &EntityBalanceTransactionContextFailedPaymentFee) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextFailedPaymentFee {
        fn default() -> Self {
            Self {
                payment_description: Default::default(),
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextInvoiceCompensation`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "invoiceId": {
    ///      "$ref": "#/components/schemas/invoiceToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextInvoiceCompensation {
        #[serde(
            rename = "invoiceId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub invoice_id: ::std::option::Option<InvoiceToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextInvoiceCompensation>
        for EntityBalanceTransactionContextInvoiceCompensation
    {
        fn from(value: &EntityBalanceTransactionContextInvoiceCompensation) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextInvoiceCompensation {
        fn default() -> Self {
            Self {
                invoice_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextManagedFee`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "feeId": {
    ///      "examples": [
    ///        "feeId"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "feeType": {
    ///      "examples": [
    ///        "feeType"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextManagedFee {
        #[serde(
            rename = "feeId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub fee_id: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "feeType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub fee_type: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextManagedFee>
        for EntityBalanceTransactionContextManagedFee
    {
        fn from(value: &EntityBalanceTransactionContextManagedFee) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextManagedFee {
        fn default() -> Self {
            Self {
                fee_id: Default::default(),
                fee_type: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextOutgoingTransfer`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "settlementId": {
    ///      "$ref": "#/components/schemas/settlementToken"
    ///    },
    ///    "transferId": {
    ///      "$ref": "#/components/schemas/transferToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextOutgoingTransfer {
        #[serde(
            rename = "settlementId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_id: ::std::option::Option<SettlementToken>,
        #[serde(
            rename = "transferId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub transfer_id: ::std::option::Option<TransferToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextOutgoingTransfer>
        for EntityBalanceTransactionContextOutgoingTransfer
    {
        fn from(value: &EntityBalanceTransactionContextOutgoingTransfer) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextOutgoingTransfer {
        fn default() -> Self {
            Self {
                settlement_id: Default::default(),
                transfer_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextPayment`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextPayment {
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextPayment>
        for EntityBalanceTransactionContextPayment
    {
        fn from(value: &EntityBalanceTransactionContextPayment) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextPayment {
        fn default() -> Self {
            Self {
                payment_description: Default::default(),
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextPaymentCommission`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "organizationId": {
    ///      "$ref": "#/components/schemas/organizationToken"
    ///    },
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextPaymentCommission {
        #[serde(
            rename = "organizationId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub organization_id: ::std::option::Option<OrganizationToken>,
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextPaymentCommission>
        for EntityBalanceTransactionContextPaymentCommission
    {
        fn from(value: &EntityBalanceTransactionContextPaymentCommission) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextPaymentCommission {
        fn default() -> Self {
            Self {
                organization_id: Default::default(),
                payment_description: Default::default(),
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextPaymentFee`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextPaymentFee {
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextPaymentFee>
        for EntityBalanceTransactionContextPaymentFee
    {
        fn from(value: &EntityBalanceTransactionContextPaymentFee) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextPaymentFee {
        fn default() -> Self {
            Self {
                payment_description: Default::default(),
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextPlatformPaymentChargeback`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "chargebackDescription": {
    ///      "examples": [
    ///        "Chargeback Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "chargebackId": {
    ///      "$ref": "#/components/schemas/chargebackToken"
    ///    },
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextPlatformPaymentChargeback {
        #[serde(
            rename = "chargebackDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub chargeback_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "chargebackId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub chargeback_id: ::std::option::Option<ChargebackToken>,
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextPlatformPaymentChargeback>
        for EntityBalanceTransactionContextPlatformPaymentChargeback
    {
        fn from(value: &EntityBalanceTransactionContextPlatformPaymentChargeback) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextPlatformPaymentChargeback {
        fn default() -> Self {
            Self {
                chargeback_description: Default::default(),
                chargeback_id: Default::default(),
                payment_description: Default::default(),
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextPlatformPaymentRefund`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    },
    ///    "refundDescription": {
    ///      "examples": [
    ///        "Refund Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "refundId": {
    ///      "$ref": "#/components/schemas/refundToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextPlatformPaymentRefund {
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
        #[serde(
            rename = "refundDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub refund_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "refundId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub refund_id: ::std::option::Option<RefundToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextPlatformPaymentRefund>
        for EntityBalanceTransactionContextPlatformPaymentRefund
    {
        fn from(value: &EntityBalanceTransactionContextPlatformPaymentRefund) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextPlatformPaymentRefund {
        fn default() -> Self {
            Self {
                payment_description: Default::default(),
                payment_id: Default::default(),
                refund_description: Default::default(),
                refund_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextPostPaymentSplitPayment`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextPostPaymentSplitPayment {
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextPostPaymentSplitPayment>
        for EntityBalanceTransactionContextPostPaymentSplitPayment
    {
        fn from(value: &EntityBalanceTransactionContextPostPaymentSplitPayment) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextPostPaymentSplitPayment {
        fn default() -> Self {
            Self {
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextRefund`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    },
    ///    "refundDescription": {
    ///      "examples": [
    ///        "Refund Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "refundId": {
    ///      "$ref": "#/components/schemas/refundToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextRefund {
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
        #[serde(
            rename = "refundDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub refund_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "refundId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub refund_id: ::std::option::Option<RefundToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextRefund>
        for EntityBalanceTransactionContextRefund
    {
        fn from(value: &EntityBalanceTransactionContextRefund) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextRefund {
        fn default() -> Self {
            Self {
                payment_description: Default::default(),
                payment_id: Default::default(),
                refund_description: Default::default(),
                refund_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextRefundCompensation`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    },
    ///    "refundDescription": {
    ///      "examples": [
    ///        "Refund Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "refundId": {
    ///      "$ref": "#/components/schemas/refundToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextRefundCompensation {
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
        #[serde(
            rename = "refundDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub refund_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "refundId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub refund_id: ::std::option::Option<RefundToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextRefundCompensation>
        for EntityBalanceTransactionContextRefundCompensation
    {
        fn from(value: &EntityBalanceTransactionContextRefundCompensation) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextRefundCompensation {
        fn default() -> Self {
            Self {
                payment_description: Default::default(),
                payment_id: Default::default(),
                refund_description: Default::default(),
                refund_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextReimbursementFee`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextReimbursementFee {
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextReimbursementFee>
        for EntityBalanceTransactionContextReimbursementFee
    {
        fn from(value: &EntityBalanceTransactionContextReimbursementFee) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextReimbursementFee {
        fn default() -> Self {
            Self {
                payment_description: Default::default(),
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextReturnedManagedFee`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "feeId": {
    ///      "examples": [
    ///        "feeId"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "feeType": {
    ///      "examples": [
    ///        "feeType"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextReturnedManagedFee {
        #[serde(
            rename = "feeId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub fee_id: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "feeType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub fee_type: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextReturnedManagedFee>
        for EntityBalanceTransactionContextReturnedManagedFee
    {
        fn from(value: &EntityBalanceTransactionContextReturnedManagedFee) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextReturnedManagedFee {
        fn default() -> Self {
            Self {
                fee_id: Default::default(),
                fee_type: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextReturnedPlatformPaymentRefund`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    },
    ///    "refundDescription": {
    ///      "examples": [
    ///        "Refund Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "refundId": {
    ///      "$ref": "#/components/schemas/refundToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextReturnedPlatformPaymentRefund {
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
        #[serde(
            rename = "refundDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub refund_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "refundId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub refund_id: ::std::option::Option<RefundToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextReturnedPlatformPaymentRefund>
        for EntityBalanceTransactionContextReturnedPlatformPaymentRefund
    {
        fn from(value: &EntityBalanceTransactionContextReturnedPlatformPaymentRefund) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextReturnedPlatformPaymentRefund {
        fn default() -> Self {
            Self {
                payment_description: Default::default(),
                payment_id: Default::default(),
                refund_description: Default::default(),
                refund_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextReturnedRefund`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    },
    ///    "refundDescription": {
    ///      "examples": [
    ///        "Refund Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "refundId": {
    ///      "$ref": "#/components/schemas/refundToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextReturnedRefund {
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
        #[serde(
            rename = "refundDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub refund_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "refundId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub refund_id: ::std::option::Option<RefundToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextReturnedRefund>
        for EntityBalanceTransactionContextReturnedRefund
    {
        fn from(value: &EntityBalanceTransactionContextReturnedRefund) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextReturnedRefund {
        fn default() -> Self {
            Self {
                payment_description: Default::default(),
                payment_id: Default::default(),
                refund_description: Default::default(),
                refund_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextReturnedRefundCompensation`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    },
    ///    "refundDescription": {
    ///      "examples": [
    ///        "Refund Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "refundId": {
    ///      "$ref": "#/components/schemas/refundToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextReturnedRefundCompensation {
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
        #[serde(
            rename = "refundDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub refund_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "refundId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub refund_id: ::std::option::Option<RefundToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextReturnedRefundCompensation>
        for EntityBalanceTransactionContextReturnedRefundCompensation
    {
        fn from(value: &EntityBalanceTransactionContextReturnedRefundCompensation) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextReturnedRefundCompensation {
        fn default() -> Self {
            Self {
                payment_description: Default::default(),
                payment_id: Default::default(),
                refund_description: Default::default(),
                refund_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextReturnedTransfer`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "settlementId": {
    ///      "examples": [
    ///        "stl_s3hcSM2hKP"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transferId": {
    ///      "examples": [
    ///        "trf_nyjwa2"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextReturnedTransfer {
        #[serde(
            rename = "settlementId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_id: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "transferId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub transfer_id: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextReturnedTransfer>
        for EntityBalanceTransactionContextReturnedTransfer
    {
        fn from(value: &EntityBalanceTransactionContextReturnedTransfer) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextReturnedTransfer {
        fn default() -> Self {
            Self {
                settlement_id: Default::default(),
                transfer_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextReversedChargebackCompensation`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "chargebackDescription": {
    ///      "examples": [
    ///        "Chargeback Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "chargebackId": {
    ///      "$ref": "#/components/schemas/chargebackToken"
    ///    },
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextReversedChargebackCompensation {
        #[serde(
            rename = "chargebackDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub chargeback_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "chargebackId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub chargeback_id: ::std::option::Option<ChargebackToken>,
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextReversedChargebackCompensation>
        for EntityBalanceTransactionContextReversedChargebackCompensation
    {
        fn from(value: &EntityBalanceTransactionContextReversedChargebackCompensation) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextReversedChargebackCompensation {
        fn default() -> Self {
            Self {
                chargeback_description: Default::default(),
                chargeback_id: Default::default(),
                payment_description: Default::default(),
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextReversedPlatformPaymentChargeback`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "chargebackDescription": {
    ///      "examples": [
    ///        "Chargeback Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "chargebackId": {
    ///      "$ref": "#/components/schemas/chargebackToken"
    ///    },
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextReversedPlatformPaymentChargeback {
        #[serde(
            rename = "chargebackDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub chargeback_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "chargebackId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub chargeback_id: ::std::option::Option<ChargebackToken>,
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextReversedPlatformPaymentChargeback>
        for EntityBalanceTransactionContextReversedPlatformPaymentChargeback
    {
        fn from(value: &EntityBalanceTransactionContextReversedPlatformPaymentChargeback) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextReversedPlatformPaymentChargeback {
        fn default() -> Self {
            Self {
                chargeback_description: Default::default(),
                chargeback_id: Default::default(),
                payment_description: Default::default(),
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextSplitPayment`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    },
    ///    "paymentOnwer": {
    ///      "$ref": "#/components/schemas/organizationToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextSplitPayment {
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
        #[serde(
            rename = "paymentOnwer",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_onwer: ::std::option::Option<OrganizationToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextSplitPayment>
        for EntityBalanceTransactionContextSplitPayment
    {
        fn from(value: &EntityBalanceTransactionContextSplitPayment) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextSplitPayment {
        fn default() -> Self {
            Self {
                payment_description: Default::default(),
                payment_id: Default::default(),
                payment_onwer: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransactionContextUnauthorizedDirectDebit`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "paymentDescription": {
    ///      "examples": [
    ///        "Payment Description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransactionContextUnauthorizedDirectDebit {
        #[serde(
            rename = "paymentDescription",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
    }

    impl ::std::convert::From<&EntityBalanceTransactionContextUnauthorizedDirectDebit>
        for EntityBalanceTransactionContextUnauthorizedDirectDebit
    {
        fn from(value: &EntityBalanceTransactionContextUnauthorizedDirectDebit) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransactionContextUnauthorizedDirectDebit {
        fn default() -> Self {
            Self {
                payment_description: Default::default(),
                payment_id: Default::default(),
            }
        }
    }

    ///`EntityBalanceTransfer`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "createdAt",
    ///    "description",
    ///    "destination",
    ///    "id",
    ///    "mode",
    ///    "resource",
    ///    "source",
    ///    "status",
    ///    "statusReason"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "category": {
    ///      "$ref": "#/components/schemas/balance-transfer-category"
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "description": {
    ///      "description": "The transfer description for initiating party.",
    ///      "examples": [
    ///        "Invoice fee"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "destination": {
    ///      "$ref": "#/components/schemas/entity-balance-transfer-party"
    ///    },
    ///    "executedAt": {
    ///      "description": "The date and time when the transfer was completed,
    /// in ISO 8601 format. This parameter is omitted if the transfer is\nnot
    /// executed (yet).",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-03-20T09:28:37.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/connectBalanceTransferToken"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a balance transfer
    /// object. Will always contain the string `connect-balance-transfer` for
    /// this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "connect-balance-transfer"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "source": {
    ///      "$ref": "#/components/schemas/entity-balance-transfer-party"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/balance-transfer-status"
    ///    },
    ///    "statusReason": {
    ///      "description": "The reason for the current status of the transfer,
    /// if applicable.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "code",
    ///        "message"
    ///      ],
    ///      "properties": {
    ///        "code": {
    ///          "$ref": "#/components/schemas/balance-transfer-status-reason"
    ///        },
    ///        "message": {
    ///          "description": "A description of the status reason, localized
    /// according to the transfer.",
    ///          "examples": [
    ///            "Insufficient funds in the source balance."
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransfer {
        pub amount: Amount,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category: ::std::option::Option<BalanceTransferCategory>,
        #[serde(rename = "createdAt")]
        pub created_at: CreatedAt,
        ///The transfer description for initiating party.
        pub description: EntityBalanceTransferDescription,
        pub destination: EntityBalanceTransferParty,
        ///The date and time when the transfer was completed, in ISO 8601
        /// format. This parameter is omitted if the transfer is
        /// not executed (yet).
        #[serde(
            rename = "executedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub executed_at: ::std::option::Option<::std::string::String>,
        pub id: ConnectBalanceTransferToken,
        pub mode: Mode,
        ///Indicates the response contains a balance transfer object. Will
        /// always contain the string `connect-balance-transfer` for this
        /// endpoint.
        pub resource: ::std::string::String,
        pub source: EntityBalanceTransferParty,
        pub status: BalanceTransferStatus,
        #[serde(rename = "statusReason")]
        pub status_reason: EntityBalanceTransferStatusReason,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
    }

    impl ::std::convert::From<&EntityBalanceTransfer> for EntityBalanceTransfer {
        fn from(value: &EntityBalanceTransfer) -> Self {
            value.clone()
        }
    }

    ///The transfer description for initiating party.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The transfer description for initiating party.",
    ///  "examples": [
    ///    "Invoice fee"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityBalanceTransferDescription(::std::string::String);
    impl ::std::ops::Deref for EntityBalanceTransferDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityBalanceTransferDescription> for ::std::string::String {
        fn from(value: EntityBalanceTransferDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityBalanceTransferDescription> for EntityBalanceTransferDescription {
        fn from(value: &EntityBalanceTransferDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityBalanceTransferDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityBalanceTransferDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityBalanceTransferDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityBalanceTransferDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityBalanceTransferDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The destination where the available amount will be automatically
    /// transferred to according to the configured transfer frequency.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The destination where the available amount will be
    /// automatically transferred to according to the configured\ntransfer
    /// frequency.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "bankAccount": {
    ///      "description": "The configured bank account number of the
    /// beneficiary the balance amount is to be transferred to.",
    ///      "examples": [
    ///        123456
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "beneficiaryName": {
    ///      "description": "The full name of the beneficiary the balance amount
    /// is to be transferred to.",
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/balance-transfer-destination-type"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransferDestination {
        ///The configured bank account number of the beneficiary the balance
        /// amount is to be transferred to.
        #[serde(
            rename = "bankAccount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub bank_account: ::std::option::Option<::std::string::String>,
        ///The full name of the beneficiary the balance amount is to be
        /// transferred to.
        #[serde(
            rename = "beneficiaryName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub beneficiary_name: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<BalanceTransferDestinationType>,
    }

    impl ::std::convert::From<&EntityBalanceTransferDestination> for EntityBalanceTransferDestination {
        fn from(value: &EntityBalanceTransferDestination) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityBalanceTransferDestination {
        fn default() -> Self {
            Self {
                bank_account: Default::default(),
                beneficiary_name: Default::default(),
                type_: Default::default(),
            }
        }
    }

    ///A party involved in the balance transfer, either the sender or the
    /// receiver.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A party involved in the balance transfer, either the
    /// sender or the receiver.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "The transfer description for the transfer party.
    /// This is the description that will appear in the financial reports of the
    /// party.",
    ///      "examples": [
    ///        "Invoice fee"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/organizationToken"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/balance-transfer-party-type"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransferParty {
        ///The transfer description for the transfer party. This is the
        /// description that will appear in the financial reports of the party.
        pub description: EntityBalanceTransferPartyDescription,
        pub id: OrganizationToken,
        #[serde(rename = "type")]
        pub type_: BalanceTransferPartyType,
    }

    impl ::std::convert::From<&EntityBalanceTransferParty> for EntityBalanceTransferParty {
        fn from(value: &EntityBalanceTransferParty) -> Self {
            value.clone()
        }
    }

    ///The transfer description for the transfer party. This is the description
    /// that will appear in the financial reports of the party.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The transfer description for the transfer party. This
    /// is the description that will appear in the financial reports of the
    /// party.",
    ///  "examples": [
    ///    "Invoice fee"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityBalanceTransferPartyDescription(::std::string::String);
    impl ::std::ops::Deref for EntityBalanceTransferPartyDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityBalanceTransferPartyDescription> for ::std::string::String {
        fn from(value: EntityBalanceTransferPartyDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityBalanceTransferPartyDescription>
        for EntityBalanceTransferPartyDescription
    {
        fn from(value: &EntityBalanceTransferPartyDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityBalanceTransferPartyDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityBalanceTransferPartyDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityBalanceTransferPartyDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityBalanceTransferPartyDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityBalanceTransferPartyDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///A party involved in the balance transfer, either the sender or the
    /// receiver.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A party involved in the balance transfer, either the
    /// sender or the receiver.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "The transfer description for the transfer party.
    /// This is the description that will appear in the financial reports of the
    /// party.",
    ///      "examples": [
    ///        "Invoice fee"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/organizationToken"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/balance-transfer-party-type-response"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransferPartyResponse {
        ///The transfer description for the transfer party. This is the
        /// description that will appear in the financial reports of the party.
        pub description: EntityBalanceTransferPartyResponseDescription,
        pub id: OrganizationToken,
        #[serde(rename = "type")]
        pub type_: BalanceTransferPartyTypeResponse,
    }

    impl ::std::convert::From<&EntityBalanceTransferPartyResponse>
        for EntityBalanceTransferPartyResponse
    {
        fn from(value: &EntityBalanceTransferPartyResponse) -> Self {
            value.clone()
        }
    }

    ///The transfer description for the transfer party. This is the description
    /// that will appear in the financial reports of the party.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The transfer description for the transfer party. This
    /// is the description that will appear in the financial reports of the
    /// party.",
    ///  "examples": [
    ///    "Invoice fee"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityBalanceTransferPartyResponseDescription(::std::string::String);
    impl ::std::ops::Deref for EntityBalanceTransferPartyResponseDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityBalanceTransferPartyResponseDescription> for ::std::string::String {
        fn from(value: EntityBalanceTransferPartyResponseDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityBalanceTransferPartyResponseDescription>
        for EntityBalanceTransferPartyResponseDescription
    {
        fn from(value: &EntityBalanceTransferPartyResponseDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityBalanceTransferPartyResponseDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityBalanceTransferPartyResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for EntityBalanceTransferPartyResponseDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for EntityBalanceTransferPartyResponseDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityBalanceTransferPartyResponseDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`EntityBalanceTransferResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "createdAt",
    ///    "description",
    ///    "destination",
    ///    "id",
    ///    "mode",
    ///    "resource",
    ///    "source",
    ///    "status",
    ///    "statusReason"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "category": {
    ///      "$ref": "#/components/schemas/balance-transfer-category-response"
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "description": {
    ///      "description": "The transfer description for initiating party.",
    ///      "examples": [
    ///        "Invoice fee"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "destination": {
    ///      "$ref":
    /// "#/components/schemas/entity-balance-transfer-party-response"
    ///    },
    ///    "executedAt": {
    ///      "description": "The date and time when the transfer was completed,
    /// in ISO 8601 format. This parameter is omitted if the transfer is\nnot
    /// executed (yet).",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-03-20T09:28:37.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/connectBalanceTransferToken"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a balance transfer
    /// object. Will always contain the string `connect-balance-transfer` for
    /// this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "connect-balance-transfer"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "source": {
    ///      "$ref":
    /// "#/components/schemas/entity-balance-transfer-party-response"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/balance-transfer-status"
    ///    },
    ///    "statusReason": {
    ///      "description": "The reason for the current status of the transfer,
    /// if applicable.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "code",
    ///        "message"
    ///      ],
    ///      "properties": {
    ///        "code": {
    ///          "$ref":
    /// "#/components/schemas/balance-transfer-status-reason-response"
    ///        },
    ///        "message": {
    ///          "description": "A description of the status reason, localized
    /// according to the transfer.",
    ///          "examples": [
    ///            "Insufficient funds in the source balance."
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransferResponse {
        pub amount: Amount,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category: ::std::option::Option<BalanceTransferCategoryResponse>,
        #[serde(rename = "createdAt")]
        pub created_at: CreatedAt,
        ///The transfer description for initiating party.
        pub description: EntityBalanceTransferResponseDescription,
        pub destination: EntityBalanceTransferPartyResponse,
        ///The date and time when the transfer was completed, in ISO 8601
        /// format. This parameter is omitted if the transfer is
        /// not executed (yet).
        #[serde(
            rename = "executedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub executed_at: ::std::option::Option<::std::string::String>,
        pub id: ConnectBalanceTransferToken,
        pub mode: Mode,
        ///Indicates the response contains a balance transfer object. Will
        /// always contain the string `connect-balance-transfer` for this
        /// endpoint.
        pub resource: ::std::string::String,
        pub source: EntityBalanceTransferPartyResponse,
        pub status: BalanceTransferStatus,
        #[serde(rename = "statusReason")]
        pub status_reason: EntityBalanceTransferResponseStatusReason,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
    }

    impl ::std::convert::From<&EntityBalanceTransferResponse> for EntityBalanceTransferResponse {
        fn from(value: &EntityBalanceTransferResponse) -> Self {
            value.clone()
        }
    }

    ///The transfer description for initiating party.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The transfer description for initiating party.",
    ///  "examples": [
    ///    "Invoice fee"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityBalanceTransferResponseDescription(::std::string::String);
    impl ::std::ops::Deref for EntityBalanceTransferResponseDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityBalanceTransferResponseDescription> for ::std::string::String {
        fn from(value: EntityBalanceTransferResponseDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityBalanceTransferResponseDescription>
        for EntityBalanceTransferResponseDescription
    {
        fn from(value: &EntityBalanceTransferResponseDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityBalanceTransferResponseDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityBalanceTransferResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityBalanceTransferResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityBalanceTransferResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityBalanceTransferResponseDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The reason for the current status of the transfer, if applicable.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The reason for the current status of the transfer, if
    /// applicable.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "message"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "$ref":
    /// "#/components/schemas/balance-transfer-status-reason-response"
    ///    },
    ///    "message": {
    ///      "description": "A description of the status reason, localized
    /// according to the transfer.",
    ///      "examples": [
    ///        "Insufficient funds in the source balance."
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransferResponseStatusReason {
        pub code: BalanceTransferStatusReasonResponse,
        ///A description of the status reason, localized according to the
        /// transfer.
        pub message: ::std::string::String,
    }

    impl ::std::convert::From<&EntityBalanceTransferResponseStatusReason>
        for EntityBalanceTransferResponseStatusReason
    {
        fn from(value: &EntityBalanceTransferResponseStatusReason) -> Self {
            value.clone()
        }
    }

    ///The reason for the current status of the transfer, if applicable.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The reason for the current status of the transfer, if
    /// applicable.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "message"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "$ref": "#/components/schemas/balance-transfer-status-reason"
    ///    },
    ///    "message": {
    ///      "description": "A description of the status reason, localized
    /// according to the transfer.",
    ///      "examples": [
    ///        "Insufficient funds in the source balance."
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityBalanceTransferStatusReason {
        pub code: BalanceTransferStatusReason,
        ///A description of the status reason, localized according to the
        /// transfer.
        pub message: ::std::string::String,
    }

    impl ::std::convert::From<&EntityBalanceTransferStatusReason>
        for EntityBalanceTransferStatusReason
    {
        fn from(value: &EntityBalanceTransferStatusReason) -> Self {
            value.clone()
        }
    }

    ///`EntityCapability`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "name": {
    ///      "description": "A unique name for this capability like `payments` /
    /// `settlements`.",
    ///      "examples": [
    ///        "payments"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "requirements": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-capability-requirement"
    ///      }
    ///    },
    ///    "resource": {
    ///      "description": "Always the word `capability` for this resource
    /// type.",
    ///      "examples": [
    ///        "capability"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/capability-status"
    ///    },
    ///    "statusReason": {
    ///      "$ref": "#/components/schemas/capability-status-reason"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityCapability {
        ///A unique name for this capability like `payments` / `settlements`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub requirements: ::std::vec::Vec<EntityCapabilityRequirement>,
        ///Always the word `capability` for this resource type.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<CapabilityStatus>,
        #[serde(
            rename = "statusReason",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub status_reason: ::std::option::Option<CapabilityStatusReason>,
    }

    impl ::std::convert::From<&EntityCapability> for EntityCapability {
        fn from(value: &EntityCapability) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityCapability {
        fn default() -> Self {
            Self {
                name: Default::default(),
                requirements: Default::default(),
                resource: Default::default(),
                status: Default::default(),
                status_reason: Default::default(),
            }
        }
    }

    ///`EntityCapabilityRequirement`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "type": "object",
    ///      "properties": {
    ///        "dashboard": {
    ///          "description": "If known, a deep link to the Mollie dashboard
    /// of the client, where the requirement can be fulfilled.\nFor example,
    /// where necessary documents are to be uploaded.",
    ///          "examples": [
    ///            {
    ///              "href": "https://my.mollie.com/dashboard/...",
    ///              "type": "text/html"
    ///            }
    ///          ],
    ///          "type": "object",
    ///          "properties": {
    ///            "href": {
    ///              "description": "The actual URL string.",
    ///              "type": "string"
    ///            },
    ///            "type": {
    ///              "description": "The content type of the page or endpoint
    /// the URL points to.",
    ///              "type": "string"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "dueDate": {
    ///      "description": "Due date until the requirement must be fulfilled,
    /// if any. The date is shown in ISO-8601 format.",
    ///      "examples": [
    ///        "2024-01-01T12:00:00+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "description": "The name of this requirement, referring to the task
    /// to be fulfilled by the organization\nto enable or re-enable the
    /// capability. The name is unique among other requirements\nof the same
    /// capability.",
    ///      "examples": [
    ///        "legal-representatives"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/capability-requirement-status"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityCapabilityRequirement {
        ///Due date until the requirement must be fulfilled, if any. The date
        /// is shown in ISO-8601 format.
        #[serde(
            rename = "dueDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub due_date: ::std::option::Option<::std::string::String>,
        ///The name of this requirement, referring to the task to be fulfilled
        /// by the organization to enable or re-enable the capability.
        /// The name is unique among other requirements of the same
        /// capability.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityCapabilityRequirementLinks>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<CapabilityRequirementStatus>,
    }

    impl ::std::convert::From<&EntityCapabilityRequirement> for EntityCapabilityRequirement {
        fn from(value: &EntityCapabilityRequirement) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityCapabilityRequirement {
        fn default() -> Self {
            Self {
                due_date: Default::default(),
                id: Default::default(),
                links: Default::default(),
                status: Default::default(),
            }
        }
    }

    ///`EntityCapabilityRequirementLinks`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "dashboard": {
    ///      "description": "If known, a deep link to the Mollie dashboard of
    /// the client, where the requirement can be fulfilled.\nFor example, where
    /// necessary documents are to be uploaded.",
    ///      "examples": [
    ///        {
    ///          "href": "https://my.mollie.com/dashboard/...",
    ///          "type": "text/html"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "properties": {
    ///        "href": {
    ///          "description": "The actual URL string.",
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "description": "The content type of the page or endpoint the
    /// URL points to.",
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityCapabilityRequirementLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub dashboard: ::std::option::Option<EntityCapabilityRequirementLinksDashboard>,
    }

    impl ::std::convert::From<&EntityCapabilityRequirementLinks> for EntityCapabilityRequirementLinks {
        fn from(value: &EntityCapabilityRequirementLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityCapabilityRequirementLinks {
        fn default() -> Self {
            Self {
                dashboard: Default::default(),
            }
        }
    }

    ///If known, a deep link to the Mollie dashboard of the client, where the
    /// requirement can be fulfilled. For example, where necessary documents
    /// are to be uploaded.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "If known, a deep link to the Mollie dashboard of the
    /// client, where the requirement can be fulfilled.\nFor example, where
    /// necessary documents are to be uploaded.",
    ///  "examples": [
    ///    {
    ///      "href": "https://my.mollie.com/dashboard/...",
    ///      "type": "text/html"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "href": {
    ///      "description": "The actual URL string.",
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The content type of the page or endpoint the URL
    /// points to.",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityCapabilityRequirementLinksDashboard {
        ///The actual URL string.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub href: ::std::option::Option<::std::string::String>,
        ///The content type of the page or endpoint the URL points to.
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityCapabilityRequirementLinksDashboard>
        for EntityCapabilityRequirementLinksDashboard
    {
        fn from(value: &EntityCapabilityRequirementLinksDashboard) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityCapabilityRequirementLinksDashboard {
        fn default() -> Self {
            Self {
                href: Default::default(),
                type_: Default::default(),
            }
        }
    }

    ///`EntityCapture`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "documentation",
    ///        "payment",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "payment": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "settlement": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        },
    ///        "shipment": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        }
    ///      }
    ///    },
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "description": {
    ///      "description": "The description of the capture.",
    ///      "examples": [
    ///        "Capture for cart #12345"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/captureToken"
    ///    },
    ///    "metadata": {
    ///      "$ref": "#/components/schemas/metadata"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a capture object.
    /// Will always contain the string `capture` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "capture"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "settlementAmount": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "settlementId": {
    ///      "$ref": "#/components/schemas/settlementToken"
    ///    },
    ///    "shipmentId": {
    ///      "$ref": "#/components/schemas/shipmentToken"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/capture-status"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityCapture {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<AmountNullable>,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        ///The description of the capture.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<EntityCaptureDescription>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<CaptureToken>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityCaptureLinks>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<Metadata>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<Mode>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
        ///Indicates the response contains a capture object. Will always
        /// contain the string `capture` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "settlementAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_amount: ::std::option::Option<AmountNullable>,
        #[serde(
            rename = "settlementId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_id: ::std::option::Option<SettlementToken>,
        #[serde(
            rename = "shipmentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub shipment_id: ::std::option::Option<ShipmentToken>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<CaptureStatus>,
    }

    impl ::std::convert::From<&EntityCapture> for EntityCapture {
        fn from(value: &EntityCapture) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityCapture {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                created_at: Default::default(),
                description: Default::default(),
                id: Default::default(),
                links: Default::default(),
                metadata: Default::default(),
                mode: Default::default(),
                payment_id: Default::default(),
                resource: Default::default(),
                settlement_amount: Default::default(),
                settlement_id: Default::default(),
                shipment_id: Default::default(),
                status: Default::default(),
            }
        }
    }

    ///The description of the capture.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The description of the capture.",
    ///  "examples": [
    ///    "Capture for cart #12345"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityCaptureDescription(::std::string::String);
    impl ::std::ops::Deref for EntityCaptureDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityCaptureDescription> for ::std::string::String {
        fn from(value: EntityCaptureDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityCaptureDescription> for EntityCaptureDescription {
        fn from(value: &EntityCaptureDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityCaptureDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityCaptureDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityCaptureDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityCaptureDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityCaptureDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "documentation",
    ///    "payment",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "payment": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "settlement": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "shipment": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityCaptureLinks {
        pub documentation: Url,
        pub payment: Url,
        #[serde(rename = "self")]
        pub self_: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub settlement: ::std::option::Option<UrlNullable>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub shipment: ::std::option::Option<UrlNullable>,
    }

    impl ::std::convert::From<&EntityCaptureLinks> for EntityCaptureLinks {
        fn from(value: &EntityCaptureLinks) -> Self {
            value.clone()
        }
    }

    ///`EntityCaptureResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "documentation",
    ///        "payment",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "payment": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "settlement": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        },
    ///        "shipment": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        }
    ///      }
    ///    },
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "description": {
    ///      "description": "The description of the capture.",
    ///      "examples": [
    ///        "Capture for cart #12345"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/captureToken"
    ///    },
    ///    "metadata": {
    ///      "$ref": "#/components/schemas/metadata"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a capture object.
    /// Will always contain the string `capture` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "capture"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "settlementAmount": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "settlementId": {
    ///      "$ref": "#/components/schemas/settlementToken"
    ///    },
    ///    "shipmentId": {
    ///      "$ref": "#/components/schemas/shipmentToken"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/capture-status"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityCaptureResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<AmountNullable>,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        ///The description of the capture.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<EntityCaptureResponseDescription>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<CaptureToken>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityCaptureResponseLinks>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<Metadata>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<Mode>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
        ///Indicates the response contains a capture object. Will always
        /// contain the string `capture` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "settlementAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_amount: ::std::option::Option<AmountNullable>,
        #[serde(
            rename = "settlementId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_id: ::std::option::Option<SettlementToken>,
        #[serde(
            rename = "shipmentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub shipment_id: ::std::option::Option<ShipmentToken>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<CaptureStatus>,
    }

    impl ::std::convert::From<&EntityCaptureResponse> for EntityCaptureResponse {
        fn from(value: &EntityCaptureResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityCaptureResponse {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                created_at: Default::default(),
                description: Default::default(),
                id: Default::default(),
                links: Default::default(),
                metadata: Default::default(),
                mode: Default::default(),
                payment_id: Default::default(),
                resource: Default::default(),
                settlement_amount: Default::default(),
                settlement_id: Default::default(),
                shipment_id: Default::default(),
                status: Default::default(),
            }
        }
    }

    ///The description of the capture.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The description of the capture.",
    ///  "examples": [
    ///    "Capture for cart #12345"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityCaptureResponseDescription(::std::string::String);
    impl ::std::ops::Deref for EntityCaptureResponseDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityCaptureResponseDescription> for ::std::string::String {
        fn from(value: EntityCaptureResponseDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityCaptureResponseDescription> for EntityCaptureResponseDescription {
        fn from(value: &EntityCaptureResponseDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityCaptureResponseDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityCaptureResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityCaptureResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityCaptureResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityCaptureResponseDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "documentation",
    ///    "payment",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "payment": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "settlement": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "shipment": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityCaptureResponseLinks {
        pub documentation: Url,
        pub payment: Url,
        #[serde(rename = "self")]
        pub self_: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub settlement: ::std::option::Option<UrlNullable>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub shipment: ::std::option::Option<UrlNullable>,
    }

    impl ::std::convert::From<&EntityCaptureResponseLinks> for EntityCaptureResponseLinks {
        fn from(value: &EntityCaptureResponseLinks) -> Self {
            value.clone()
        }
    }

    ///`EntityChargeback`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_links",
    ///    "amount",
    ///    "createdAt",
    ///    "id",
    ///    "paymentId",
    ///    "resource"
    ///  ],
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "documentation",
    ///        "payment",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "payment": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "settlement": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        }
    ///      }
    ///    },
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/chargebackToken"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    },
    ///    "reason": {
    ///      "description": "Reason for the chargeback as given by the bank.
    /// Only available for chargebacks of SEPA Direct Debit payments.",
    ///      "readOnly": true,
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "required": [
    ///        "code",
    ///        "description"
    ///      ],
    ///      "properties": {
    ///        "code": {
    ///          "description": "Technical code provided by the bank.",
    ///          "examples": [
    ///            "AC01"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "description": {
    ///          "description": "A more detailed human-friendly description.",
    ///          "examples": [
    ///            "Account identifier incorrect (i.e. invalid IBAN)"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a chargeback
    /// object. Will always contain the string `chargeback` for
    /// this\nendpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "chargeback"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "reversedAt": {
    ///      "description": "The date and time the chargeback was reversed if applicable, in\n[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-03-21T09:13:37.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "settlementAmount": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "settlementId": {
    ///      "$ref": "#/components/schemas/settlementToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityChargeback {
        pub amount: Amount,
        #[serde(rename = "createdAt")]
        pub created_at: CreatedAt,
        pub id: ChargebackToken,
        #[serde(rename = "_links")]
        pub links: EntityChargebackLinks,
        #[serde(rename = "paymentId")]
        pub payment_id: PaymentToken,
        ///Reason for the chargeback as given by the bank. Only available for
        /// chargebacks of SEPA Direct Debit payments.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub reason: ::std::option::Option<EntityChargebackReason>,
        ///Indicates the response contains a chargeback object. Will always
        /// contain the string `chargeback` for this endpoint.
        pub resource: ::std::string::String,
        ///The date and time the chargeback was reversed if applicable, in
        ///[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        #[serde(
            rename = "reversedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub reversed_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "settlementAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_amount: ::std::option::Option<AmountNullable>,
        #[serde(
            rename = "settlementId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_id: ::std::option::Option<SettlementToken>,
    }

    impl ::std::convert::From<&EntityChargeback> for EntityChargeback {
        fn from(value: &EntityChargeback) -> Self {
            value.clone()
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "documentation",
    ///    "payment",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "payment": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "settlement": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityChargebackLinks {
        pub documentation: Url,
        pub payment: Url,
        #[serde(rename = "self")]
        pub self_: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub settlement: ::std::option::Option<UrlNullable>,
    }

    impl ::std::convert::From<&EntityChargebackLinks> for EntityChargebackLinks {
        fn from(value: &EntityChargebackLinks) -> Self {
            value.clone()
        }
    }

    ///Reason for the chargeback as given by the bank. Only available for
    /// chargebacks of SEPA Direct Debit payments.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Reason for the chargeback as given by the bank. Only
    /// available for chargebacks of SEPA Direct Debit payments.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "description"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "description": "Technical code provided by the bank.",
    ///      "examples": [
    ///        "AC01"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "description": "A more detailed human-friendly description.",
    ///      "examples": [
    ///        "Account identifier incorrect (i.e. invalid IBAN)"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityChargebackReason {
        ///Technical code provided by the bank.
        pub code: ::std::string::String,
        ///A more detailed human-friendly description.
        pub description: ::std::string::String,
    }

    impl ::std::convert::From<&EntityChargebackReason> for EntityChargebackReason {
        fn from(value: &EntityChargebackReason) -> Self {
            value.clone()
        }
    }

    ///`EntityClient`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "onboarding": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "organization": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "commission": {
    ///      "description": "The commission object.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "count": {
    ///          "description": "The commission count.",
    ///          "type": "integer"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "The identifier uniquely referring to this client.
    /// Example: `org_12345678`.",
    ///      "readOnly": true,
    ///      "type": "string"
    ///    },
    ///    "organizationCreatedAt": {
    ///      "description": "The date and time the client organization was created, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)\nformat.",
    ///      "readOnly": true,
    ///      "type": "string"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a client object.
    /// Will always contain the string `client` for this resource type.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "client"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityClient {
        ///The commission object.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub commission: ::std::option::Option<EntityClientCommission>,
        ///The identifier uniquely referring to this client. Example:
        /// `org_12345678`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityClientLinks>,
        ///The date and time the client organization was created, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
        ///format.
        #[serde(
            rename = "organizationCreatedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub organization_created_at: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a client object. Will always contain
        /// the string `client` for this resource type.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityClient> for EntityClient {
        fn from(value: &EntityClient) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityClient {
        fn default() -> Self {
            Self {
                commission: Default::default(),
                id: Default::default(),
                links: Default::default(),
                organization_created_at: Default::default(),
                resource: Default::default(),
            }
        }
    }

    ///The commission object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The commission object.",
    ///  "type": "object",
    ///  "properties": {
    ///    "count": {
    ///      "description": "The commission count.",
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityClientCommission {
        ///The commission count.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<i64>,
    }

    impl ::std::convert::From<&EntityClientCommission> for EntityClientCommission {
        fn from(value: &EntityClientCommission) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityClientCommission {
        fn default() -> Self {
            Self {
                count: Default::default(),
            }
        }
    }

    ///`EntityClientLink`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "clientLink": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "address": {
    ///      "description": "Address of the organization.",
    ///      "writeOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "country"
    ///      ],
    ///      "properties": {
    ///        "city": {
    ///          "description": "The city of the organization. Required if a
    /// street address is provided.",
    ///          "examples": [
    ///            "Amsterdam"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "country": {
    ///          "description": "The country of the address in\n[ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.",
    ///          "examples": [
    ///            "NL"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "postalCode": {
    ///          "description": "The postal code of the organization. Required
    /// if a street address is provided and if the country has a postal\ncode
    /// system.",
    ///          "examples": [
    ///            "1234AB"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "streetAndNumber": {
    ///          "description": "The street name and house number of the
    /// organization.",
    ///          "examples": [
    ///            "Main Street 123"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "The identifier uniquely referring to this client
    /// link. Example: `cl_vZCnNQsV2UtfXxYifWKWH`.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "cl_vZCnNQsV2UtfXxYifWKWH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the organization.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "Acme Corporation"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "owner": {
    ///      "description": "Personal data of your customer.",
    ///      "writeOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "email",
    ///        "familyName",
    ///        "givenName"
    ///      ],
    ///      "properties": {
    ///        "email": {
    ///          "description": "The email address of your customer.",
    ///          "examples": [
    ///            "john@example.org"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "familyName": {
    ///          "description": "The family name (surname) of your customer.",
    ///          "examples": [
    ///            "Doe"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "givenName": {
    ///          "description": "The given name (first name) of your customer.",
    ///          "examples": [
    ///            "John"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "locale": {
    ///          "$ref": "#/components/schemas/locale-response"
    ///        }
    ///      }
    ///    },
    ///    "registrationNumber": {
    ///      "description": "The registration number of the organization at
    /// their local chamber of commerce.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        12345678
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a client link
    /// object. Will always contain the string `client-link` for
    /// this\nendpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "client-link"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "vatNumber": {
    ///      "description": "The VAT number of the organization, if based in the
    /// European Union. VAT numbers are verified against the\ninternational
    /// registry *VIES*.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "123456789B01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityClientLink {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<EntityClientLinkAddress>,
        ///The identifier uniquely referring to this client link. Example:
        /// `cl_vZCnNQsV2UtfXxYifWKWH`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityClientLinkLinks>,
        ///Name of the organization.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner: ::std::option::Option<EntityClientLinkOwner>,
        ///The registration number of the organization at their local chamber
        /// of commerce.
        #[serde(
            rename = "registrationNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub registration_number: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a client link object. Will always
        /// contain the string `client-link` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        ///The VAT number of the organization, if based in the European Union.
        /// VAT numbers are verified against the international registry
        /// *VIES*.
        #[serde(
            rename = "vatNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_number: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityClientLink> for EntityClientLink {
        fn from(value: &EntityClientLink) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityClientLink {
        fn default() -> Self {
            Self {
                address: Default::default(),
                id: Default::default(),
                links: Default::default(),
                name: Default::default(),
                owner: Default::default(),
                registration_number: Default::default(),
                resource: Default::default(),
                vat_number: Default::default(),
            }
        }
    }

    ///Address of the organization.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Address of the organization.",
    ///  "writeOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "country"
    ///  ],
    ///  "properties": {
    ///    "city": {
    ///      "description": "The city of the organization. Required if a street
    /// address is provided.",
    ///      "examples": [
    ///        "Amsterdam"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "country": {
    ///      "description": "The country of the address in\n[ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.",
    ///      "examples": [
    ///        "NL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "postalCode": {
    ///      "description": "The postal code of the organization. Required if a
    /// street address is provided and if the country has a postal\ncode
    /// system.",
    ///      "examples": [
    ///        "1234AB"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "streetAndNumber": {
    ///      "description": "The street name and house number of the
    /// organization.",
    ///      "examples": [
    ///        "Main Street 123"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityClientLinkAddress {
        ///The city of the organization. Required if a street address is
        /// provided.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub city: ::std::option::Option<::std::string::String>,
        ///The country of the address in
        ///[ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
        pub country: ::std::string::String,
        ///The postal code of the organization. Required if a street address is
        /// provided and if the country has a postal code system.
        #[serde(
            rename = "postalCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub postal_code: ::std::option::Option<::std::string::String>,
        ///The street name and house number of the organization.
        #[serde(
            rename = "streetAndNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub street_and_number: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityClientLinkAddress> for EntityClientLinkAddress {
        fn from(value: &EntityClientLinkAddress) -> Self {
            value.clone()
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "clientLink": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityClientLinkLinks {
        #[serde(
            rename = "clientLink",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub client_link: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&EntityClientLinkLinks> for EntityClientLinkLinks {
        fn from(value: &EntityClientLinkLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityClientLinkLinks {
        fn default() -> Self {
            Self {
                client_link: Default::default(),
                documentation: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///Personal data of your customer.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Personal data of your customer.",
    ///  "writeOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "familyName",
    ///    "givenName"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "description": "The email address of your customer.",
    ///      "examples": [
    ///        "john@example.org"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "familyName": {
    ///      "description": "The family name (surname) of your customer.",
    ///      "examples": [
    ///        "Doe"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "givenName": {
    ///      "description": "The given name (first name) of your customer.",
    ///      "examples": [
    ///        "John"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "locale": {
    ///      "$ref": "#/components/schemas/locale-response"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityClientLinkOwner {
        ///The email address of your customer.
        pub email: ::std::string::String,
        ///The family name (surname) of your customer.
        #[serde(rename = "familyName")]
        pub family_name: ::std::string::String,
        ///The given name (first name) of your customer.
        #[serde(rename = "givenName")]
        pub given_name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub locale: ::std::option::Option<LocaleResponse>,
    }

    impl ::std::convert::From<&EntityClientLinkOwner> for EntityClientLinkOwner {
        fn from(value: &EntityClientLinkOwner) -> Self {
            value.clone()
        }
    }

    ///`EntityClientLinkResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "clientLink": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "address": {
    ///      "description": "Address of the organization.",
    ///      "writeOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "country"
    ///      ],
    ///      "properties": {
    ///        "city": {
    ///          "description": "The city of the organization. Required if a
    /// street address is provided.",
    ///          "examples": [
    ///            "Amsterdam"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "country": {
    ///          "description": "The country of the address in\n[ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.",
    ///          "examples": [
    ///            "NL"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "postalCode": {
    ///          "description": "The postal code of the organization. Required
    /// if a street address is provided and if the country has a postal\ncode
    /// system.",
    ///          "examples": [
    ///            "1234AB"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "streetAndNumber": {
    ///          "description": "The street name and house number of the
    /// organization.",
    ///          "examples": [
    ///            "Main Street 123"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "The identifier uniquely referring to this client
    /// link. Example: `cl_vZCnNQsV2UtfXxYifWKWH`.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "cl_vZCnNQsV2UtfXxYifWKWH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the organization.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "Acme Corporation"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "owner": {
    ///      "description": "Personal data of your customer.",
    ///      "writeOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "email",
    ///        "familyName",
    ///        "givenName"
    ///      ],
    ///      "properties": {
    ///        "email": {
    ///          "description": "The email address of your customer.",
    ///          "examples": [
    ///            "john@example.org"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "familyName": {
    ///          "description": "The family name (surname) of your customer.",
    ///          "examples": [
    ///            "Doe"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "givenName": {
    ///          "description": "The given name (first name) of your customer.",
    ///          "examples": [
    ///            "John"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "locale": {
    ///          "$ref": "#/components/schemas/locale-response"
    ///        }
    ///      }
    ///    },
    ///    "registrationNumber": {
    ///      "description": "The registration number of the organization at
    /// their local chamber of commerce.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        12345678
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a client link
    /// object. Will always contain the string `client-link` for
    /// this\nendpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "client-link"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "vatNumber": {
    ///      "description": "The VAT number of the organization, if based in the
    /// European Union. VAT numbers are verified against the\ninternational
    /// registry *VIES*.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "123456789B01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityClientLinkResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<EntityClientLinkResponseAddress>,
        ///The identifier uniquely referring to this client link. Example:
        /// `cl_vZCnNQsV2UtfXxYifWKWH`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityClientLinkResponseLinks>,
        ///Name of the organization.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner: ::std::option::Option<EntityClientLinkResponseOwner>,
        ///The registration number of the organization at their local chamber
        /// of commerce.
        #[serde(
            rename = "registrationNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub registration_number: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a client link object. Will always
        /// contain the string `client-link` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        ///The VAT number of the organization, if based in the European Union.
        /// VAT numbers are verified against the international registry
        /// *VIES*.
        #[serde(
            rename = "vatNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_number: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityClientLinkResponse> for EntityClientLinkResponse {
        fn from(value: &EntityClientLinkResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityClientLinkResponse {
        fn default() -> Self {
            Self {
                address: Default::default(),
                id: Default::default(),
                links: Default::default(),
                name: Default::default(),
                owner: Default::default(),
                registration_number: Default::default(),
                resource: Default::default(),
                vat_number: Default::default(),
            }
        }
    }

    ///Address of the organization.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Address of the organization.",
    ///  "writeOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "country"
    ///  ],
    ///  "properties": {
    ///    "city": {
    ///      "description": "The city of the organization. Required if a street
    /// address is provided.",
    ///      "examples": [
    ///        "Amsterdam"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "country": {
    ///      "description": "The country of the address in\n[ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.",
    ///      "examples": [
    ///        "NL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "postalCode": {
    ///      "description": "The postal code of the organization. Required if a
    /// street address is provided and if the country has a postal\ncode
    /// system.",
    ///      "examples": [
    ///        "1234AB"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "streetAndNumber": {
    ///      "description": "The street name and house number of the
    /// organization.",
    ///      "examples": [
    ///        "Main Street 123"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityClientLinkResponseAddress {
        ///The city of the organization. Required if a street address is
        /// provided.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub city: ::std::option::Option<::std::string::String>,
        ///The country of the address in
        ///[ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
        pub country: ::std::string::String,
        ///The postal code of the organization. Required if a street address is
        /// provided and if the country has a postal code system.
        #[serde(
            rename = "postalCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub postal_code: ::std::option::Option<::std::string::String>,
        ///The street name and house number of the organization.
        #[serde(
            rename = "streetAndNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub street_and_number: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityClientLinkResponseAddress> for EntityClientLinkResponseAddress {
        fn from(value: &EntityClientLinkResponseAddress) -> Self {
            value.clone()
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "clientLink": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityClientLinkResponseLinks {
        #[serde(
            rename = "clientLink",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub client_link: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&EntityClientLinkResponseLinks> for EntityClientLinkResponseLinks {
        fn from(value: &EntityClientLinkResponseLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityClientLinkResponseLinks {
        fn default() -> Self {
            Self {
                client_link: Default::default(),
                documentation: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///Personal data of your customer.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Personal data of your customer.",
    ///  "writeOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "familyName",
    ///    "givenName"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "description": "The email address of your customer.",
    ///      "examples": [
    ///        "john@example.org"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "familyName": {
    ///      "description": "The family name (surname) of your customer.",
    ///      "examples": [
    ///        "Doe"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "givenName": {
    ///      "description": "The given name (first name) of your customer.",
    ///      "examples": [
    ///        "John"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "locale": {
    ///      "$ref": "#/components/schemas/locale-response"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityClientLinkResponseOwner {
        ///The email address of your customer.
        pub email: ::std::string::String,
        ///The family name (surname) of your customer.
        #[serde(rename = "familyName")]
        pub family_name: ::std::string::String,
        ///The given name (first name) of your customer.
        #[serde(rename = "givenName")]
        pub given_name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub locale: ::std::option::Option<LocaleResponse>,
    }

    impl ::std::convert::From<&EntityClientLinkResponseOwner> for EntityClientLinkResponseOwner {
        fn from(value: &EntityClientLinkResponseOwner) -> Self {
            value.clone()
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "onboarding": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "organization": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityClientLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub onboarding: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub organization: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&EntityClientLinks> for EntityClientLinks {
        fn from(value: &EntityClientLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityClientLinks {
        fn default() -> Self {
            Self {
                documentation: Default::default(),
                onboarding: Default::default(),
                organization: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///`EntityCustomer`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "dashboard",
    ///        "documentation",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "dashboard": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "mandates": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        },
    ///        "payments": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "subscriptions": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        }
    ///      }
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "email": {
    ///      "description": "The email address of the customer.",
    ///      "examples": [
    ///        "example@email.com"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/customerToken"
    ///    },
    ///    "locale": {
    ///      "$ref": "#/components/schemas/locale-response"
    ///    },
    ///    "metadata": {
    ///      "$ref": "#/components/schemas/metadata"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "name": {
    ///      "description": "The full name of the customer.",
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a customer object.
    /// Will always contain the string `customer` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "customer"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityCustomer {
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        ///The email address of the customer.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<CustomerToken>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityCustomerLinks>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub locale: ::std::option::Option<LocaleResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<Metadata>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<Mode>,
        ///The full name of the customer.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a customer object. Will always
        /// contain the string `customer` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
    }

    impl ::std::convert::From<&EntityCustomer> for EntityCustomer {
        fn from(value: &EntityCustomer) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityCustomer {
        fn default() -> Self {
            Self {
                created_at: Default::default(),
                email: Default::default(),
                id: Default::default(),
                links: Default::default(),
                locale: Default::default(),
                metadata: Default::default(),
                mode: Default::default(),
                name: Default::default(),
                resource: Default::default(),
                testmode: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "dashboard",
    ///    "documentation",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "dashboard": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "mandates": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "payments": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "subscriptions": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityCustomerLinks {
        pub dashboard: Url,
        pub documentation: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mandates: ::std::option::Option<UrlNullable>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payments: ::std::option::Option<UrlNullable>,
        #[serde(rename = "self")]
        pub self_: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub subscriptions: ::std::option::Option<UrlNullable>,
    }

    impl ::std::convert::From<&EntityCustomerLinks> for EntityCustomerLinks {
        fn from(value: &EntityCustomerLinks) -> Self {
            value.clone()
        }
    }

    ///`EntityCustomerResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "dashboard",
    ///        "documentation",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "dashboard": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "mandates": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        },
    ///        "payments": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "subscriptions": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        }
    ///      }
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "email": {
    ///      "description": "The email address of the customer.",
    ///      "examples": [
    ///        "example@email.com"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/customerToken"
    ///    },
    ///    "locale": {
    ///      "$ref": "#/components/schemas/locale-response"
    ///    },
    ///    "metadata": {
    ///      "$ref": "#/components/schemas/metadata"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "name": {
    ///      "description": "The full name of the customer.",
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a customer object.
    /// Will always contain the string `customer` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "customer"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityCustomerResponse {
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        ///The email address of the customer.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<CustomerToken>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityCustomerResponseLinks>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub locale: ::std::option::Option<LocaleResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<Metadata>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<Mode>,
        ///The full name of the customer.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a customer object. Will always
        /// contain the string `customer` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
    }

    impl ::std::convert::From<&EntityCustomerResponse> for EntityCustomerResponse {
        fn from(value: &EntityCustomerResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityCustomerResponse {
        fn default() -> Self {
            Self {
                created_at: Default::default(),
                email: Default::default(),
                id: Default::default(),
                links: Default::default(),
                locale: Default::default(),
                metadata: Default::default(),
                mode: Default::default(),
                name: Default::default(),
                resource: Default::default(),
                testmode: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "dashboard",
    ///    "documentation",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "dashboard": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "mandates": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "payments": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "subscriptions": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityCustomerResponseLinks {
        pub dashboard: Url,
        pub documentation: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mandates: ::std::option::Option<UrlNullable>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payments: ::std::option::Option<UrlNullable>,
        #[serde(rename = "self")]
        pub self_: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub subscriptions: ::std::option::Option<UrlNullable>,
    }

    impl ::std::convert::From<&EntityCustomerResponseLinks> for EntityCustomerResponseLinks {
        fn from(value: &EntityCustomerResponseLinks) -> Self {
            value.clone()
        }
    }

    ///`EntityEvent`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "createdAt",
    ///    "message",
    ///    "resource",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "type": "object",
    ///      "properties": {
    ///        "url": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "message": {
    ///      "examples": [
    ///        "Customer created"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "resource": {
    ///      "examples": [
    ///        "event"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        200
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityEvent {
        #[serde(rename = "createdAt")]
        pub created_at: CreatedAt,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityEventLinks>,
        pub message: ::std::string::String,
        pub resource: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: i64,
    }

    impl ::std::convert::From<&EntityEvent> for EntityEvent {
        fn from(value: &EntityEvent) -> Self {
            value.clone()
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "type": "object",
    ///  "properties": {
    ///    "url": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityEventLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub url: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&EntityEventLinks> for EntityEventLinks {
        fn from(value: &EntityEventLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityEventLinks {
        fn default() -> Self {
            Self {
                url: Default::default(),
            }
        }
    }

    ///`EntityInvoice`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "pdf": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "dueAt": {
    ///      "description": "The date on which the invoice is due, if
    /// applicable, in `YYYY-MM-DD` format.",
    ///      "readOnly": true,
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "grossAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "id": {
    ///      "description": "The identifier uniquely referring to this invoice.
    /// Example: `inv_FrvewDA3Pr`.",
    ///      "readOnly": true,
    ///      "type": "string"
    ///    },
    ///    "issuedAt": {
    ///      "description": "The invoice date in `YYYY-MM-DD` format.",
    ///      "readOnly": true,
    ///      "type": "string"
    ///    },
    ///    "lines": {
    ///      "description": "The collection of products which make up the
    /// invoice.",
    ///      "readOnly": true,
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "properties": {
    ///          "amount": {
    ///            "$ref": "#/components/schemas/amount"
    ///          },
    ///          "count": {
    ///            "description": "Number of products invoiced. For example, the
    /// number of payments.",
    ///            "type": "integer"
    ///          },
    ///          "description": {
    ///            "description": "Description of the product.",
    ///            "type": "string"
    ///          },
    ///          "period": {
    ///            "description": "The administrative period in `YYYY-MM` on
    /// which the line should be booked.",
    ///            "type": "string"
    ///          },
    ///          "vatPercentage": {
    ///            "description": "VAT percentage rate that applies to this
    /// product.",
    ///            "type": "integer"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "netAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "paidAt": {
    ///      "description": "The date on which the invoice was paid, if
    /// applicable, in `YYYY-MM-DD` format.",
    ///      "readOnly": true,
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "reference": {
    ///      "description": "The reference number of the invoice. An example
    /// value would be: `2024.10000`.",
    ///      "readOnly": true,
    ///      "type": "string"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates that the response contains an invoice object.\nWill always contain the string `invoice` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "invoice"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/invoice-status"
    ///    },
    ///    "vatAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "vatNumber": {
    ///      "description": "The VAT number to which the invoice was issued to,
    /// if applicable.",
    ///      "readOnly": true,
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityInvoice {
        ///The date on which the invoice is due, if applicable, in `YYYY-MM-DD`
        /// format.
        #[serde(
            rename = "dueAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub due_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "grossAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub gross_amount: ::std::option::Option<Amount>,
        ///The identifier uniquely referring to this invoice. Example:
        /// `inv_FrvewDA3Pr`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        ///The invoice date in `YYYY-MM-DD` format.
        #[serde(
            rename = "issuedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub issued_at: ::std::option::Option<::std::string::String>,
        ///The collection of products which make up the invoice.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub lines: ::std::vec::Vec<EntityInvoiceLinesItem>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityInvoiceLinks>,
        #[serde(
            rename = "netAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub net_amount: ::std::option::Option<Amount>,
        ///The date on which the invoice was paid, if applicable, in
        /// `YYYY-MM-DD` format.
        #[serde(
            rename = "paidAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paid_at: ::std::option::Option<::std::string::String>,
        ///The reference number of the invoice. An example value would be:
        /// `2024.10000`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub reference: ::std::option::Option<::std::string::String>,
        ///Indicates that the response contains an invoice object.
        ///Will always contain the string `invoice` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<InvoiceStatus>,
        #[serde(
            rename = "vatAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_amount: ::std::option::Option<Amount>,
        ///The VAT number to which the invoice was issued to, if applicable.
        #[serde(
            rename = "vatNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_number: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityInvoice> for EntityInvoice {
        fn from(value: &EntityInvoice) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityInvoice {
        fn default() -> Self {
            Self {
                due_at: Default::default(),
                gross_amount: Default::default(),
                id: Default::default(),
                issued_at: Default::default(),
                lines: Default::default(),
                links: Default::default(),
                net_amount: Default::default(),
                paid_at: Default::default(),
                reference: Default::default(),
                resource: Default::default(),
                status: Default::default(),
                vat_amount: Default::default(),
                vat_number: Default::default(),
            }
        }
    }

    ///`EntityInvoiceLinesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "count": {
    ///      "description": "Number of products invoiced. For example, the
    /// number of payments.",
    ///      "type": "integer"
    ///    },
    ///    "description": {
    ///      "description": "Description of the product.",
    ///      "type": "string"
    ///    },
    ///    "period": {
    ///      "description": "The administrative period in `YYYY-MM` on which the
    /// line should be booked.",
    ///      "type": "string"
    ///    },
    ///    "vatPercentage": {
    ///      "description": "VAT percentage rate that applies to this product.",
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityInvoiceLinesItem {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<Amount>,
        ///Number of products invoiced. For example, the number of payments.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<i64>,
        ///Description of the product.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        ///The administrative period in `YYYY-MM` on which the line should be
        /// booked.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub period: ::std::option::Option<::std::string::String>,
        ///VAT percentage rate that applies to this product.
        #[serde(
            rename = "vatPercentage",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_percentage: ::std::option::Option<i64>,
    }

    impl ::std::convert::From<&EntityInvoiceLinesItem> for EntityInvoiceLinesItem {
        fn from(value: &EntityInvoiceLinesItem) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityInvoiceLinesItem {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                count: Default::default(),
                description: Default::default(),
                period: Default::default(),
                vat_percentage: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "pdf": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityInvoiceLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pdf: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&EntityInvoiceLinks> for EntityInvoiceLinks {
        fn from(value: &EntityInvoiceLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityInvoiceLinks {
        fn default() -> Self {
            Self {
                documentation: Default::default(),
                pdf: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///`EntityMandate`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "customer",
    ///        "documentation",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "customer": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "consumerAccount": {
    ///      "description": "The customer's IBAN. Required for SEPA Direct Debit
    /// mandates.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "NL55INGB0000000000"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "consumerBic": {
    ///      "description": "The BIC of the customer's bank.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "BANKBIC"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "consumerEmail": {
    ///      "description": "The customer's email address. Required for PayPal
    /// mandates.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "example@email.com"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "consumerName": {
    ///      "description": "The customer's name.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "customerId": {
    ///      "$ref": "#/components/schemas/customerToken"
    ///    },
    ///    "details": {
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "cardExpiryDate": {
    ///          "description": "The card's expiry date in `YYYY-MM-DD` format.
    /// Available for card mandates.",
    ///          "examples": [
    ///            "2025-01-01"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "cardFingerprint": {
    ///          "description": "Unique alphanumeric representation of this
    /// specific card. Available for card mandates. Can be used to
    /// identify\nreturning customers.",
    ///          "examples": [
    ///            "d3290e932k02f"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "cardHolder": {
    ///          "description": "The card holder's name. Available for card
    /// mandates.",
    ///          "examples": [
    ///            "John Doe"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "cardLabel": {
    ///          "$ref": "#/components/schemas/mandate-details-card-label"
    ///        },
    ///        "cardNumber": {
    ///          "description": "The last four digits of the card number.
    /// Available for card mandates.",
    ///          "examples": [
    ///            3240
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "consumerAccount": {
    ///          "description": "The customer's IBAN or email address. Available
    /// for SEPA Direct Debit and PayPal mandates.",
    ///          "examples": [
    ///            "NL55INGB0000000000"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "consumerBic": {
    ///          "description": "The BIC of the customer's bank. Available for
    /// SEPA Direct Debit mandates.",
    ///          "examples": [
    ///            "BANKBIC"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "consumerName": {
    ///          "description": "The customer's name. Available for SEPA Direct
    /// Debit and PayPal mandates.",
    ///          "examples": [
    ///            "John Doe"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/mandateToken"
    ///    },
    ///    "mandateReference": {
    ///      "description": "A custom mandate reference. For SEPA Direct Debit,
    /// it is vital to provide a unique reference. Some banks will\ndecline
    /// Direct Debit payments if the mandate reference is not unique.",
    ///      "examples": [
    ///        "ID-1023892"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "method": {
    ///      "$ref": "#/components/schemas/mandate-method"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "payPalVaultId": {
    ///      "description": "The Vault ID given by PayPal. For example:
    /// `8kk8451t`. Required for PayPal mandates.\nMust provide either this
    /// field or `paypalBillingAgreementId`, but not both.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "8kk8451t"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "paypalBillingAgreementId": {
    ///      "description": "The billing agreement ID given by PayPal. For
    /// example: `B-12A34567B8901234CD`. Required for PayPal mandates.\nMust
    /// provide either this field or `payPalVaultId`, but not both.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "B-12A34567B8901234CD"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a mandate object.
    /// Will always contain the string `mandate` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "mandate"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "signatureDate": {
    ///      "description": "The date when the mandate was signed in
    /// `YYYY-MM-DD` format.",
    ///      "examples": [
    ///        "2025-01-01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/mandate-status"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityMandate {
        ///The customer's IBAN. Required for SEPA Direct Debit mandates.
        #[serde(
            rename = "consumerAccount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_account: ::std::option::Option<::std::string::String>,
        ///The BIC of the customer's bank.
        #[serde(
            rename = "consumerBic",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_bic: ::std::option::Option<::std::string::String>,
        ///The customer's email address. Required for PayPal mandates.
        #[serde(
            rename = "consumerEmail",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_email: ::std::option::Option<::std::string::String>,
        ///The customer's name.
        #[serde(
            rename = "consumerName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_name: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        #[serde(
            rename = "customerId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub customer_id: ::std::option::Option<CustomerToken>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub details: ::std::option::Option<EntityMandateDetails>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<MandateToken>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityMandateLinks>,
        ///A custom mandate reference. For SEPA Direct Debit, it is vital to
        /// provide a unique reference. Some banks will decline Direct
        /// Debit payments if the mandate reference is not unique.
        #[serde(
            rename = "mandateReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub mandate_reference: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub method: ::std::option::Option<MandateMethod>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<Mode>,
        ///The Vault ID given by PayPal. For example: `8kk8451t`. Required for
        /// PayPal mandates. Must provide either this field or
        /// `paypalBillingAgreementId`, but not both.
        #[serde(
            rename = "payPalVaultId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub pay_pal_vault_id: ::std::option::Option<::std::string::String>,
        ///The billing agreement ID given by PayPal. For example:
        /// `B-12A34567B8901234CD`. Required for PayPal mandates.
        /// Must provide either this field or `payPalVaultId`, but not both.
        #[serde(
            rename = "paypalBillingAgreementId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paypal_billing_agreement_id: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a mandate object. Will always
        /// contain the string `mandate` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        ///The date when the mandate was signed in `YYYY-MM-DD` format.
        #[serde(
            rename = "signatureDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub signature_date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<MandateStatus>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
    }

    impl ::std::convert::From<&EntityMandate> for EntityMandate {
        fn from(value: &EntityMandate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityMandate {
        fn default() -> Self {
            Self {
                consumer_account: Default::default(),
                consumer_bic: Default::default(),
                consumer_email: Default::default(),
                consumer_name: Default::default(),
                created_at: Default::default(),
                customer_id: Default::default(),
                details: Default::default(),
                id: Default::default(),
                links: Default::default(),
                mandate_reference: Default::default(),
                method: Default::default(),
                mode: Default::default(),
                pay_pal_vault_id: Default::default(),
                paypal_billing_agreement_id: Default::default(),
                resource: Default::default(),
                signature_date: Default::default(),
                status: Default::default(),
                testmode: Default::default(),
            }
        }
    }

    ///`EntityMandateDetails`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "cardExpiryDate": {
    ///      "description": "The card's expiry date in `YYYY-MM-DD` format.
    /// Available for card mandates.",
    ///      "examples": [
    ///        "2025-01-01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "cardFingerprint": {
    ///      "description": "Unique alphanumeric representation of this specific
    /// card. Available for card mandates. Can be used to identify\nreturning
    /// customers.",
    ///      "examples": [
    ///        "d3290e932k02f"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "cardHolder": {
    ///      "description": "The card holder's name. Available for card
    /// mandates.",
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "cardLabel": {
    ///      "$ref": "#/components/schemas/mandate-details-card-label"
    ///    },
    ///    "cardNumber": {
    ///      "description": "The last four digits of the card number. Available
    /// for card mandates.",
    ///      "examples": [
    ///        3240
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "consumerAccount": {
    ///      "description": "The customer's IBAN or email address. Available for
    /// SEPA Direct Debit and PayPal mandates.",
    ///      "examples": [
    ///        "NL55INGB0000000000"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "consumerBic": {
    ///      "description": "The BIC of the customer's bank. Available for SEPA
    /// Direct Debit mandates.",
    ///      "examples": [
    ///        "BANKBIC"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "consumerName": {
    ///      "description": "The customer's name. Available for SEPA Direct
    /// Debit and PayPal mandates.",
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityMandateDetails {
        ///The card's expiry date in `YYYY-MM-DD` format. Available for card
        /// mandates.
        #[serde(
            rename = "cardExpiryDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_expiry_date: ::std::option::Option<::std::string::String>,
        ///Unique alphanumeric representation of this specific card. Available
        /// for card mandates. Can be used to identify
        /// returning customers.
        #[serde(
            rename = "cardFingerprint",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_fingerprint: ::std::option::Option<::std::string::String>,
        ///The card holder's name. Available for card mandates.
        #[serde(
            rename = "cardHolder",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_holder: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cardLabel",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_label: ::std::option::Option<MandateDetailsCardLabel>,
        ///The last four digits of the card number. Available for card
        /// mandates.
        #[serde(
            rename = "cardNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_number: ::std::option::Option<::std::string::String>,
        ///The customer's IBAN or email address. Available for SEPA Direct
        /// Debit and PayPal mandates.
        #[serde(
            rename = "consumerAccount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_account: ::std::option::Option<::std::string::String>,
        ///The BIC of the customer's bank. Available for SEPA Direct Debit
        /// mandates.
        #[serde(
            rename = "consumerBic",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_bic: ::std::option::Option<::std::string::String>,
        ///The customer's name. Available for SEPA Direct Debit and PayPal
        /// mandates.
        #[serde(
            rename = "consumerName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_name: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityMandateDetails> for EntityMandateDetails {
        fn from(value: &EntityMandateDetails) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityMandateDetails {
        fn default() -> Self {
            Self {
                card_expiry_date: Default::default(),
                card_fingerprint: Default::default(),
                card_holder: Default::default(),
                card_label: Default::default(),
                card_number: Default::default(),
                consumer_account: Default::default(),
                consumer_bic: Default::default(),
                consumer_name: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "customer",
    ///    "documentation",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "customer": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityMandateLinks {
        pub customer: Url,
        pub documentation: Url,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&EntityMandateLinks> for EntityMandateLinks {
        fn from(value: &EntityMandateLinks) -> Self {
            value.clone()
        }
    }

    ///`EntityMandateResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "customer",
    ///        "documentation",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "customer": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "consumerAccount": {
    ///      "description": "The customer's IBAN. Required for SEPA Direct Debit
    /// mandates.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "NL55INGB0000000000"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "consumerBic": {
    ///      "description": "The BIC of the customer's bank.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "BANKBIC"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "consumerEmail": {
    ///      "description": "The customer's email address. Required for PayPal
    /// mandates.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "example@email.com"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "consumerName": {
    ///      "description": "The customer's name.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "customerId": {
    ///      "$ref": "#/components/schemas/customerToken"
    ///    },
    ///    "details": {
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "cardExpiryDate": {
    ///          "description": "The card's expiry date in `YYYY-MM-DD` format.
    /// Available for card mandates.",
    ///          "examples": [
    ///            "2025-01-01"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "cardFingerprint": {
    ///          "description": "Unique alphanumeric representation of this
    /// specific card. Available for card mandates. Can be used to
    /// identify\nreturning customers.",
    ///          "examples": [
    ///            "d3290e932k02f"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "cardHolder": {
    ///          "description": "The card holder's name. Available for card
    /// mandates.",
    ///          "examples": [
    ///            "John Doe"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "cardLabel": {
    ///          "$ref":
    /// "#/components/schemas/mandate-details-card-label-response"
    ///        },
    ///        "cardNumber": {
    ///          "description": "The last four digits of the card number.
    /// Available for card mandates.",
    ///          "examples": [
    ///            3240
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "consumerAccount": {
    ///          "description": "The customer's IBAN or email address. Available
    /// for SEPA Direct Debit and PayPal mandates.",
    ///          "examples": [
    ///            "NL55INGB0000000000"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "consumerBic": {
    ///          "description": "The BIC of the customer's bank. Available for
    /// SEPA Direct Debit mandates.",
    ///          "examples": [
    ///            "BANKBIC"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "consumerName": {
    ///          "description": "The customer's name. Available for SEPA Direct
    /// Debit and PayPal mandates.",
    ///          "examples": [
    ///            "John Doe"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/mandateToken"
    ///    },
    ///    "mandateReference": {
    ///      "description": "A custom mandate reference. For SEPA Direct Debit,
    /// it is vital to provide a unique reference. Some banks will\ndecline
    /// Direct Debit payments if the mandate reference is not unique.",
    ///      "examples": [
    ///        "ID-1023892"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "method": {
    ///      "$ref": "#/components/schemas/mandate-method-response"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "payPalVaultId": {
    ///      "description": "The Vault ID given by PayPal. For example:
    /// `8kk8451t`. Required for PayPal mandates.\nMust provide either this
    /// field or `paypalBillingAgreementId`, but not both.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "8kk8451t"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "paypalBillingAgreementId": {
    ///      "description": "The billing agreement ID given by PayPal. For
    /// example: `B-12A34567B8901234CD`. Required for PayPal mandates.\nMust
    /// provide either this field or `payPalVaultId`, but not both.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "B-12A34567B8901234CD"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a mandate object.
    /// Will always contain the string `mandate` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "mandate"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "signatureDate": {
    ///      "description": "The date when the mandate was signed in
    /// `YYYY-MM-DD` format.",
    ///      "examples": [
    ///        "2025-01-01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/mandate-status"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityMandateResponse {
        ///The customer's IBAN. Required for SEPA Direct Debit mandates.
        #[serde(
            rename = "consumerAccount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_account: ::std::option::Option<::std::string::String>,
        ///The BIC of the customer's bank.
        #[serde(
            rename = "consumerBic",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_bic: ::std::option::Option<::std::string::String>,
        ///The customer's email address. Required for PayPal mandates.
        #[serde(
            rename = "consumerEmail",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_email: ::std::option::Option<::std::string::String>,
        ///The customer's name.
        #[serde(
            rename = "consumerName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_name: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        #[serde(
            rename = "customerId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub customer_id: ::std::option::Option<CustomerToken>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub details: ::std::option::Option<EntityMandateResponseDetails>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<MandateToken>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityMandateResponseLinks>,
        ///A custom mandate reference. For SEPA Direct Debit, it is vital to
        /// provide a unique reference. Some banks will decline Direct
        /// Debit payments if the mandate reference is not unique.
        #[serde(
            rename = "mandateReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub mandate_reference: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub method: ::std::option::Option<MandateMethodResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<Mode>,
        ///The Vault ID given by PayPal. For example: `8kk8451t`. Required for
        /// PayPal mandates. Must provide either this field or
        /// `paypalBillingAgreementId`, but not both.
        #[serde(
            rename = "payPalVaultId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub pay_pal_vault_id: ::std::option::Option<::std::string::String>,
        ///The billing agreement ID given by PayPal. For example:
        /// `B-12A34567B8901234CD`. Required for PayPal mandates.
        /// Must provide either this field or `payPalVaultId`, but not both.
        #[serde(
            rename = "paypalBillingAgreementId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paypal_billing_agreement_id: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a mandate object. Will always
        /// contain the string `mandate` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        ///The date when the mandate was signed in `YYYY-MM-DD` format.
        #[serde(
            rename = "signatureDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub signature_date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<MandateStatus>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
    }

    impl ::std::convert::From<&EntityMandateResponse> for EntityMandateResponse {
        fn from(value: &EntityMandateResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityMandateResponse {
        fn default() -> Self {
            Self {
                consumer_account: Default::default(),
                consumer_bic: Default::default(),
                consumer_email: Default::default(),
                consumer_name: Default::default(),
                created_at: Default::default(),
                customer_id: Default::default(),
                details: Default::default(),
                id: Default::default(),
                links: Default::default(),
                mandate_reference: Default::default(),
                method: Default::default(),
                mode: Default::default(),
                pay_pal_vault_id: Default::default(),
                paypal_billing_agreement_id: Default::default(),
                resource: Default::default(),
                signature_date: Default::default(),
                status: Default::default(),
                testmode: Default::default(),
            }
        }
    }

    ///`EntityMandateResponseDetails`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "cardExpiryDate": {
    ///      "description": "The card's expiry date in `YYYY-MM-DD` format.
    /// Available for card mandates.",
    ///      "examples": [
    ///        "2025-01-01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "cardFingerprint": {
    ///      "description": "Unique alphanumeric representation of this specific
    /// card. Available for card mandates. Can be used to identify\nreturning
    /// customers.",
    ///      "examples": [
    ///        "d3290e932k02f"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "cardHolder": {
    ///      "description": "The card holder's name. Available for card
    /// mandates.",
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "cardLabel": {
    ///      "$ref": "#/components/schemas/mandate-details-card-label-response"
    ///    },
    ///    "cardNumber": {
    ///      "description": "The last four digits of the card number. Available
    /// for card mandates.",
    ///      "examples": [
    ///        3240
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "consumerAccount": {
    ///      "description": "The customer's IBAN or email address. Available for
    /// SEPA Direct Debit and PayPal mandates.",
    ///      "examples": [
    ///        "NL55INGB0000000000"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "consumerBic": {
    ///      "description": "The BIC of the customer's bank. Available for SEPA
    /// Direct Debit mandates.",
    ///      "examples": [
    ///        "BANKBIC"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "consumerName": {
    ///      "description": "The customer's name. Available for SEPA Direct
    /// Debit and PayPal mandates.",
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityMandateResponseDetails {
        ///The card's expiry date in `YYYY-MM-DD` format. Available for card
        /// mandates.
        #[serde(
            rename = "cardExpiryDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_expiry_date: ::std::option::Option<::std::string::String>,
        ///Unique alphanumeric representation of this specific card. Available
        /// for card mandates. Can be used to identify
        /// returning customers.
        #[serde(
            rename = "cardFingerprint",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_fingerprint: ::std::option::Option<::std::string::String>,
        ///The card holder's name. Available for card mandates.
        #[serde(
            rename = "cardHolder",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_holder: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cardLabel",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_label: ::std::option::Option<MandateDetailsCardLabelResponse>,
        ///The last four digits of the card number. Available for card
        /// mandates.
        #[serde(
            rename = "cardNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_number: ::std::option::Option<::std::string::String>,
        ///The customer's IBAN or email address. Available for SEPA Direct
        /// Debit and PayPal mandates.
        #[serde(
            rename = "consumerAccount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_account: ::std::option::Option<::std::string::String>,
        ///The BIC of the customer's bank. Available for SEPA Direct Debit
        /// mandates.
        #[serde(
            rename = "consumerBic",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_bic: ::std::option::Option<::std::string::String>,
        ///The customer's name. Available for SEPA Direct Debit and PayPal
        /// mandates.
        #[serde(
            rename = "consumerName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_name: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityMandateResponseDetails> for EntityMandateResponseDetails {
        fn from(value: &EntityMandateResponseDetails) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityMandateResponseDetails {
        fn default() -> Self {
            Self {
                card_expiry_date: Default::default(),
                card_fingerprint: Default::default(),
                card_holder: Default::default(),
                card_label: Default::default(),
                card_number: Default::default(),
                consumer_account: Default::default(),
                consumer_bic: Default::default(),
                consumer_name: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "customer",
    ///    "documentation",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "customer": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityMandateResponseLinks {
        pub customer: Url,
        pub documentation: Url,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&EntityMandateResponseLinks> for EntityMandateResponseLinks {
        fn from(value: &EntityMandateResponseLinks) -> Self {
            value.clone()
        }
    }

    ///`EntityMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_links",
    ///    "description",
    ///    "id",
    ///    "image",
    ///    "maximumAmount",
    ///    "minimumAmount",
    ///    "resource",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "description": {
    ///      "description": "The full name of the payment method.\n\nIf a
    /// `locale` parameter is provided, the name is translated to the given
    /// locale if possible.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "iDeal"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/method-response"
    ///    },
    ///    "image": {
    ///      "description": "URLs of images representing the payment method.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "size1x",
    ///        "size2x",
    ///        "svg"
    ///      ],
    ///      "properties": {
    ///        "size1x": {
    ///          "description": "The URL pointing to an icon of 32 by 24
    /// pixels.",
    ///          "examples": [
    ///            "https://..."
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "size2x": {
    ///          "description": "The URL pointing to an icon of 64 by 48
    /// pixels.",
    ///          "examples": [
    ///            "https://..."
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "svg": {
    ///          "description": "The URL pointing to a vector version of the
    /// icon. Usage of this format is preferred, since the icon can\nscale to
    /// any desired size without compromising visual quality.",
    ///          "examples": [
    ///            "https://..."
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "issuers": {
    ///      "description": "**Optional include.** Array of objects for each
    /// 'issuer' that is available for this payment method. Only relevant\nfor
    /// iDEAL, KBC/CBC, gift cards, and vouchers.",
    ///      "type": "array",
    ///      "items": {
    ///        "readOnly": true,
    ///        "type": "object",
    ///        "required": [
    ///          "id",
    ///          "image",
    ///          "name",
    ///          "resource"
    ///        ],
    ///        "properties": {
    ///          "id": {
    ///            "examples": [
    ///              "ideal_ABNANL2A"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "image": {
    ///            "description": "URLs of images representing the
    /// issuer.\nrequired:\n  - size1x\n  - size2x\n  - svg",
    ///            "type": "object",
    ///            "properties": {
    ///              "size1x": {
    ///                "description": "The URL pointing to an icon of 32 by 24
    /// pixels.",
    ///                "examples": [
    ///                  "https://..."
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "size2x": {
    ///                "description": "The URL pointing to an icon of 64 by 48
    /// pixels.",
    ///                "examples": [
    ///                  "https://..."
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "svg": {
    ///                "description": "The URL pointing to a vector version of
    /// the icon. Usage of this format is preferred, since the icon can\nscale
    /// to any desired size without compromising visual quality.",
    ///                "examples": [
    ///                  "https://..."
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          },
    ///          "name": {
    ///            "description": "The full name of the issuer.",
    ///            "examples": [
    ///              "ING Bank"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "resource": {
    ///            "examples": [
    ///              "issuer"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "maximumAmount": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "minimumAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a payment method object. Will always contain the string `method` for this\nendpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "method"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/method-status"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityMethod {
        ///The full name of the payment method.
        ///
        ///If a `locale` parameter is provided, the name is translated to the
        /// given locale if possible.
        pub description: ::std::string::String,
        pub id: MethodResponse,
        pub image: EntityMethodImage,
        ///**Optional include.** Array of objects for each 'issuer' that is
        /// available for this payment method. Only relevant for iDEAL,
        /// KBC/CBC, gift cards, and vouchers.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub issuers: ::std::vec::Vec<EntityMethodIssuersItem>,
        #[serde(rename = "_links")]
        pub links: EntityMethodLinks,
        #[serde(rename = "maximumAmount")]
        pub maximum_amount: AmountNullable,
        #[serde(rename = "minimumAmount")]
        pub minimum_amount: Amount,
        ///Indicates the response contains a payment method object. Will always
        /// contain the string `method` for this endpoint.
        pub resource: ::std::string::String,
        pub status: MethodStatus,
    }

    impl ::std::convert::From<&EntityMethod> for EntityMethod {
        fn from(value: &EntityMethod) -> Self {
            value.clone()
        }
    }

    ///`EntityMethodAll`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/entity-method"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "pricing": {
    ///          "description": "**Optional include.** Array of objects
    /// describing the pricing configuration applicable for this payment method
    /// on\nyour account.",
    ///          "readOnly": true,
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "description",
    ///              "fixed",
    ///              "variable"
    ///            ],
    ///            "properties": {
    ///              "description": {
    ///                "description": "A description of what the pricing applies
    /// to. For example, a specific country (`The Netherlands`) or a\ncategory
    /// of cards (`American Express`). If a `locale` is provided, the
    /// description may be translated.",
    ///                "examples": [
    ///                  "The Netherlands"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "feeRegion": {
    ///                "description": "Only present for credit card pricing. It
    /// will correspond with the `feeRegion` of credit card payments
    /// as\nreturned in the [Payments API](get-payment).",
    ///                "examples": [
    ///                  "other"
    ///                ],
    ///                "type": [
    ///                  "string",
    ///                  "null"
    ///                ]
    ///              },
    ///              "fixed": {
    ///                "$ref": "#/components/schemas/amount"
    ///              },
    ///              "variable": {
    ///                "description": "The variable price charged per payment,
    /// as a percentage string.",
    ///                "examples": [
    ///                  0
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityMethodAll {
        ///The full name of the payment method.
        ///
        ///If a `locale` parameter is provided, the name is translated to the
        /// given locale if possible.
        pub description: ::std::string::String,
        pub id: MethodResponse,
        pub image: EntityMethodAllImage,
        ///**Optional include.** Array of objects for each 'issuer' that is
        /// available for this payment method. Only relevant for iDEAL,
        /// KBC/CBC, gift cards, and vouchers.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub issuers: ::std::vec::Vec<EntityMethodAllIssuersItem>,
        #[serde(rename = "_links")]
        pub links: EntityMethodAllLinks,
        #[serde(rename = "maximumAmount")]
        pub maximum_amount: AmountNullable,
        #[serde(rename = "minimumAmount")]
        pub minimum_amount: Amount,
        ///**Optional include.** Array of objects describing the pricing
        /// configuration applicable for this payment method on
        /// your account.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub pricing: ::std::vec::Vec<EntityMethodAllPricingItem>,
        ///Indicates the response contains a payment method object. Will always
        /// contain the string `method` for this endpoint.
        pub resource: ::std::string::String,
        pub status: MethodStatus,
    }

    impl ::std::convert::From<&EntityMethodAll> for EntityMethodAll {
        fn from(value: &EntityMethodAll) -> Self {
            value.clone()
        }
    }

    ///URLs of images representing the payment method.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "URLs of images representing the payment method.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "size1x",
    ///    "size2x",
    ///    "svg"
    ///  ],
    ///  "properties": {
    ///    "size1x": {
    ///      "description": "The URL pointing to an icon of 32 by 24 pixels.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "size2x": {
    ///      "description": "The URL pointing to an icon of 64 by 48 pixels.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "svg": {
    ///      "description": "The URL pointing to a vector version of the icon.
    /// Usage of this format is preferred, since the icon can\nscale to any
    /// desired size without compromising visual quality.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityMethodAllImage {
        ///The URL pointing to an icon of 32 by 24 pixels.
        pub size1x: ::std::string::String,
        ///The URL pointing to an icon of 64 by 48 pixels.
        pub size2x: ::std::string::String,
        ///The URL pointing to a vector version of the icon. Usage of this
        /// format is preferred, since the icon can scale to any desired
        /// size without compromising visual quality.
        pub svg: ::std::string::String,
    }

    impl ::std::convert::From<&EntityMethodAllImage> for EntityMethodAllImage {
        fn from(value: &EntityMethodAllImage) -> Self {
            value.clone()
        }
    }

    ///`EntityMethodAllIssuersItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "image",
    ///    "name",
    ///    "resource"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "examples": [
    ///        "ideal_ABNANL2A"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "image": {
    ///      "description": "URLs of images representing the
    /// issuer.\nrequired:\n  - size1x\n  - size2x\n  - svg",
    ///      "type": "object",
    ///      "properties": {
    ///        "size1x": {
    ///          "description": "The URL pointing to an icon of 32 by 24
    /// pixels.",
    ///          "examples": [
    ///            "https://..."
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "size2x": {
    ///          "description": "The URL pointing to an icon of 64 by 48
    /// pixels.",
    ///          "examples": [
    ///            "https://..."
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "svg": {
    ///          "description": "The URL pointing to a vector version of the
    /// icon. Usage of this format is preferred, since the icon can\nscale to
    /// any desired size without compromising visual quality.",
    ///          "examples": [
    ///            "https://..."
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "name": {
    ///      "description": "The full name of the issuer.",
    ///      "examples": [
    ///        "ING Bank"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "resource": {
    ///      "examples": [
    ///        "issuer"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityMethodAllIssuersItem {
        pub id: ::std::string::String,
        pub image: EntityMethodAllIssuersItemImage,
        ///The full name of the issuer.
        pub name: ::std::string::String,
        pub resource: ::std::string::String,
    }

    impl ::std::convert::From<&EntityMethodAllIssuersItem> for EntityMethodAllIssuersItem {
        fn from(value: &EntityMethodAllIssuersItem) -> Self {
            value.clone()
        }
    }

    ///URLs of images representing the issuer.
    ///required:
    ///  - size1x
    ///  - size2x
    ///  - svg
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "URLs of images representing the issuer.\nrequired:\n  -
    /// size1x\n  - size2x\n  - svg",
    ///  "type": "object",
    ///  "properties": {
    ///    "size1x": {
    ///      "description": "The URL pointing to an icon of 32 by 24 pixels.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "size2x": {
    ///      "description": "The URL pointing to an icon of 64 by 48 pixels.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "svg": {
    ///      "description": "The URL pointing to a vector version of the icon.
    /// Usage of this format is preferred, since the icon can\nscale to any
    /// desired size without compromising visual quality.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityMethodAllIssuersItemImage {
        ///The URL pointing to an icon of 32 by 24 pixels.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub size1x: ::std::option::Option<::std::string::String>,
        ///The URL pointing to an icon of 64 by 48 pixels.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub size2x: ::std::option::Option<::std::string::String>,
        ///The URL pointing to a vector version of the icon. Usage of this
        /// format is preferred, since the icon can scale to any desired
        /// size without compromising visual quality.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub svg: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityMethodAllIssuersItemImage> for EntityMethodAllIssuersItemImage {
        fn from(value: &EntityMethodAllIssuersItemImage) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityMethodAllIssuersItemImage {
        fn default() -> Self {
            Self {
                size1x: Default::default(),
                size2x: Default::default(),
                svg: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityMethodAllLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&EntityMethodAllLinks> for EntityMethodAllLinks {
        fn from(value: &EntityMethodAllLinks) -> Self {
            value.clone()
        }
    }

    ///`EntityMethodAllPricingItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "fixed",
    ///    "variable"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "A description of what the pricing applies to. For
    /// example, a specific country (`The Netherlands`) or a\ncategory of cards
    /// (`American Express`). If a `locale` is provided, the description may be
    /// translated.",
    ///      "examples": [
    ///        "The Netherlands"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "feeRegion": {
    ///      "description": "Only present for credit card pricing. It will
    /// correspond with the `feeRegion` of credit card payments as\nreturned in
    /// the [Payments API](get-payment).",
    ///      "examples": [
    ///        "other"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "fixed": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "variable": {
    ///      "description": "The variable price charged per payment, as a
    /// percentage string.",
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityMethodAllPricingItem {
        ///A description of what the pricing applies to. For example, a
        /// specific country (`The Netherlands`) or a category of cards
        /// (`American Express`). If a `locale` is provided, the description may
        /// be translated.
        pub description: ::std::string::String,
        ///Only present for credit card pricing. It will correspond with the
        /// `feeRegion` of credit card payments as returned in the
        /// [Payments API](get-payment).
        #[serde(
            rename = "feeRegion",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub fee_region: ::std::option::Option<::std::string::String>,
        pub fixed: Amount,
        ///The variable price charged per payment, as a percentage string.
        pub variable: ::std::string::String,
    }

    impl ::std::convert::From<&EntityMethodAllPricingItem> for EntityMethodAllPricingItem {
        fn from(value: &EntityMethodAllPricingItem) -> Self {
            value.clone()
        }
    }

    ///URLs of images representing the payment method.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "URLs of images representing the payment method.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "size1x",
    ///    "size2x",
    ///    "svg"
    ///  ],
    ///  "properties": {
    ///    "size1x": {
    ///      "description": "The URL pointing to an icon of 32 by 24 pixels.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "size2x": {
    ///      "description": "The URL pointing to an icon of 64 by 48 pixels.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "svg": {
    ///      "description": "The URL pointing to a vector version of the icon.
    /// Usage of this format is preferred, since the icon can\nscale to any
    /// desired size without compromising visual quality.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityMethodImage {
        ///The URL pointing to an icon of 32 by 24 pixels.
        pub size1x: ::std::string::String,
        ///The URL pointing to an icon of 64 by 48 pixels.
        pub size2x: ::std::string::String,
        ///The URL pointing to a vector version of the icon. Usage of this
        /// format is preferred, since the icon can scale to any desired
        /// size without compromising visual quality.
        pub svg: ::std::string::String,
    }

    impl ::std::convert::From<&EntityMethodImage> for EntityMethodImage {
        fn from(value: &EntityMethodImage) -> Self {
            value.clone()
        }
    }

    ///`EntityMethodIssuersItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "image",
    ///    "name",
    ///    "resource"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "examples": [
    ///        "ideal_ABNANL2A"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "image": {
    ///      "description": "URLs of images representing the
    /// issuer.\nrequired:\n  - size1x\n  - size2x\n  - svg",
    ///      "type": "object",
    ///      "properties": {
    ///        "size1x": {
    ///          "description": "The URL pointing to an icon of 32 by 24
    /// pixels.",
    ///          "examples": [
    ///            "https://..."
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "size2x": {
    ///          "description": "The URL pointing to an icon of 64 by 48
    /// pixels.",
    ///          "examples": [
    ///            "https://..."
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "svg": {
    ///          "description": "The URL pointing to a vector version of the
    /// icon. Usage of this format is preferred, since the icon can\nscale to
    /// any desired size without compromising visual quality.",
    ///          "examples": [
    ///            "https://..."
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "name": {
    ///      "description": "The full name of the issuer.",
    ///      "examples": [
    ///        "ING Bank"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "resource": {
    ///      "examples": [
    ///        "issuer"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityMethodIssuersItem {
        pub id: ::std::string::String,
        pub image: EntityMethodIssuersItemImage,
        ///The full name of the issuer.
        pub name: ::std::string::String,
        pub resource: ::std::string::String,
    }

    impl ::std::convert::From<&EntityMethodIssuersItem> for EntityMethodIssuersItem {
        fn from(value: &EntityMethodIssuersItem) -> Self {
            value.clone()
        }
    }

    ///URLs of images representing the issuer.
    ///required:
    ///  - size1x
    ///  - size2x
    ///  - svg
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "URLs of images representing the issuer.\nrequired:\n  -
    /// size1x\n  - size2x\n  - svg",
    ///  "type": "object",
    ///  "properties": {
    ///    "size1x": {
    ///      "description": "The URL pointing to an icon of 32 by 24 pixels.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "size2x": {
    ///      "description": "The URL pointing to an icon of 64 by 48 pixels.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "svg": {
    ///      "description": "The URL pointing to a vector version of the icon.
    /// Usage of this format is preferred, since the icon can\nscale to any
    /// desired size without compromising visual quality.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityMethodIssuersItemImage {
        ///The URL pointing to an icon of 32 by 24 pixels.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub size1x: ::std::option::Option<::std::string::String>,
        ///The URL pointing to an icon of 64 by 48 pixels.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub size2x: ::std::option::Option<::std::string::String>,
        ///The URL pointing to a vector version of the icon. Usage of this
        /// format is preferred, since the icon can scale to any desired
        /// size without compromising visual quality.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub svg: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityMethodIssuersItemImage> for EntityMethodIssuersItemImage {
        fn from(value: &EntityMethodIssuersItemImage) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityMethodIssuersItemImage {
        fn default() -> Self {
            Self {
                size1x: Default::default(),
                size2x: Default::default(),
                svg: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityMethodLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&EntityMethodLinks> for EntityMethodLinks {
        fn from(value: &EntityMethodLinks) -> Self {
            value.clone()
        }
    }

    ///`EntityOnboardingStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "dashboard": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "organization": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "canReceivePayments": {
    ///      "description": "Whether the organization can receive payments.",
    ///      "readOnly": true,
    ///      "type": "boolean"
    ///    },
    ///    "canReceiveSettlements": {
    ///      "description": "Whether the organization can receive settlements to
    /// their external bank account.",
    ///      "readOnly": true,
    ///      "type": "boolean"
    ///    },
    ///    "name": {
    ///      "description": "The name of the organization.",
    ///      "readOnly": true,
    ///      "type": "string"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains an onboarding
    /// status object. Will always contain the string `onboarding` for
    /// this\nresource type.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "onboarding"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "signedUpAt": {
    ///      "description": "The sign up date time of the organization in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.",
    ///      "readOnly": true,
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/onboarding-status"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityOnboardingStatus {
        ///Whether the organization can receive payments.
        #[serde(
            rename = "canReceivePayments",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub can_receive_payments: ::std::option::Option<bool>,
        ///Whether the organization can receive settlements to their external
        /// bank account.
        #[serde(
            rename = "canReceiveSettlements",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub can_receive_settlements: ::std::option::Option<bool>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityOnboardingStatusLinks>,
        ///The name of the organization.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains an onboarding status object. Will
        /// always contain the string `onboarding` for this
        /// resource type.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        ///The sign up date time of the organization in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        #[serde(
            rename = "signedUpAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub signed_up_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<OnboardingStatus>,
    }

    impl ::std::convert::From<&EntityOnboardingStatus> for EntityOnboardingStatus {
        fn from(value: &EntityOnboardingStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityOnboardingStatus {
        fn default() -> Self {
            Self {
                can_receive_payments: Default::default(),
                can_receive_settlements: Default::default(),
                links: Default::default(),
                name: Default::default(),
                resource: Default::default(),
                signed_up_at: Default::default(),
                status: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "dashboard": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "organization": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityOnboardingStatusLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub dashboard: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub organization: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&EntityOnboardingStatusLinks> for EntityOnboardingStatusLinks {
        fn from(value: &EntityOnboardingStatusLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityOnboardingStatusLinks {
        fn default() -> Self {
            Self {
                dashboard: Default::default(),
                documentation: Default::default(),
                organization: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///`EntityOrganization`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "dashboard": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "address": {
    ///      "$ref": "#/components/schemas/address"
    ///    },
    ///    "email": {
    ///      "description": "The email address associated with the
    /// organization.",
    ///      "readOnly": true,
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "The identifier uniquely referring to this
    /// organization. Example: `org_12345678`.",
    ///      "readOnly": true,
    ///      "type": "string"
    ///    },
    ///    "locale": {
    ///      "$ref": "#/components/schemas/locale-response"
    ///    },
    ///    "name": {
    ///      "description": "The name of the organization.",
    ///      "readOnly": true,
    ///      "type": "string"
    ///    },
    ///    "registrationNumber": {
    ///      "description": "The registration number of the organization at
    /// their local chamber of commerce.",
    ///      "type": "string"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains an organization
    /// object. Will always contain the string `organization` for this\nresource
    /// type.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "organization"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "vatNumber": {
    ///      "description": "The VAT number of the organization, if based in the
    /// European Union or in The United Kingdom. VAT numbers are\nverified
    /// against the international registry *VIES*.\n\nThe field is not present
    /// for merchants residing in other countries.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "vatRegulation": {
    ///      "$ref": "#/components/schemas/organization-vat-regulation"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityOrganization {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<Address>,
        ///The email address associated with the organization.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        ///The identifier uniquely referring to this organization. Example:
        /// `org_12345678`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityOrganizationLinks>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub locale: ::std::option::Option<LocaleResponse>,
        ///The name of the organization.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///The registration number of the organization at their local chamber
        /// of commerce.
        #[serde(
            rename = "registrationNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub registration_number: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains an organization object. Will always
        /// contain the string `organization` for this resource type.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        ///The VAT number of the organization, if based in the European Union
        /// or in The United Kingdom. VAT numbers are verified against
        /// the international registry *VIES*.
        ///
        ///The field is not present for merchants residing in other countries.
        #[serde(
            rename = "vatNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_number: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "vatRegulation",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_regulation: ::std::option::Option<OrganizationVatRegulation>,
    }

    impl ::std::convert::From<&EntityOrganization> for EntityOrganization {
        fn from(value: &EntityOrganization) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityOrganization {
        fn default() -> Self {
            Self {
                address: Default::default(),
                email: Default::default(),
                id: Default::default(),
                links: Default::default(),
                locale: Default::default(),
                name: Default::default(),
                registration_number: Default::default(),
                resource: Default::default(),
                vat_number: Default::default(),
                vat_regulation: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "dashboard": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityOrganizationLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub dashboard: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&EntityOrganizationLinks> for EntityOrganizationLinks {
        fn from(value: &EntityOrganizationLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityOrganizationLinks {
        fn default() -> Self {
            Self {
                dashboard: Default::default(),
                documentation: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///`EntityPayment`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "dashboard",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "captures": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "changePaymentState": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "chargebacks": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "checkout": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "customer": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "dashboard": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "mandate": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "mobileAppCheckout": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "order": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "payOnline": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "refunds": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "settlement": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "status": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "subscription": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "terminal": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "amountCaptured": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "amountChargedBack": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "amountRefunded": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "amountRemaining": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "applicationFee": {
    ///      "description": "With Mollie Connect you can charge fees on payments
    /// that your app is processing on behalf of other Mollie\nmerchants.\n\nIf
    /// you use OAuth to create payments on a connected merchant's account, you
    /// can charge a fee using this\n`applicationFee` parameter. If the payment
    /// succeeds, the fee will be deducted from the merchant's balance and
    /// sent\nto your own account balance.\n\nIf instead you want to split a
    /// payment on your own account between yourself and a connected merchant,
    /// refer to the\n`routing` parameter.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "amount": {
    ///          "$ref": "#/components/schemas/amount"
    ///        },
    ///        "description": {
    ///          "description": "The description of the application fee. This
    /// will appear on settlement reports towards both you and the\nconnected
    /// merchant.",
    ///          "examples": [
    ///            10
    ///          ],
    ///          "type": "string",
    ///          "maxLength": 255
    ///        }
    ///      }
    ///    },
    ///    "authorizedAt": {
    ///      "description": "The date and time the payment became authorized, in
    /// ISO 8601 format. This parameter is omitted if the payment is\nnot
    /// authorized (yet).",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-03-20T09:28:37.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "billingAddress": {
    ///      "description": "The customer's billing address details. We advise
    /// to provide these details to improve fraud protection
    /// and\nconversion.\n\nShould include `email` or a valid postal address
    /// consisting of `streetAndNumber`, `postalCode`, `city`
    /// and\n`country`.\n\nRequired for payment method `in3`, `klarna`, `billie`
    /// and `riverty`.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/payment-address"
    ///        },
    ///        {
    ///          "type": "object",
    ///          "properties": {
    ///            "organizationName": {
    ///              "description": "The name of the organization, in case the addressee is an organization.\n\nRequired for payment method `billie`."
    ///            }
    ///          }
    ///        }
    ///      ]
    ///    },
    ///    "cancelUrl": {
    ///      "description": "The URL your customer will be redirected to when
    /// the customer explicitly cancels the payment. If this URL is
    /// not\nprovided, the customer will be redirected to the `redirectUrl`
    /// instead — see above.\n\nMollie will always give you status updates via
    /// webhooks, including for the canceled status. This parameter
    /// is\ntherefore entirely optional, but can be useful when implementing a
    /// dedicated customer-facing flow to handle\npayment cancellations.",
    ///      "examples": [
    ///        "https://example.org/cancel"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "canceledAt": {
    ///      "description": "The date and time the payment was canceled, in ISO
    /// 8601 format. This parameter is omitted if the payment is not\ncanceled
    /// (yet).",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-03-20T09:28:37.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "captureBefore": {
    ///      "description": "Indicates the date before which the payment needs
    /// to be captured, in ISO 8601 format. From this date onwards we\ncan no
    /// longer guarantee a successful capture. The parameter is omitted if the
    /// payment is not authorized (yet).",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-03-20T09:28:37.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "captureDelay": {
    ///      "description": "**Only relevant if you wish to manage authorization
    /// and capturing separately.**\n\nSome payment methods allow placing a hold
    /// on the card or bank account. This hold or 'authorization' can then at
    /// a\nlater point either be 'captured' or canceled.\n\nBy default, we
    /// charge the customer's card or bank account immediately when they
    /// complete the payment. If you set a\ncapture delay however, we will delay
    /// the automatic capturing of the payment for the specified amount of time.
    /// For\nexample `8 hours` or `2 days`.\n\nTo schedule an automatic capture,
    /// the `captureMode` must be set to `automatic`.\n\nThe maximum delay is 7
    /// days (168 hours).\n\nPossible values: `... hours` `... days`",
    ///      "examples": [
    ///        "8 hours"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "pattern": "^\\d+ (hours|days)$"
    ///    },
    ///    "captureMode": {
    ///      "$ref": "#/components/schemas/capture-mode"
    ///    },
    ///    "countryCode": {
    ///      "description": "This optional field contains your customer's ISO
    /// 3166-1 alpha-2 country code, detected by us during checkout. This\nfield
    /// is omitted if the country code was not detected.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "BE"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "maxLength": 2,
    ///      "minLength": 2
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "customerId": {
    ///      "$ref": "#/components/schemas/customerToken"
    ///    },
    ///    "description": {
    ///      "description": "The description of the payment. This will be shown
    /// to your customer on their card or bank statement when possible.\nWe
    /// truncate the description automatically according to the limits of the
    /// used payment method. The description is\nalso visible in any exports you
    /// generate.\n\nWe recommend you use a unique identifier so that you can
    /// always link the payment to the order in your back office.\nThis is
    /// particularly useful for bookkeeping.\n\nThe maximum length of the
    /// description field differs per payment method, with the absolute maximum
    /// being 255\ncharacters. The API will not reject strings longer than the
    /// maximum length but it will truncate them to fit.",
    ///      "examples": [
    ///        "Chess Board"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "details": {
    ///      "description": "An object containing payment details collected
    /// during the payment process. For example, details may include
    /// the\ncustomer's card or bank details and a payment reference. For the
    /// full list of details, please refer to the\n[method-specific
    /// parameters](extra-payment-parameters) guide.",
    ///      "readOnly": true,
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "bankAccount": {
    ///          "description": "The bank account number the customer will need
    /// to make the bank transfer payment towards.",
    ///          "examples": [
    ///            "NL91ABNA0417164300"
    ///          ],
    ///          "type": "string",
    ///          "x-methodSpecific": true
    ///        },
    ///        "bankBic": {
    ///          "description": "The BIC of the bank the customer will need to
    /// make the bank transfer payment towards.",
    ///          "examples": [
    ///            "ABNANL2A"
    ///          ],
    ///          "type": "string",
    ///          "x-methodSpecific": true
    ///        },
    ///        "bankName": {
    ///          "description": "The name of the bank that the customer will
    /// need to make the bank transfer payment towards.",
    ///          "examples": [
    ///            "Mollie Bank"
    ///          ],
    ///          "type": "string",
    ///          "x-methodSpecific": true
    ///        },
    ///        "bankReason": {
    ///          "description": "A human-friendly description of the failure
    /// reason.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "bankReasonCode": {
    ///          "description": "The official reason why this payment has
    /// failed. A detailed description of each reason is available on
    /// the\nwebsite of the European Payments Council.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "batchReference": {
    ///          "description": "The batch reference you provided in the batch
    /// file.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "card3dsEci": {
    ///          "description": "The outcome of authentication attempted on
    /// transactions enforced by 3DS (ie valid only for oneoff and first).",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardAudition": {
    ///          "$ref": "#/components/schemas/payment-details-card-audition"
    ///        },
    ///        "cardBin": {
    ///          "description": "The first 6 digit of the card bank
    /// identification number.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardCountryCode": {
    ///          "description": "The ISO 3166-1 alpha-2 country code of the
    /// country the card was issued in.",
    ///          "examples": [
    ///            "NL"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardExpiryDate": {
    ///          "description": "The expiry date (MM/YY) of the card as
    /// displayed on the card.",
    ///          "examples": [
    ///            "12/25"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardFingerprint": {
    ///          "description": "A unique fingerprint for a specific card. Can
    /// be used to identify returning customers.\n\nIn the case of Point-of-sale
    /// payments, it's a unique identifier assigned to a cardholder's payment
    /// account,\nlinking multiple transactions from wallets and physical card
    /// to a single account, also across payment methods\nor when the card is
    /// reissued.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardFunding": {
    ///          "$ref": "#/components/schemas/payment-details-card-funding"
    ///        },
    ///        "cardHolder": {
    ///          "description": "The customer's name as shown on their card.",
    ///          "examples": [
    ///            "John Doe"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardIssuer": {
    ///          "description": "The issuer of the Card.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardLabel": {
    ///          "$ref": "#/components/schemas/payment-details-card-label"
    ///        },
    ///        "cardMaskedNumber": {
    ///          "description": "The first 6 and last 4 digits of the card
    /// number.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardNumber": {
    ///          "description": "For bancontact, it will be the customer's
    /// masked card number. For cards, it will be the last 4-digit of the\nPAN.
    /// For Point-of-sale, it will be the the last 4 digits of the customer's
    /// masked card number.",
    ///          "examples": [
    ///            "************1234"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardSecurity": {
    ///          "$ref": "#/components/schemas/payment-details-card-security"
    ///        },
    ///        "consumerAccount": {
    ///          "description": "The customer's account reference.\n\nFor
    /// banking-based payment methods — such as iDEAL — this is normally either
    /// an IBAN or a domestic bank account\nnumber.\n\nFor PayPal, the account
    /// reference is an email address.\n\nFor card and Bancontact payments,
    /// refer to details.cardNumber.",
    ///          "examples": [
    ///            "NL91ABNA0417164300"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "consumerBic": {
    ///          "description": "The BIC of the customer's bank account, if
    /// applicable.",
    ///          "examples": [
    ///            "ABNANL2A"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "consumerName": {
    ///          "description": "The customer's name, if made available by the
    /// payment method. For card payments, refer to details.cardHolder.",
    ///          "examples": [
    ///            "John Doe"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "creditorIdentifier": {
    ///          "description": "The creditor identifier indicates who is
    /// authorized to execute the payment. In this case, it is a\nreference to
    /// Mollie.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "customerReference": {
    ///          "description": "The paysafecard customer reference either
    /// provided via the API or otherwise auto-generated by Mollie.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": "string",
    ///          "x-methodSpecific": true
    ///        },
    ///        "dueDate": {
    ///          "description": "Estimated date the payment is debited from the
    /// customer's bank account, in YYYY-MM-DD format.",
    ///          "examples": [
    ///            "2025-01-01"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "format": "date",
    ///          "x-methodSpecific": true
    ///        },
    ///        "endToEndIdentifier": {
    ///          "description": "The end-to-end identifier you provided in the
    /// batch file.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "failureMessage": {
    ///          "description": "A human-friendly failure message that can be
    /// shown to the customer. The message is translated in accordance\nwith the
    /// payment's locale setting.",
    ///          "examples": [
    ///            "Your card was declined."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "failureReason": {
    ///          "$ref": "#/components/schemas/payment-details-failure-reason"
    ///        },
    ///        "feeRegion": {
    ///          "$ref": "#/components/schemas/payment-details-fee-region"
    ///        },
    ///        "fileReference": {
    ///          "description": "The file reference you provided in the batch
    /// file.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "giftcards": {
    ///          "description": "An array of detail objects for each gift card
    /// that was used on this payment, if any.",
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "additionalProperties": true
    ///          },
    ///          "x-methodSpecific": true
    ///        },
    ///        "issuer": {
    ///          "description": "For payments with vouchers: the brand name of
    /// the first voucher applied.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": "string",
    ///          "x-methodSpecific": true
    ///        },
    ///        "mandateReference": {
    ///          "description": "The mandate reference you provided in the batch
    /// file.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "maskedNumber": {
    ///          "description": "The first 6 digits & last 4 digits of the
    /// customer's masked card number.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "paypalFee": {
    ///          "$ref": "#/components/schemas/amount-nullable"
    ///        },
    ///        "paypalPayerId": {
    ///          "description": "ID of the customer's PayPal account.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "paypalReference": {
    ///          "description": "PayPal's reference for the payment.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "qrCode": {
    ///          "description": "Optional include. If a QR code was requested
    /// during payment creation for a QR-compatible payment method,\nthe QR code
    /// details will be available in this object.\n\nThe QR code can be scanned
    /// by the customer to complete the payment on their mobile device. For
    /// example,\nBancontact QR payments can be completed by the customer using
    /// the Bancontact app.",
    ///          "type": "object",
    ///          "properties": {
    ///            "height": {
    ///              "description": "The height of the QR code image in
    /// pixels.",
    ///              "examples": [
    ///                300
    ///              ],
    ///              "type": "integer"
    ///            },
    ///            "src": {
    ///              "description": "The URL to the QR code image. The image is
    /// a PNG file, and can be displayed directly in the browser
    /// or\ndownloaded.",
    ///              "examples": [
    ///                "https://www.mollie.com/images/qr-code.png"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "width": {
    ///              "description": "The width of the QR code image in pixels.",
    ///              "examples": [
    ///                300
    ///              ],
    ///              "type": "integer"
    ///            }
    ///          },
    ///          "x-methodSpecific": true
    ///        },
    ///        "receipt": {
    ///          "description": "The Point of sale receipt object.",
    ///          "type": "object",
    ///          "properties": {
    ///            "applicationIdentifier": {
    ///              "description": "The unique number that identifies a
    /// specific payment application on a chip card.",
    ///              "examples": [
    ///                "..."
    ///              ],
    ///              "type": [
    ///                "string",
    ///                "null"
    ///              ]
    ///            },
    ///            "authorizationCode": {
    ///              "description": "A unique code provided by the cardholder’s
    /// bank to confirm that the transaction was successfully approved.",
    ///              "examples": [
    ///                "..."
    ///              ],
    ///              "type": [
    ///                "string",
    ///                "null"
    ///              ]
    ///            },
    ///            "cardReadMethod": {
    ///              "$ref":
    /// "#/components/schemas/payment-details-receipt-card-read-method"
    ///            },
    ///            "cardVerificationMethod": {
    ///              "$ref":
    /// "#/components/schemas/payment-details-receipt-card-verification-method"
    ///            }
    ///          },
    ///          "x-methodSpecific": true
    ///        },
    ///        "remainderAmount": {
    ///          "$ref": "#/components/schemas/amount"
    ///        },
    ///        "remainderDetails": {
    ///          "description": "Optional include. The full payment method
    /// details of the remainder payment.",
    ///          "type": "object",
    ///          "additionalProperties": true,
    ///          "x-methodSpecific": true
    ///        },
    ///        "remainderMethod": {
    ///          "description": "The payment method used to pay the remainder
    /// amount, after all gift cards or vouchers were applied.",
    ///          "examples": [
    ///            "creditcard"
    ///          ],
    ///          "type": "string",
    ///          "x-methodSpecific": true
    ///        },
    ///        "sellerProtection": {
    ///          "$ref":
    /// "#/components/schemas/payment-details-seller-protection"
    ///        },
    ///        "shippingAddress": {
    ///          "description": "For wallet payment methods — such as Apple Pay
    /// and PayPal — the shipping address is often already known by the\nwallet
    /// provider. In these cases the shipping address may be available as a
    /// payment detail.",
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "additionalProperties": true,
    ///          "x-methodSpecific": true
    ///        },
    ///        "signatureDate": {
    ///          "description": "Date the payment has been signed by the
    /// customer, in YYYY-MM-DD format. Only available if the payment\nhas been
    /// signed.",
    ///          "examples": [
    ///            "2024-03-20"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "format": "date",
    ///          "x-methodSpecific": true
    ///        },
    ///        "terminalId": {
    ///          "description": "The ID of the terminal device where the payment
    /// took place on.",
    ///          "examples": [
    ///            "term_12345"
    ///          ],
    ///          "type": "string",
    ///          "x-methodSpecific": true
    ///        },
    ///        "transferReference": {
    ///          "description": "The Mollie-generated reference the customer
    /// needs to use when transfering the amount. Do not apply any\nformatting
    /// here; show it to the customer as-is.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "voucherNumber": {
    ///          "description": "For payments with gift cards: the masked gift
    /// card number of the first gift card applied to the payment.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": "string",
    ///          "x-methodSpecific": true
    ///        },
    ///        "vouchers": {
    ///          "description": "An array of detail objects for each voucher
    /// that was used on this payment, if any.",
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "additionalProperties": true
    ///          },
    ///          "x-methodSpecific": true
    ///        },
    ///        "wallet": {
    ///          "$ref": "#/components/schemas/payment-details-wallet"
    ///        }
    ///      }
    ///    },
    ///    "dueDate": {
    ///      "description": "The date by which the payment should be completed
    /// in `YYYY-MM-DD` format",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "2025-01-01"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "expiredAt": {
    ///      "description": "The date and time the payment was expired, in ISO
    /// 8601 format. This parameter is omitted if the payment did not\nexpire
    /// (yet).",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-03-20T09:28:37.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "expiresAt": {
    ///      "description": "The date and time the payment will expire, in ISO
    /// 8601 format. This parameter is omitted if the payment can no\nlonger
    /// expire.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-03-20T09:28:37.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "failedAt": {
    ///      "description": "The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail\n(yet).",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-03-20T09:28:37.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    },
    ///    "isCancelable": {
    ///      "description": "Whether the payment can be canceled. This parameter
    /// is omitted if the payment reaches a final state.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "issuer": {
    ///      "description": "**Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**\n\n**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information\non the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**\n\nSome payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment\nmethod, the customer may still need to select the appropriate issuer before the payment can proceed.\n\nWe provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API\nup front.\n\nThe full list of issuers for a specific method can be retrieved via the Methods API by using the optional\n`issuers` include.\n\nA valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "ideal_INGBNL2A"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "lines": {
    ///      "description": "Optionally provide the order lines for the payment.
    /// Each line contains details such as a description of the item\nordered
    /// and its price.\n\nAll lines must have the same currency as the
    /// payment.\n\nRequired for payment methods `billie`, `in3`, `klarna`,
    /// `riverty` and `voucher`.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "allOf": [
    ///          {
    ///            "$ref": "#/components/schemas/payment-line-item"
    ///          },
    ///          {
    ///            "type": "object",
    ///            "properties": {
    ///              "recurring": {
    ///                "$ref": "#/components/schemas/recurring-line-item"
    ///              }
    ///            }
    ///          }
    ///        ]
    ///      }
    ///    },
    ///    "locale": {
    ///      "$ref": "#/components/schemas/locale"
    ///    },
    ///    "mandateId": {
    ///      "$ref": "#/components/schemas/mandateToken"
    ///    },
    ///    "metadata": {
    ///      "$ref": "#/components/schemas/metadata"
    ///    },
    ///    "method": {
    ///      "$ref": "#/components/schemas/method"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "orderId": {
    ///      "$ref": "#/components/schemas/orderToken"
    ///    },
    ///    "paidAt": {
    ///      "description": "The date and time the payment became paid, in ISO
    /// 8601 format. This parameter is omitted if the payment is not\ncompleted
    /// (yet).",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-03-20T09:28:37.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "profileId": {
    ///      "$ref": "#/components/schemas/profileToken"
    ///    },
    ///    "redirectUrl": {
    ///      "description": "The URL your customer will be redirected to after
    /// the payment process.\n\nIt could make sense for the redirectUrl to
    /// contain a unique identifier – like your order ID – so you can show
    /// the\nright page referencing the order when your customer returns.\n\nThe
    /// parameter is normally required, but can be omitted for recurring
    /// payments (`sequenceType: recurring`) and for\nApple Pay payments with an
    /// `applePayPaymentToken`.",
    ///      "examples": [
    ///        "https://example.org/redirect"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a payment object.
    /// Will always contain the string `payment` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "payment"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "restrictPaymentMethodsToCountry": {
    ///      "description": "For digital goods in most jurisdictions, you must
    /// apply the VAT rate from your customer's country. Choose the VAT\nrates
    /// you have used for the order to ensure your customer's country matches
    /// the VAT country.\n\nUse this parameter to restrict the payment methods
    /// available to your customer to those from a single country.\n\nIf
    /// available, the credit card method will still be offered, but only cards
    /// from the allowed country are accepted.\n\nThe field expects a country
    /// code in ISO 3166-1 alpha-2 format, for example `NL`.",
    ///      "examples": [
    ///        "NL"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "routing": {
    ///      "description": "*This functionality is not enabled by default.
    /// Reach out to our partner management team if you wish to use it.*\n\nWith
    /// Mollie Connect you can charge fees on payments that your app is
    /// processing on behalf of other Mollie\nmerchants.\n\nIf you create
    /// payments on your own account that you want to split between yourself and
    /// one or more connected\nmerchants, you can use this `routing` parameter
    /// to route the payment accordingly.\n\nThe `routing` parameter should
    /// contain an array of objects, with each object describing the destination
    /// for a\nspecific portion of the payment.\n\nIt is not necessary to
    /// indicate in the array which portion goes to yourself. After all portions
    /// of the total\npayment amount have been routed, the amount left will be
    /// routed to the current organization automatically.\n\nIf instead you use
    /// OAuth to create payments on a connected merchant's account, refer to the
    /// `applicationFee`\nparameter.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-payment-route"
    ///      }
    ///    },
    ///    "sequenceType": {
    ///      "$ref": "#/components/schemas/sequence-type"
    ///    },
    ///    "settlementAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "settlementId": {
    ///      "$ref": "#/components/schemas/settlementToken"
    ///    },
    ///    "shippingAddress": {
    ///      "$ref": "#/components/schemas/payment-address"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/payment-status"
    ///    },
    ///    "statusReason": {
    ///      "$ref": "#/components/schemas/status-reason"
    ///    },
    ///    "subscriptionId": {
    ///      "$ref": "#/components/schemas/subscriptionToken"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    },
    ///    "webhookUrl": {
    ///      "description": "The webhook URL where we will send payment status
    /// updates to.\n\nThe webhookUrl is optional, but without a webhook you
    /// will miss out on important status changes to your payment.\n\nThe
    /// webhookUrl must be reachable from Mollie's point of view, so you cannot
    /// use `localhost`. If you want to use\nwebhook during development on
    /// `localhost`, you must use a tool like ngrok to have the webhooks
    /// delivered to your\nlocal machine.",
    ///      "examples": [
    ///        "https://example.org/webhooks"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPayment {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<Amount>,
        #[serde(
            rename = "amountCaptured",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub amount_captured: ::std::option::Option<Amount>,
        #[serde(
            rename = "amountChargedBack",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub amount_charged_back: ::std::option::Option<Amount>,
        #[serde(
            rename = "amountRefunded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub amount_refunded: ::std::option::Option<Amount>,
        #[serde(
            rename = "amountRemaining",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub amount_remaining: ::std::option::Option<Amount>,
        ///With Mollie Connect you can charge fees on payments that your app is
        /// processing on behalf of other Mollie merchants.
        ///
        ///If you use OAuth to create payments on a connected merchant's
        /// account, you can charge a fee using this `applicationFee`
        /// parameter. If the payment succeeds, the fee will be deducted from
        /// the merchant's balance and sent to your own account balance.
        ///
        ///If instead you want to split a payment on your own account between
        /// yourself and a connected merchant, refer to the
        /// `routing` parameter.
        #[serde(
            rename = "applicationFee",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub application_fee: ::std::option::Option<EntityPaymentApplicationFee>,
        ///The date and time the payment became authorized, in ISO 8601 format.
        /// This parameter is omitted if the payment is not authorized
        /// (yet).
        #[serde(
            rename = "authorizedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub authorized_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "billingAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub billing_address: ::std::option::Option<PaymentAddress>,
        ///The URL your customer will be redirected to when the customer
        /// explicitly cancels the payment. If this URL is not provided,
        /// the customer will be redirected to the `redirectUrl` instead — see
        /// above.
        ///
        ///Mollie will always give you status updates via webhooks, including
        /// for the canceled status. This parameter is
        /// therefore entirely optional, but can be useful when implementing a
        /// dedicated customer-facing flow to handle
        /// payment cancellations.
        #[serde(
            rename = "cancelUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub cancel_url: ::std::option::Option<::std::string::String>,
        ///The date and time the payment was canceled, in ISO 8601 format. This
        /// parameter is omitted if the payment is not canceled (yet).
        #[serde(
            rename = "canceledAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub canceled_at: ::std::option::Option<::std::string::String>,
        ///Indicates the date before which the payment needs to be captured, in
        /// ISO 8601 format. From this date onwards we can no longer
        /// guarantee a successful capture. The parameter is omitted if the
        /// payment is not authorized (yet).
        #[serde(
            rename = "captureBefore",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub capture_before: ::std::option::Option<::std::string::String>,
        ///**Only relevant if you wish to manage authorization and capturing
        /// separately.**
        ///
        ///Some payment methods allow placing a hold on the card or bank
        /// account. This hold or 'authorization' can then at a
        /// later point either be 'captured' or canceled.
        ///
        ///By default, we charge the customer's card or bank account
        /// immediately when they complete the payment. If you set a
        /// capture delay however, we will delay the automatic capturing of the
        /// payment for the specified amount of time. For example `8
        /// hours` or `2 days`.
        ///
        ///To schedule an automatic capture, the `captureMode` must be set to
        /// `automatic`.
        ///
        ///The maximum delay is 7 days (168 hours).
        ///
        ///Possible values: `... hours` `... days`
        #[serde(
            rename = "captureDelay",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub capture_delay: ::std::option::Option<EntityPaymentCaptureDelay>,
        #[serde(
            rename = "captureMode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub capture_mode: ::std::option::Option<CaptureMode>,
        ///This optional field contains your customer's ISO 3166-1 alpha-2
        /// country code, detected by us during checkout. This
        /// field is omitted if the country code was not detected.
        #[serde(
            rename = "countryCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub country_code: ::std::option::Option<EntityPaymentCountryCode>,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        #[serde(
            rename = "customerId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub customer_id: ::std::option::Option<CustomerToken>,
        ///The description of the payment. This will be shown to your customer
        /// on their card or bank statement when possible. We truncate
        /// the description automatically according to the limits of the used
        /// payment method. The description is also visible in any
        /// exports you generate.
        ///
        ///We recommend you use a unique identifier so that you can always link
        /// the payment to the order in your back office.
        /// This is particularly useful for bookkeeping.
        ///
        ///The maximum length of the description field differs per payment
        /// method, with the absolute maximum being 255 characters. The
        /// API will not reject strings longer than the maximum length but it
        /// will truncate them to fit.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<EntityPaymentDescription>,
        ///An object containing payment details collected during the payment
        /// process. For example, details may include the customer's
        /// card or bank details and a payment reference. For the full list of
        /// details, please refer to the [method-specific
        /// parameters](extra-payment-parameters) guide.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub details: ::std::option::Option<EntityPaymentDetails>,
        ///The date by which the payment should be completed in `YYYY-MM-DD`
        /// format
        #[serde(
            rename = "dueDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub due_date: ::std::option::Option<::std::string::String>,
        ///The date and time the payment was expired, in ISO 8601 format. This
        /// parameter is omitted if the payment did not expire (yet).
        #[serde(
            rename = "expiredAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub expired_at: ::std::option::Option<::std::string::String>,
        ///The date and time the payment will expire, in ISO 8601 format. This
        /// parameter is omitted if the payment can no longer expire.
        #[serde(
            rename = "expiresAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub expires_at: ::std::option::Option<::std::string::String>,
        ///The date and time the payment failed, in ISO 8601 format. This
        /// parameter is omitted if the payment did not fail (yet).
        #[serde(
            rename = "failedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub failed_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<PaymentToken>,
        ///Whether the payment can be canceled. This parameter is omitted if
        /// the payment reaches a final state.
        #[serde(
            rename = "isCancelable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub is_cancelable: ::std::option::Option<bool>,
        ///**Only relevant for iDEAL, KBC/CBC, gift card, and voucher
        /// payments.**
        ///
        ///**⚠️ With the introduction of iDEAL 2 in 2025, this field will be
        /// ignored for iDEAL payments. For more information on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
        ///
        ///Some payment methods are a network of connected banks or card
        /// issuers. In these cases, after selecting the payment method,
        /// the customer may still need to select the appropriate issuer before
        /// the payment can proceed.
        ///
        ///We provide hosted issuer selection screens, but these screens can be
        /// skipped by providing the `issuer` via the API up front.
        ///
        ///The full list of issuers for a specific method can be retrieved via
        /// the Methods API by using the optional `issuers` include.
        ///
        ///A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING
        /// Bank).
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub issuer: ::std::option::Option<::std::string::String>,
        ///Optionally provide the order lines for the payment. Each line
        /// contains details such as a description of the item
        /// ordered and its price.
        ///
        ///All lines must have the same currency as the payment.
        ///
        ///Required for payment methods `billie`, `in3`, `klarna`, `riverty`
        /// and `voucher`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub lines: ::std::option::Option<::std::vec::Vec<EntityPaymentLinesItem>>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityPaymentLinks>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub locale: ::std::option::Option<Locale>,
        #[serde(
            rename = "mandateId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub mandate_id: ::std::option::Option<MandateToken>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<Metadata>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub method: ::std::option::Option<Method>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<Mode>,
        #[serde(
            rename = "orderId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub order_id: ::std::option::Option<OrderToken>,
        ///The date and time the payment became paid, in ISO 8601 format. This
        /// parameter is omitted if the payment is not completed (yet).
        #[serde(
            rename = "paidAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paid_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "profileId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub profile_id: ::std::option::Option<ProfileToken>,
        ///The URL your customer will be redirected to after the payment
        /// process.
        ///
        ///It could make sense for the redirectUrl to contain a unique
        /// identifier – like your order ID – so you can show the
        /// right page referencing the order when your customer returns.
        ///
        ///The parameter is normally required, but can be omitted for recurring
        /// payments (`sequenceType: recurring`) and for
        /// Apple Pay payments with an `applePayPaymentToken`.
        #[serde(
            rename = "redirectUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub redirect_url: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a payment object. Will always
        /// contain the string `payment` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        ///For digital goods in most jurisdictions, you must apply the VAT rate
        /// from your customer's country. Choose the VAT rates you have
        /// used for the order to ensure your customer's country matches the VAT
        /// country.
        ///
        ///Use this parameter to restrict the payment methods available to your
        /// customer to those from a single country.
        ///
        ///If available, the credit card method will still be offered, but only
        /// cards from the allowed country are accepted.
        ///
        ///The field expects a country code in ISO 3166-1 alpha-2 format, for
        /// example `NL`.
        #[serde(
            rename = "restrictPaymentMethodsToCountry",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub restrict_payment_methods_to_country: ::std::option::Option<::std::string::String>,
        ///*This functionality is not enabled by default. Reach out to our
        /// partner management team if you wish to use it.*
        ///
        ///With Mollie Connect you can charge fees on payments that your app is
        /// processing on behalf of other Mollie merchants.
        ///
        ///If you create payments on your own account that you want to split
        /// between yourself and one or more connected merchants, you
        /// can use this `routing` parameter to route the payment accordingly.
        ///
        ///The `routing` parameter should contain an array of objects, with
        /// each object describing the destination for a
        /// specific portion of the payment.
        ///
        ///It is not necessary to indicate in the array which portion goes to
        /// yourself. After all portions of the total payment amount
        /// have been routed, the amount left will be routed to the current
        /// organization automatically.
        ///
        ///If instead you use OAuth to create payments on a connected
        /// merchant's account, refer to the `applicationFee` parameter.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub routing: ::std::option::Option<::std::vec::Vec<EntityPaymentRoute>>,
        #[serde(
            rename = "sequenceType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub sequence_type: ::std::option::Option<SequenceType>,
        #[serde(
            rename = "settlementAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_amount: ::std::option::Option<Amount>,
        #[serde(
            rename = "settlementId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_id: ::std::option::Option<SettlementToken>,
        #[serde(
            rename = "shippingAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub shipping_address: ::std::option::Option<PaymentAddress>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<PaymentStatus>,
        #[serde(
            rename = "statusReason",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub status_reason: ::std::option::Option<StatusReason>,
        #[serde(
            rename = "subscriptionId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subscription_id: ::std::option::Option<SubscriptionToken>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
        ///The webhook URL where we will send payment status updates to.
        ///
        ///The webhookUrl is optional, but without a webhook you will miss out
        /// on important status changes to your payment.
        ///
        ///The webhookUrl must be reachable from Mollie's point of view, so you
        /// cannot use `localhost`. If you want to use webhook during
        /// development on `localhost`, you must use a tool like ngrok to have
        /// the webhooks delivered to your local machine.
        #[serde(
            rename = "webhookUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub webhook_url: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityPayment> for EntityPayment {
        fn from(value: &EntityPayment) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityPayment {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                amount_captured: Default::default(),
                amount_charged_back: Default::default(),
                amount_refunded: Default::default(),
                amount_remaining: Default::default(),
                application_fee: Default::default(),
                authorized_at: Default::default(),
                billing_address: Default::default(),
                cancel_url: Default::default(),
                canceled_at: Default::default(),
                capture_before: Default::default(),
                capture_delay: Default::default(),
                capture_mode: Default::default(),
                country_code: Default::default(),
                created_at: Default::default(),
                customer_id: Default::default(),
                description: Default::default(),
                details: Default::default(),
                due_date: Default::default(),
                expired_at: Default::default(),
                expires_at: Default::default(),
                failed_at: Default::default(),
                id: Default::default(),
                is_cancelable: Default::default(),
                issuer: Default::default(),
                lines: Default::default(),
                links: Default::default(),
                locale: Default::default(),
                mandate_id: Default::default(),
                metadata: Default::default(),
                method: Default::default(),
                mode: Default::default(),
                order_id: Default::default(),
                paid_at: Default::default(),
                profile_id: Default::default(),
                redirect_url: Default::default(),
                resource: Default::default(),
                restrict_payment_methods_to_country: Default::default(),
                routing: Default::default(),
                sequence_type: Default::default(),
                settlement_amount: Default::default(),
                settlement_id: Default::default(),
                shipping_address: Default::default(),
                status: Default::default(),
                status_reason: Default::default(),
                subscription_id: Default::default(),
                testmode: Default::default(),
                webhook_url: Default::default(),
            }
        }
    }

    ///With Mollie Connect you can charge fees on payments that your app is
    /// processing on behalf of other Mollie merchants.
    ///
    ///If you use OAuth to create payments on a connected merchant's account,
    /// you can charge a fee using this `applicationFee` parameter. If the
    /// payment succeeds, the fee will be deducted from the merchant's balance
    /// and sent to your own account balance.
    ///
    ///If instead you want to split a payment on your own account between
    /// yourself and a connected merchant, refer to the `routing` parameter.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "With Mollie Connect you can charge fees on payments
    /// that your app is processing on behalf of other Mollie\nmerchants.\n\nIf
    /// you use OAuth to create payments on a connected merchant's account, you
    /// can charge a fee using this\n`applicationFee` parameter. If the payment
    /// succeeds, the fee will be deducted from the merchant's balance and
    /// sent\nto your own account balance.\n\nIf instead you want to split a
    /// payment on your own account between yourself and a connected merchant,
    /// refer to the\n`routing` parameter.",
    ///  "type": "object",
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "description": {
    ///      "description": "The description of the application fee. This will
    /// appear on settlement reports towards both you and the\nconnected
    /// merchant.",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentApplicationFee {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<Amount>,
        ///The description of the application fee. This will appear on
        /// settlement reports towards both you and the
        /// connected merchant.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<EntityPaymentApplicationFeeDescription>,
    }

    impl ::std::convert::From<&EntityPaymentApplicationFee> for EntityPaymentApplicationFee {
        fn from(value: &EntityPaymentApplicationFee) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityPaymentApplicationFee {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                description: Default::default(),
            }
        }
    }

    ///The description of the application fee. This will appear on settlement
    /// reports towards both you and the connected merchant.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The description of the application fee. This will
    /// appear on settlement reports towards both you and the\nconnected
    /// merchant.",
    ///  "examples": [
    ///    10
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityPaymentApplicationFeeDescription(::std::string::String);
    impl ::std::ops::Deref for EntityPaymentApplicationFeeDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityPaymentApplicationFeeDescription> for ::std::string::String {
        fn from(value: EntityPaymentApplicationFeeDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityPaymentApplicationFeeDescription>
        for EntityPaymentApplicationFeeDescription
    {
        fn from(value: &EntityPaymentApplicationFeeDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityPaymentApplicationFeeDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityPaymentApplicationFeeDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityPaymentApplicationFeeDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityPaymentApplicationFeeDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityPaymentApplicationFeeDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///**Only relevant if you wish to manage authorization and capturing
    /// separately.**
    ///
    ///Some payment methods allow placing a hold on the card or bank account.
    /// This hold or 'authorization' can then at a later point either be
    /// 'captured' or canceled.
    ///
    ///By default, we charge the customer's card or bank account immediately
    /// when they complete the payment. If you set a capture delay however,
    /// we will delay the automatic capturing of the payment for the specified
    /// amount of time. For example `8 hours` or `2 days`.
    ///
    ///To schedule an automatic capture, the `captureMode` must be set to
    /// `automatic`.
    ///
    ///The maximum delay is 7 days (168 hours).
    ///
    ///Possible values: `... hours` `... days`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "**Only relevant if you wish to manage authorization and
    /// capturing separately.**\n\nSome payment methods allow placing a hold on
    /// the card or bank account. This hold or 'authorization' can then at
    /// a\nlater point either be 'captured' or canceled.\n\nBy default, we
    /// charge the customer's card or bank account immediately when they
    /// complete the payment. If you set a\ncapture delay however, we will delay
    /// the automatic capturing of the payment for the specified amount of time.
    /// For\nexample `8 hours` or `2 days`.\n\nTo schedule an automatic capture,
    /// the `captureMode` must be set to `automatic`.\n\nThe maximum delay is 7
    /// days (168 hours).\n\nPossible values: `... hours` `... days`",
    ///  "examples": [
    ///    "8 hours"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+ (hours|days)$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityPaymentCaptureDelay(::std::string::String);
    impl ::std::ops::Deref for EntityPaymentCaptureDelay {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityPaymentCaptureDelay> for ::std::string::String {
        fn from(value: EntityPaymentCaptureDelay) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityPaymentCaptureDelay> for EntityPaymentCaptureDelay {
        fn from(value: &EntityPaymentCaptureDelay) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityPaymentCaptureDelay {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^\\d+ (hours|days)$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+ (hours|days)$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityPaymentCaptureDelay {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityPaymentCaptureDelay {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityPaymentCaptureDelay {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityPaymentCaptureDelay {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///This optional field contains your customer's ISO 3166-1 alpha-2 country
    /// code, detected by us during checkout. This field is omitted if the
    /// country code was not detected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This optional field contains your customer's ISO 3166-1
    /// alpha-2 country code, detected by us during checkout. This\nfield is
    /// omitted if the country code was not detected.",
    ///  "readOnly": true,
    ///  "examples": [
    ///    "BE"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 2,
    ///  "minLength": 2
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityPaymentCountryCode(::std::string::String);
    impl ::std::ops::Deref for EntityPaymentCountryCode {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityPaymentCountryCode> for ::std::string::String {
        fn from(value: EntityPaymentCountryCode) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityPaymentCountryCode> for EntityPaymentCountryCode {
        fn from(value: &EntityPaymentCountryCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityPaymentCountryCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 2usize {
                return Err("longer than 2 characters".into());
            }
            if value.chars().count() < 2usize {
                return Err("shorter than 2 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityPaymentCountryCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityPaymentCountryCode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityPaymentCountryCode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityPaymentCountryCode {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The description of the payment. This will be shown to your customer on
    /// their card or bank statement when possible. We truncate the
    /// description automatically according to the limits of the used payment
    /// method. The description is also visible in any exports you generate.
    ///
    ///We recommend you use a unique identifier so that you can always link the
    /// payment to the order in your back office. This is particularly
    /// useful for bookkeeping.
    ///
    ///The maximum length of the description field differs per payment method,
    /// with the absolute maximum being 255 characters. The API will not
    /// reject strings longer than the maximum length but it will truncate them
    /// to fit.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The description of the payment. This will be shown to
    /// your customer on their card or bank statement when possible.\nWe
    /// truncate the description automatically according to the limits of the
    /// used payment method. The description is\nalso visible in any exports you
    /// generate.\n\nWe recommend you use a unique identifier so that you can
    /// always link the payment to the order in your back office.\nThis is
    /// particularly useful for bookkeeping.\n\nThe maximum length of the
    /// description field differs per payment method, with the absolute maximum
    /// being 255\ncharacters. The API will not reject strings longer than the
    /// maximum length but it will truncate them to fit.",
    ///  "examples": [
    ///    "Chess Board"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityPaymentDescription(::std::string::String);
    impl ::std::ops::Deref for EntityPaymentDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityPaymentDescription> for ::std::string::String {
        fn from(value: EntityPaymentDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityPaymentDescription> for EntityPaymentDescription {
        fn from(value: &EntityPaymentDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityPaymentDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityPaymentDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityPaymentDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityPaymentDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityPaymentDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///An object containing payment details collected during the payment
    /// process. For example, details may include the customer's card or
    /// bank details and a payment reference. For the full list of details,
    /// please refer to the [method-specific
    /// parameters](extra-payment-parameters) guide.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object containing payment details collected during
    /// the payment process. For example, details may include the\ncustomer's
    /// card or bank details and a payment reference. For the full list of
    /// details, please refer to the\n[method-specific
    /// parameters](extra-payment-parameters) guide.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "bankAccount": {
    ///      "description": "The bank account number the customer will need to
    /// make the bank transfer payment towards.",
    ///      "examples": [
    ///        "NL91ABNA0417164300"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "bankBic": {
    ///      "description": "The BIC of the bank the customer will need to make
    /// the bank transfer payment towards.",
    ///      "examples": [
    ///        "ABNANL2A"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "bankName": {
    ///      "description": "The name of the bank that the customer will need to
    /// make the bank transfer payment towards.",
    ///      "examples": [
    ///        "Mollie Bank"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "bankReason": {
    ///      "description": "A human-friendly description of the failure
    /// reason.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "bankReasonCode": {
    ///      "description": "The official reason why this payment has failed. A
    /// detailed description of each reason is available on the\nwebsite of the
    /// European Payments Council.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "batchReference": {
    ///      "description": "The batch reference you provided in the batch
    /// file.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "card3dsEci": {
    ///      "description": "The outcome of authentication attempted on
    /// transactions enforced by 3DS (ie valid only for oneoff and first).",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardAudition": {
    ///      "$ref": "#/components/schemas/payment-details-card-audition"
    ///    },
    ///    "cardBin": {
    ///      "description": "The first 6 digit of the card bank identification
    /// number.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardCountryCode": {
    ///      "description": "The ISO 3166-1 alpha-2 country code of the country
    /// the card was issued in.",
    ///      "examples": [
    ///        "NL"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardExpiryDate": {
    ///      "description": "The expiry date (MM/YY) of the card as displayed on
    /// the card.",
    ///      "examples": [
    ///        "12/25"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardFingerprint": {
    ///      "description": "A unique fingerprint for a specific card. Can be
    /// used to identify returning customers.\n\nIn the case of Point-of-sale
    /// payments, it's a unique identifier assigned to a cardholder's payment
    /// account,\nlinking multiple transactions from wallets and physical card
    /// to a single account, also across payment methods\nor when the card is
    /// reissued.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardFunding": {
    ///      "$ref": "#/components/schemas/payment-details-card-funding"
    ///    },
    ///    "cardHolder": {
    ///      "description": "The customer's name as shown on their card.",
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardIssuer": {
    ///      "description": "The issuer of the Card.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardLabel": {
    ///      "$ref": "#/components/schemas/payment-details-card-label"
    ///    },
    ///    "cardMaskedNumber": {
    ///      "description": "The first 6 and last 4 digits of the card number.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardNumber": {
    ///      "description": "For bancontact, it will be the customer's masked
    /// card number. For cards, it will be the last 4-digit of the\nPAN. For
    /// Point-of-sale, it will be the the last 4 digits of the customer's masked
    /// card number.",
    ///      "examples": [
    ///        "************1234"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardSecurity": {
    ///      "$ref": "#/components/schemas/payment-details-card-security"
    ///    },
    ///    "consumerAccount": {
    ///      "description": "The customer's account reference.\n\nFor
    /// banking-based payment methods — such as iDEAL — this is normally either
    /// an IBAN or a domestic bank account\nnumber.\n\nFor PayPal, the account
    /// reference is an email address.\n\nFor card and Bancontact payments,
    /// refer to details.cardNumber.",
    ///      "examples": [
    ///        "NL91ABNA0417164300"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "consumerBic": {
    ///      "description": "The BIC of the customer's bank account, if
    /// applicable.",
    ///      "examples": [
    ///        "ABNANL2A"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "consumerName": {
    ///      "description": "The customer's name, if made available by the
    /// payment method. For card payments, refer to details.cardHolder.",
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "creditorIdentifier": {
    ///      "description": "The creditor identifier indicates who is authorized to execute the payment. In this case, it is a\nreference to Mollie.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "customerReference": {
    ///      "description": "The paysafecard customer reference either provided
    /// via the API or otherwise auto-generated by Mollie.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "dueDate": {
    ///      "description": "Estimated date the payment is debited from the
    /// customer's bank account, in YYYY-MM-DD format.",
    ///      "examples": [
    ///        "2025-01-01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "date",
    ///      "x-methodSpecific": true
    ///    },
    ///    "endToEndIdentifier": {
    ///      "description": "The end-to-end identifier you provided in the batch
    /// file.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "failureMessage": {
    ///      "description": "A human-friendly failure message that can be shown
    /// to the customer. The message is translated in accordance\nwith the
    /// payment's locale setting.",
    ///      "examples": [
    ///        "Your card was declined."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "failureReason": {
    ///      "$ref": "#/components/schemas/payment-details-failure-reason"
    ///    },
    ///    "feeRegion": {
    ///      "$ref": "#/components/schemas/payment-details-fee-region"
    ///    },
    ///    "fileReference": {
    ///      "description": "The file reference you provided in the batch
    /// file.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "giftcards": {
    ///      "description": "An array of detail objects for each gift card that
    /// was used on this payment, if any.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "additionalProperties": true
    ///      },
    ///      "x-methodSpecific": true
    ///    },
    ///    "issuer": {
    ///      "description": "For payments with vouchers: the brand name of the
    /// first voucher applied.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "mandateReference": {
    ///      "description": "The mandate reference you provided in the batch
    /// file.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "maskedNumber": {
    ///      "description": "The first 6 digits & last 4 digits of the
    /// customer's masked card number.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "paypalFee": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "paypalPayerId": {
    ///      "description": "ID of the customer's PayPal account.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "paypalReference": {
    ///      "description": "PayPal's reference for the payment.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "qrCode": {
    ///      "description": "Optional include. If a QR code was requested during
    /// payment creation for a QR-compatible payment method,\nthe QR code
    /// details will be available in this object.\n\nThe QR code can be scanned
    /// by the customer to complete the payment on their mobile device. For
    /// example,\nBancontact QR payments can be completed by the customer using
    /// the Bancontact app.",
    ///      "type": "object",
    ///      "properties": {
    ///        "height": {
    ///          "description": "The height of the QR code image in pixels.",
    ///          "examples": [
    ///            300
    ///          ],
    ///          "type": "integer"
    ///        },
    ///        "src": {
    ///          "description": "The URL to the QR code image. The image is a PNG file, and can be displayed directly in the browser or\ndownloaded.",
    ///          "examples": [
    ///            "https://www.mollie.com/images/qr-code.png"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "width": {
    ///          "description": "The width of the QR code image in pixels.",
    ///          "examples": [
    ///            300
    ///          ],
    ///          "type": "integer"
    ///        }
    ///      },
    ///      "x-methodSpecific": true
    ///    },
    ///    "receipt": {
    ///      "description": "The Point of sale receipt object.",
    ///      "type": "object",
    ///      "properties": {
    ///        "applicationIdentifier": {
    ///          "description": "The unique number that identifies a specific
    /// payment application on a chip card.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "authorizationCode": {
    ///          "description": "A unique code provided by the cardholder’s bank
    /// to confirm that the transaction was successfully approved.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "cardReadMethod": {
    ///          "$ref":
    /// "#/components/schemas/payment-details-receipt-card-read-method"
    ///        },
    ///        "cardVerificationMethod": {
    ///          "$ref":
    /// "#/components/schemas/payment-details-receipt-card-verification-method"
    ///        }
    ///      },
    ///      "x-methodSpecific": true
    ///    },
    ///    "remainderAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "remainderDetails": {
    ///      "description": "Optional include. The full payment method details
    /// of the remainder payment.",
    ///      "type": "object",
    ///      "additionalProperties": true,
    ///      "x-methodSpecific": true
    ///    },
    ///    "remainderMethod": {
    ///      "description": "The payment method used to pay the remainder
    /// amount, after all gift cards or vouchers were applied.",
    ///      "examples": [
    ///        "creditcard"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "sellerProtection": {
    ///      "$ref": "#/components/schemas/payment-details-seller-protection"
    ///    },
    ///    "shippingAddress": {
    ///      "description": "For wallet payment methods — such as Apple Pay and
    /// PayPal — the shipping address is often already known by the\nwallet
    /// provider. In these cases the shipping address may be available as a
    /// payment detail.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "additionalProperties": true,
    ///      "x-methodSpecific": true
    ///    },
    ///    "signatureDate": {
    ///      "description": "Date the payment has been signed by the customer, in YYYY-MM-DD format. Only available if the payment\nhas been signed.",
    ///      "examples": [
    ///        "2024-03-20"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "date",
    ///      "x-methodSpecific": true
    ///    },
    ///    "terminalId": {
    ///      "description": "The ID of the terminal device where the payment
    /// took place on.",
    ///      "examples": [
    ///        "term_12345"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "transferReference": {
    ///      "description": "The Mollie-generated reference the customer needs
    /// to use when transfering the amount. Do not apply any\nformatting here;
    /// show it to the customer as-is.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "voucherNumber": {
    ///      "description": "For payments with gift cards: the masked gift card
    /// number of the first gift card applied to the payment.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "vouchers": {
    ///      "description": "An array of detail objects for each voucher that
    /// was used on this payment, if any.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "additionalProperties": true
    ///      },
    ///      "x-methodSpecific": true
    ///    },
    ///    "wallet": {
    ///      "$ref": "#/components/schemas/payment-details-wallet"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentDetails {
        ///The bank account number the customer will need to make the bank
        /// transfer payment towards.
        #[serde(
            rename = "bankAccount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub bank_account: ::std::option::Option<::std::string::String>,
        ///The BIC of the bank the customer will need to make the bank transfer
        /// payment towards.
        #[serde(
            rename = "bankBic",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub bank_bic: ::std::option::Option<::std::string::String>,
        ///The name of the bank that the customer will need to make the bank
        /// transfer payment towards.
        #[serde(
            rename = "bankName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub bank_name: ::std::option::Option<::std::string::String>,
        ///A human-friendly description of the failure reason.
        #[serde(
            rename = "bankReason",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub bank_reason: ::std::option::Option<::std::string::String>,
        ///The official reason why this payment has failed. A detailed
        /// description of each reason is available on the website of
        /// the European Payments Council.
        #[serde(
            rename = "bankReasonCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub bank_reason_code: ::std::option::Option<::std::string::String>,
        ///The batch reference you provided in the batch file.
        #[serde(
            rename = "batchReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub batch_reference: ::std::option::Option<::std::string::String>,
        ///The outcome of authentication attempted on transactions enforced by
        /// 3DS (ie valid only for oneoff and first).
        #[serde(
            rename = "card3dsEci",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card3ds_eci: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cardAudition",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_audition: ::std::option::Option<PaymentDetailsCardAudition>,
        ///The first 6 digit of the card bank identification number.
        #[serde(
            rename = "cardBin",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_bin: ::std::option::Option<::std::string::String>,
        ///The ISO 3166-1 alpha-2 country code of the country the card was
        /// issued in.
        #[serde(
            rename = "cardCountryCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_country_code: ::std::option::Option<::std::string::String>,
        ///The expiry date (MM/YY) of the card as displayed on the card.
        #[serde(
            rename = "cardExpiryDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_expiry_date: ::std::option::Option<::std::string::String>,
        ///A unique fingerprint for a specific card. Can be used to identify
        /// returning customers.
        ///
        ///In the case of Point-of-sale payments, it's a unique identifier
        /// assigned to a cardholder's payment account, linking multiple
        /// transactions from wallets and physical card to a single account,
        /// also across payment methods or when the card is reissued.
        #[serde(
            rename = "cardFingerprint",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_fingerprint: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cardFunding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_funding: ::std::option::Option<PaymentDetailsCardFunding>,
        ///The customer's name as shown on their card.
        #[serde(
            rename = "cardHolder",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_holder: ::std::option::Option<::std::string::String>,
        ///The issuer of the Card.
        #[serde(
            rename = "cardIssuer",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_issuer: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cardLabel",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_label: ::std::option::Option<PaymentDetailsCardLabel>,
        ///The first 6 and last 4 digits of the card number.
        #[serde(
            rename = "cardMaskedNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_masked_number: ::std::option::Option<::std::string::String>,
        ///For bancontact, it will be the customer's masked card number. For
        /// cards, it will be the last 4-digit of the
        /// PAN. For Point-of-sale, it will be the the last 4 digits of the
        /// customer's masked card number.
        #[serde(
            rename = "cardNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_number: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cardSecurity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_security: ::std::option::Option<PaymentDetailsCardSecurity>,
        ///The customer's account reference.
        ///
        ///For banking-based payment methods — such as iDEAL — this is normally
        /// either an IBAN or a domestic bank account number.
        ///
        ///For PayPal, the account reference is an email address.
        ///
        ///For card and Bancontact payments, refer to details.cardNumber.
        #[serde(
            rename = "consumerAccount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_account: ::std::option::Option<::std::string::String>,
        ///The BIC of the customer's bank account, if applicable.
        #[serde(
            rename = "consumerBic",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_bic: ::std::option::Option<::std::string::String>,
        ///The customer's name, if made available by the payment method. For
        /// card payments, refer to details.cardHolder.
        #[serde(
            rename = "consumerName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_name: ::std::option::Option<::std::string::String>,
        ///The creditor identifier indicates who is authorized to execute the
        /// payment. In this case, it is a reference to Mollie.
        #[serde(
            rename = "creditorIdentifier",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub creditor_identifier: ::std::option::Option<::std::string::String>,
        ///The paysafecard customer reference either provided via the API or
        /// otherwise auto-generated by Mollie.
        #[serde(
            rename = "customerReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub customer_reference: ::std::option::Option<::std::string::String>,
        ///Estimated date the payment is debited from the customer's bank
        /// account, in YYYY-MM-DD format.
        #[serde(
            rename = "dueDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub due_date: ::std::option::Option<::chrono::naive::NaiveDate>,
        ///The end-to-end identifier you provided in the batch file.
        #[serde(
            rename = "endToEndIdentifier",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub end_to_end_identifier: ::std::option::Option<::std::string::String>,
        ///A human-friendly failure message that can be shown to the customer.
        /// The message is translated in accordance with the payment's
        /// locale setting.
        #[serde(
            rename = "failureMessage",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub failure_message: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "failureReason",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub failure_reason: ::std::option::Option<PaymentDetailsFailureReason>,
        #[serde(
            rename = "feeRegion",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub fee_region: ::std::option::Option<PaymentDetailsFeeRegion>,
        ///The file reference you provided in the batch file.
        #[serde(
            rename = "fileReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub file_reference: ::std::option::Option<::std::string::String>,
        ///An array of detail objects for each gift card that was used on this
        /// payment, if any.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub giftcards:
            ::std::vec::Vec<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        ///For payments with vouchers: the brand name of the first voucher
        /// applied.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub issuer: ::std::option::Option<::std::string::String>,
        ///The mandate reference you provided in the batch file.
        #[serde(
            rename = "mandateReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub mandate_reference: ::std::option::Option<::std::string::String>,
        ///The first 6 digits & last 4 digits of the customer's masked card
        /// number.
        #[serde(
            rename = "maskedNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub masked_number: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paypalFee",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paypal_fee: ::std::option::Option<AmountNullable>,
        ///ID of the customer's PayPal account.
        #[serde(
            rename = "paypalPayerId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paypal_payer_id: ::std::option::Option<::std::string::String>,
        ///PayPal's reference for the payment.
        #[serde(
            rename = "paypalReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paypal_reference: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "qrCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub qr_code: ::std::option::Option<EntityPaymentDetailsQrCode>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub receipt: ::std::option::Option<EntityPaymentDetailsReceipt>,
        #[serde(
            rename = "remainderAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub remainder_amount: ::std::option::Option<Amount>,
        ///Optional include. The full payment method details of the remainder
        /// payment.
        #[serde(
            rename = "remainderDetails",
            default,
            skip_serializing_if = "::serde_json::Map::is_empty"
        )]
        pub remainder_details: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        ///The payment method used to pay the remainder amount, after all gift
        /// cards or vouchers were applied.
        #[serde(
            rename = "remainderMethod",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub remainder_method: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "sellerProtection",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub seller_protection: ::std::option::Option<PaymentDetailsSellerProtection>,
        ///For wallet payment methods — such as Apple Pay and PayPal — the
        /// shipping address is often already known by the
        /// wallet provider. In these cases the shipping address may be
        /// available as a payment detail.
        #[serde(
            rename = "shippingAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub shipping_address:
            ::std::option::Option<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        ///Date the payment has been signed by the customer, in YYYY-MM-DD
        /// format. Only available if the payment has been signed.
        #[serde(
            rename = "signatureDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub signature_date: ::std::option::Option<::chrono::naive::NaiveDate>,
        ///The ID of the terminal device where the payment took place on.
        #[serde(
            rename = "terminalId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub terminal_id: ::std::option::Option<::std::string::String>,
        ///The Mollie-generated reference the customer needs to use when
        /// transfering the amount. Do not apply any formatting here;
        /// show it to the customer as-is.
        #[serde(
            rename = "transferReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub transfer_reference: ::std::option::Option<::std::string::String>,
        ///For payments with gift cards: the masked gift card number of the
        /// first gift card applied to the payment.
        #[serde(
            rename = "voucherNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub voucher_number: ::std::option::Option<::std::string::String>,
        ///An array of detail objects for each voucher that was used on this
        /// payment, if any.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub vouchers:
            ::std::vec::Vec<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub wallet: ::std::option::Option<PaymentDetailsWallet>,
    }

    impl ::std::convert::From<&EntityPaymentDetails> for EntityPaymentDetails {
        fn from(value: &EntityPaymentDetails) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityPaymentDetails {
        fn default() -> Self {
            Self {
                bank_account: Default::default(),
                bank_bic: Default::default(),
                bank_name: Default::default(),
                bank_reason: Default::default(),
                bank_reason_code: Default::default(),
                batch_reference: Default::default(),
                card3ds_eci: Default::default(),
                card_audition: Default::default(),
                card_bin: Default::default(),
                card_country_code: Default::default(),
                card_expiry_date: Default::default(),
                card_fingerprint: Default::default(),
                card_funding: Default::default(),
                card_holder: Default::default(),
                card_issuer: Default::default(),
                card_label: Default::default(),
                card_masked_number: Default::default(),
                card_number: Default::default(),
                card_security: Default::default(),
                consumer_account: Default::default(),
                consumer_bic: Default::default(),
                consumer_name: Default::default(),
                creditor_identifier: Default::default(),
                customer_reference: Default::default(),
                due_date: Default::default(),
                end_to_end_identifier: Default::default(),
                failure_message: Default::default(),
                failure_reason: Default::default(),
                fee_region: Default::default(),
                file_reference: Default::default(),
                giftcards: Default::default(),
                issuer: Default::default(),
                mandate_reference: Default::default(),
                masked_number: Default::default(),
                paypal_fee: Default::default(),
                paypal_payer_id: Default::default(),
                paypal_reference: Default::default(),
                qr_code: Default::default(),
                receipt: Default::default(),
                remainder_amount: Default::default(),
                remainder_details: Default::default(),
                remainder_method: Default::default(),
                seller_protection: Default::default(),
                shipping_address: Default::default(),
                signature_date: Default::default(),
                terminal_id: Default::default(),
                transfer_reference: Default::default(),
                voucher_number: Default::default(),
                vouchers: Default::default(),
                wallet: Default::default(),
            }
        }
    }

    ///Optional include. If a QR code was requested during payment creation for
    /// a QR-compatible payment method, the QR code details will be
    /// available in this object.
    ///
    ///The QR code can be scanned by the customer to complete the payment on
    /// their mobile device. For example, Bancontact QR payments can be
    /// completed by the customer using the Bancontact app.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Optional include. If a QR code was requested during
    /// payment creation for a QR-compatible payment method,\nthe QR code
    /// details will be available in this object.\n\nThe QR code can be scanned
    /// by the customer to complete the payment on their mobile device. For
    /// example,\nBancontact QR payments can be completed by the customer using
    /// the Bancontact app.",
    ///  "type": "object",
    ///  "properties": {
    ///    "height": {
    ///      "description": "The height of the QR code image in pixels.",
    ///      "examples": [
    ///        300
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "src": {
    ///      "description": "The URL to the QR code image. The image is a PNG
    /// file, and can be displayed directly in the browser or\ndownloaded.",
    ///      "examples": [
    ///        "https://www.mollie.com/images/qr-code.png"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "width": {
    ///      "description": "The width of the QR code image in pixels.",
    ///      "examples": [
    ///        300
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  },
    ///  "x-methodSpecific": true
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentDetailsQrCode {
        ///The height of the QR code image in pixels.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub height: ::std::option::Option<i64>,
        ///The URL to the QR code image. The image is a PNG file, and can be
        /// displayed directly in the browser or downloaded.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub src: ::std::option::Option<::std::string::String>,
        ///The width of the QR code image in pixels.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub width: ::std::option::Option<i64>,
    }

    impl ::std::convert::From<&EntityPaymentDetailsQrCode> for EntityPaymentDetailsQrCode {
        fn from(value: &EntityPaymentDetailsQrCode) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityPaymentDetailsQrCode {
        fn default() -> Self {
            Self {
                height: Default::default(),
                src: Default::default(),
                width: Default::default(),
            }
        }
    }

    ///The Point of sale receipt object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The Point of sale receipt object.",
    ///  "type": "object",
    ///  "properties": {
    ///    "applicationIdentifier": {
    ///      "description": "The unique number that identifies a specific
    /// payment application on a chip card.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "authorizationCode": {
    ///      "description": "A unique code provided by the cardholder’s bank to
    /// confirm that the transaction was successfully approved.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "cardReadMethod": {
    ///      "$ref":
    /// "#/components/schemas/payment-details-receipt-card-read-method"
    ///    },
    ///    "cardVerificationMethod": {
    ///      "$ref":
    /// "#/components/schemas/payment-details-receipt-card-verification-method"
    ///    }
    ///  },
    ///  "x-methodSpecific": true
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentDetailsReceipt {
        ///The unique number that identifies a specific payment application on
        /// a chip card.
        #[serde(
            rename = "applicationIdentifier",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub application_identifier: ::std::option::Option<::std::string::String>,
        ///A unique code provided by the cardholder’s bank to confirm that the
        /// transaction was successfully approved.
        #[serde(
            rename = "authorizationCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub authorization_code: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cardReadMethod",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_read_method: ::std::option::Option<PaymentDetailsReceiptCardReadMethod>,
        #[serde(
            rename = "cardVerificationMethod",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_verification_method:
            ::std::option::Option<PaymentDetailsReceiptCardVerificationMethod>,
    }

    impl ::std::convert::From<&EntityPaymentDetailsReceipt> for EntityPaymentDetailsReceipt {
        fn from(value: &EntityPaymentDetailsReceipt) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityPaymentDetailsReceipt {
        fn default() -> Self {
            Self {
                application_identifier: Default::default(),
                authorization_code: Default::default(),
                card_read_method: Default::default(),
                card_verification_method: Default::default(),
            }
        }
    }

    ///`EntityPaymentLinesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/payment-line-item"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "recurring": {
    ///          "$ref": "#/components/schemas/recurring-line-item"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentLinesItem {
        ///An array with the voucher categories, in case of a line eligible for
        /// a voucher. See the [Integrating Vouchers](https://docs.mollie.com/docs/integrating-vouchers/) guide for more information.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub categories: ::std::vec::Vec<LineCategories>,
        ///A description of the line item. For example *LEGO 4440 Forest Police
        /// Station*.
        pub description: ::std::string::String,
        #[serde(
            rename = "discountAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub discount_amount: ::std::option::Option<Amount>,
        ///A link pointing to an image of the product sold.
        #[serde(
            rename = "imageUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub image_url: ::std::option::Option<::std::string::String>,
        ///A link pointing to the product page in your web shop of the product
        /// sold.
        #[serde(
            rename = "productUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub product_url: ::std::option::Option<::std::string::String>,
        ///The number of items.
        pub quantity: ::std::num::NonZeroU64,
        ///The unit for the quantity. For example *pcs*, *kg*, or *cm*.
        #[serde(
            rename = "quantityUnit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub quantity_unit: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub recurring: ::std::option::Option<RecurringLineItem>,
        ///The SKU, EAN, ISBN or UPC of the product sold.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sku: ::std::option::Option<EntityPaymentLinesItemSku>,
        #[serde(rename = "totalAmount")]
        pub total_amount: Amount,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<PaymentLineType>,
        #[serde(rename = "unitPrice")]
        pub unit_price: Amount,
        #[serde(
            rename = "vatAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_amount: ::std::option::Option<Amount>,
        ///The VAT rate applied to the line, for example `21.00` for 21%. The
        /// vatRate should be passed as a string and not as a float, to
        /// ensure the correct number of decimals are passed.
        #[serde(
            rename = "vatRate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_rate: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityPaymentLinesItem> for EntityPaymentLinesItem {
        fn from(value: &EntityPaymentLinesItem) -> Self {
            value.clone()
        }
    }

    ///The SKU, EAN, ISBN or UPC of the product sold.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The SKU, EAN, ISBN or UPC of the product sold.",
    ///  "examples": [
    ///    "9780241661628"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 64
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityPaymentLinesItemSku(::std::string::String);
    impl ::std::ops::Deref for EntityPaymentLinesItemSku {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityPaymentLinesItemSku> for ::std::string::String {
        fn from(value: EntityPaymentLinesItemSku) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityPaymentLinesItemSku> for EntityPaymentLinesItemSku {
        fn from(value: &EntityPaymentLinesItemSku) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityPaymentLinesItemSku {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 64usize {
                return Err("longer than 64 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityPaymentLinesItemSku {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityPaymentLinesItemSku {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityPaymentLinesItemSku {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityPaymentLinesItemSku {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`EntityPaymentLink`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "paymentLink",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "paymentLink": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "allowedMethods": {
    ///      "$ref": "#/components/schemas/payment-link-methods"
    ///    },
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "applicationFee": {
    ///      "description": "With Mollie Connect you can charge fees on payment
    /// links that your app is processing on behalf of other
    /// Mollie\nmerchants.\n\nIf you use OAuth to create payment links on a
    /// connected merchant's account, you can charge a fee using
    /// this\n`applicationFee` parameter. If a payment on the payment link
    /// succeeds, the fee will be deducted from the merchant's balance and
    /// sent\nto your own account balance.",
    ///      "type": "object",
    ///      "required": [
    ///        "amount",
    ///        "description"
    ///      ],
    ///      "properties": {
    ///        "amount": {
    ///          "$ref": "#/components/schemas/amount"
    ///        },
    ///        "description": {
    ///          "description": "The description of the application fee. This
    /// will appear on settlement reports towards both you and the\nconnected
    /// merchant.",
    ///          "examples": [
    ///            "Platform fee"
    ///          ],
    ///          "type": "string",
    ///          "maxLength": 255
    ///        }
    ///      }
    ///    },
    ///    "archived": {
    ///      "description": "Whether the payment link is archived. Customers
    /// will not be able to complete payments on archived payment links.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "billingAddress": {
    ///      "$ref": "#/components/schemas/payment-address"
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "customerId": {
    ///      "description": "**Only relevant when `sequenceType` is set to
    /// `first`**\n\nThe ID of the [customer](get-customer) the payment link is
    /// being created for. If a value is not provided,\nthe customer will be
    /// required to input relevant information which will be used to establish a
    /// mandate after\nthe payment is made.",
    ///      "examples": [
    ///        "cst_XimFHuaEzd"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "description": {
    ///      "description": "A short description of the payment link. The
    /// description is visible in the Dashboard and will be shown on
    /// the\ncustomer's bank or card statement when possible.",
    ///      "examples": [
    ///        "Chess Board"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "expiresAt": {
    ///      "description": "The date and time the payment link is set to
    /// expire, in ISO 8601 format. If no expiry date was provided up
    /// front,\nthe payment link will not expire automatically.",
    ///      "examples": [
    ///        "2025-12-24T11:00:16+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/paymentLinkToken"
    ///    },
    ///    "lines": {
    ///      "description": "Optionally provide the order lines for the payment.
    /// Each line contains details such as a description of the item\nordered
    /// and its price.\n\nAll lines must have the same currency as the
    /// payment.\n\nRequired for payment methods `billie`, `in3`, `klarna`,
    /// `riverty` and `voucher`.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/payment-line-item-response"
    ///      }
    ///    },
    ///    "minimumAmount": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "paidAt": {
    ///      "description": "The date and time the payment link became paid, in
    /// ISO 8601 format.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2025-12-24T11:00:16+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "profileId": {
    ///      "description": "The identifier referring to the
    /// [profile](get-profile) this entity belongs to.\n\nMost API credentials
    /// are linked to a single profile. In these cases the `profileId` can be
    /// omitted in the creation\nrequest. For organization-level credentials
    /// such as OAuth access tokens however, the `profileId` parameter
    /// is\nrequired.",
    ///      "examples": [
    ///        "pfl_QkEhN94Ba"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "redirectUrl": {
    ///      "description": "The URL your customer will be redirected to after completing the payment process. If no redirect URL is provided,\nthe customer will be shown a generic message after completing the payment.",
    ///      "examples": [
    ///        "https://webshop.example.org/payment-links/redirect/"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a payment link
    /// object. Will always contain the string `payment-link` for
    /// this\nendpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "payment-link"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "reusable": {
    ///      "description": "Indicates whether the payment link is reusable. If
    /// this field is set to `true`, customers can make multiple\npayments using
    /// the same link.\n\nIf no value is specified, the field defaults to
    /// `false`, allowing only a single payment per link.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "sequenceType": {
    ///      "$ref": "#/components/schemas/payment-link-sequence-type-response"
    ///    },
    ///    "shippingAddress": {
    ///      "$ref": "#/components/schemas/payment-address"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    },
    ///    "webhookUrl": {
    ///      "description": "The webhook URL where we will send payment status
    /// updates to.\n\nThe webhookUrl is optional, but without a webhook you
    /// will miss out on important status changes to any payments\nresulting
    /// from the payment link.\n\nThe webhookUrl must be reachable from Mollie's
    /// point of view, so you cannot use `localhost`. If you want to
    /// use\nwebhook during development on `localhost`, you must use a tool like
    /// ngrok to have the webhooks delivered to your\nlocal machine.",
    ///      "examples": [
    ///        "https://webshop.example.org/payment-links/webhook/"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentLink {
        #[serde(
            rename = "allowedMethods",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub allowed_methods: ::std::option::Option<PaymentLinkMethods>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<AmountNullable>,
        #[serde(
            rename = "applicationFee",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub application_fee: ::std::option::Option<EntityPaymentLinkApplicationFee>,
        ///Whether the payment link is archived. Customers will not be able to
        /// complete payments on archived payment links.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub archived: ::std::option::Option<bool>,
        #[serde(
            rename = "billingAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub billing_address: ::std::option::Option<PaymentAddress>,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        ///**Only relevant when `sequenceType` is set to `first`**
        ///
        ///The ID of the [customer](get-customer) the payment link is being
        /// created for. If a value is not provided, the customer will
        /// be required to input relevant information which will be used to
        /// establish a mandate after the payment is made.
        #[serde(
            rename = "customerId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub customer_id: ::std::option::Option<::std::string::String>,
        ///A short description of the payment link. The description is visible
        /// in the Dashboard and will be shown on the customer's bank or
        /// card statement when possible.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<EntityPaymentLinkDescription>,
        ///The date and time the payment link is set to expire, in ISO 8601
        /// format. If no expiry date was provided up front, the payment
        /// link will not expire automatically.
        #[serde(
            rename = "expiresAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub expires_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<PaymentLinkToken>,
        ///Optionally provide the order lines for the payment. Each line
        /// contains details such as a description of the item
        /// ordered and its price.
        ///
        ///All lines must have the same currency as the payment.
        ///
        ///Required for payment methods `billie`, `in3`, `klarna`, `riverty`
        /// and `voucher`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub lines: ::std::option::Option<::std::vec::Vec<PaymentLineItemResponse>>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityPaymentLinkLinks>,
        #[serde(
            rename = "minimumAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub minimum_amount: ::std::option::Option<AmountNullable>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<Mode>,
        ///The date and time the payment link became paid, in ISO 8601 format.
        #[serde(
            rename = "paidAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paid_at: ::std::option::Option<::std::string::String>,
        ///The identifier referring to the [profile](get-profile) this entity
        /// belongs to.
        ///
        ///Most API credentials are linked to a single profile. In these cases
        /// the `profileId` can be omitted in the creation request. For
        /// organization-level credentials such as OAuth access tokens however,
        /// the `profileId` parameter is required.
        #[serde(
            rename = "profileId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub profile_id: ::std::option::Option<::std::string::String>,
        ///The URL your customer will be redirected to after completing the
        /// payment process. If no redirect URL is provided,
        /// the customer will be shown a generic message after completing the
        /// payment.
        #[serde(
            rename = "redirectUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub redirect_url: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a payment link object. Will always
        /// contain the string `payment-link` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        ///Indicates whether the payment link is reusable. If this field is set
        /// to `true`, customers can make multiple payments using the
        /// same link.
        ///
        ///If no value is specified, the field defaults to `false`, allowing
        /// only a single payment per link.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub reusable: ::std::option::Option<bool>,
        #[serde(
            rename = "sequenceType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub sequence_type: ::std::option::Option<PaymentLinkSequenceTypeResponse>,
        #[serde(
            rename = "shippingAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub shipping_address: ::std::option::Option<PaymentAddress>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
        ///The webhook URL where we will send payment status updates to.
        ///
        ///The webhookUrl is optional, but without a webhook you will miss out
        /// on important status changes to any payments resulting from
        /// the payment link.
        ///
        ///The webhookUrl must be reachable from Mollie's point of view, so you
        /// cannot use `localhost`. If you want to use webhook during
        /// development on `localhost`, you must use a tool like ngrok to have
        /// the webhooks delivered to your local machine.
        #[serde(
            rename = "webhookUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub webhook_url: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityPaymentLink> for EntityPaymentLink {
        fn from(value: &EntityPaymentLink) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityPaymentLink {
        fn default() -> Self {
            Self {
                allowed_methods: Default::default(),
                amount: Default::default(),
                application_fee: Default::default(),
                archived: Default::default(),
                billing_address: Default::default(),
                created_at: Default::default(),
                customer_id: Default::default(),
                description: Default::default(),
                expires_at: Default::default(),
                id: Default::default(),
                lines: Default::default(),
                links: Default::default(),
                minimum_amount: Default::default(),
                mode: Default::default(),
                paid_at: Default::default(),
                profile_id: Default::default(),
                redirect_url: Default::default(),
                resource: Default::default(),
                reusable: Default::default(),
                sequence_type: Default::default(),
                shipping_address: Default::default(),
                testmode: Default::default(),
                webhook_url: Default::default(),
            }
        }
    }

    ///With Mollie Connect you can charge fees on payment links that your app
    /// is processing on behalf of other Mollie merchants.
    ///
    ///If you use OAuth to create payment links on a connected merchant's
    /// account, you can charge a fee using this `applicationFee` parameter.
    /// If a payment on the payment link succeeds, the fee will be deducted from
    /// the merchant's balance and sent to your own account balance.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "With Mollie Connect you can charge fees on payment
    /// links that your app is processing on behalf of other
    /// Mollie\nmerchants.\n\nIf you use OAuth to create payment links on a
    /// connected merchant's account, you can charge a fee using
    /// this\n`applicationFee` parameter. If a payment on the payment link
    /// succeeds, the fee will be deducted from the merchant's balance and
    /// sent\nto your own account balance.",
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "description"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "description": {
    ///      "description": "The description of the application fee. This will
    /// appear on settlement reports towards both you and the\nconnected
    /// merchant.",
    ///      "examples": [
    ///        "Platform fee"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentLinkApplicationFee {
        pub amount: Amount,
        ///The description of the application fee. This will appear on
        /// settlement reports towards both you and the
        /// connected merchant.
        pub description: EntityPaymentLinkApplicationFeeDescription,
    }

    impl ::std::convert::From<&EntityPaymentLinkApplicationFee> for EntityPaymentLinkApplicationFee {
        fn from(value: &EntityPaymentLinkApplicationFee) -> Self {
            value.clone()
        }
    }

    ///The description of the application fee. This will appear on settlement
    /// reports towards both you and the connected merchant.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The description of the application fee. This will
    /// appear on settlement reports towards both you and the\nconnected
    /// merchant.",
    ///  "examples": [
    ///    "Platform fee"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityPaymentLinkApplicationFeeDescription(::std::string::String);
    impl ::std::ops::Deref for EntityPaymentLinkApplicationFeeDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityPaymentLinkApplicationFeeDescription> for ::std::string::String {
        fn from(value: EntityPaymentLinkApplicationFeeDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityPaymentLinkApplicationFeeDescription>
        for EntityPaymentLinkApplicationFeeDescription
    {
        fn from(value: &EntityPaymentLinkApplicationFeeDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityPaymentLinkApplicationFeeDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityPaymentLinkApplicationFeeDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for EntityPaymentLinkApplicationFeeDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityPaymentLinkApplicationFeeDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityPaymentLinkApplicationFeeDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///A short description of the payment link. The description is visible in
    /// the Dashboard and will be shown on the customer's bank or card
    /// statement when possible.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A short description of the payment link. The
    /// description is visible in the Dashboard and will be shown on
    /// the\ncustomer's bank or card statement when possible.",
    ///  "examples": [
    ///    "Chess Board"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityPaymentLinkDescription(::std::string::String);
    impl ::std::ops::Deref for EntityPaymentLinkDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityPaymentLinkDescription> for ::std::string::String {
        fn from(value: EntityPaymentLinkDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityPaymentLinkDescription> for EntityPaymentLinkDescription {
        fn from(value: &EntityPaymentLinkDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityPaymentLinkDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityPaymentLinkDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityPaymentLinkDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityPaymentLinkDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityPaymentLinkDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "paymentLink",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "paymentLink": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentLinkLinks {
        #[serde(rename = "paymentLink")]
        pub payment_link: Url,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&EntityPaymentLinkLinks> for EntityPaymentLinkLinks {
        fn from(value: &EntityPaymentLinkLinks) -> Self {
            value.clone()
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "dashboard",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "captures": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "changePaymentState": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "chargebacks": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "checkout": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "customer": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "dashboard": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "mandate": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "mobileAppCheckout": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "order": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "payOnline": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "refunds": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "settlement": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "subscription": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "terminal": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub captures: ::std::option::Option<Url>,
        #[serde(
            rename = "changePaymentState",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub change_payment_state: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chargebacks: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub checkout: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub customer: ::std::option::Option<Url>,
        pub dashboard: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mandate: ::std::option::Option<Url>,
        #[serde(
            rename = "mobileAppCheckout",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub mobile_app_checkout: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub order: ::std::option::Option<Url>,
        #[serde(
            rename = "payOnline",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub pay_online: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub refunds: ::std::option::Option<Url>,
        #[serde(rename = "self")]
        pub self_: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub settlement: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub subscription: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub terminal: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&EntityPaymentLinks> for EntityPaymentLinks {
        fn from(value: &EntityPaymentLinks) -> Self {
            value.clone()
        }
    }

    ///`EntityPaymentResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "dashboard",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "captures": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "changePaymentState": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "chargebacks": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "checkout": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "customer": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "dashboard": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "mandate": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "mobileAppCheckout": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "order": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "payOnline": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "refunds": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "settlement": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "status": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "subscription": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "terminal": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "amountCaptured": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "amountChargedBack": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "amountRefunded": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "amountRemaining": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "applicationFee": {
    ///      "description": "With Mollie Connect you can charge fees on payments
    /// that your app is processing on behalf of other Mollie\nmerchants.\n\nIf
    /// you use OAuth to create payments on a connected merchant's account, you
    /// can charge a fee using this\n`applicationFee` parameter. If the payment
    /// succeeds, the fee will be deducted from the merchant's balance and
    /// sent\nto your own account balance.\n\nIf instead you want to split a
    /// payment on your own account between yourself and a connected merchant,
    /// refer to the\n`routing` parameter.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "amount": {
    ///          "$ref": "#/components/schemas/amount"
    ///        },
    ///        "description": {
    ///          "description": "The description of the application fee. This
    /// will appear on settlement reports towards both you and the\nconnected
    /// merchant.",
    ///          "examples": [
    ///            10
    ///          ],
    ///          "type": "string",
    ///          "maxLength": 255
    ///        }
    ///      }
    ///    },
    ///    "authorizedAt": {
    ///      "description": "The date and time the payment became authorized, in
    /// ISO 8601 format. This parameter is omitted if the payment is\nnot
    /// authorized (yet).",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-03-20T09:28:37.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "billingAddress": {
    ///      "description": "The customer's billing address details. We advise
    /// to provide these details to improve fraud protection
    /// and\nconversion.\n\nShould include `email` or a valid postal address
    /// consisting of `streetAndNumber`, `postalCode`, `city`
    /// and\n`country`.\n\nRequired for payment method `in3`, `klarna`, `billie`
    /// and `riverty`.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/payment-address"
    ///        },
    ///        {
    ///          "type": "object",
    ///          "properties": {
    ///            "organizationName": {
    ///              "description": "The name of the organization, in case the addressee is an organization.\n\nRequired for payment method `billie`."
    ///            }
    ///          }
    ///        }
    ///      ]
    ///    },
    ///    "cancelUrl": {
    ///      "description": "The URL your customer will be redirected to when
    /// the customer explicitly cancels the payment. If this URL is
    /// not\nprovided, the customer will be redirected to the `redirectUrl`
    /// instead — see above.\n\nMollie will always give you status updates via
    /// webhooks, including for the canceled status. This parameter
    /// is\ntherefore entirely optional, but can be useful when implementing a
    /// dedicated customer-facing flow to handle\npayment cancellations.",
    ///      "examples": [
    ///        "https://example.org/cancel"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "canceledAt": {
    ///      "description": "The date and time the payment was canceled, in ISO
    /// 8601 format. This parameter is omitted if the payment is not\ncanceled
    /// (yet).",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-03-20T09:28:37.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "captureBefore": {
    ///      "description": "Indicates the date before which the payment needs
    /// to be captured, in ISO 8601 format. From this date onwards we\ncan no
    /// longer guarantee a successful capture. The parameter is omitted if the
    /// payment is not authorized (yet).",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-03-20T09:28:37.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "captureDelay": {
    ///      "description": "**Only relevant if you wish to manage authorization
    /// and capturing separately.**\n\nSome payment methods allow placing a hold
    /// on the card or bank account. This hold or 'authorization' can then at
    /// a\nlater point either be 'captured' or canceled.\n\nBy default, we
    /// charge the customer's card or bank account immediately when they
    /// complete the payment. If you set a\ncapture delay however, we will delay
    /// the automatic capturing of the payment for the specified amount of time.
    /// For\nexample `8 hours` or `2 days`.\n\nTo schedule an automatic capture,
    /// the `captureMode` must be set to `automatic`.\n\nThe maximum delay is 7
    /// days (168 hours).\n\nPossible values: `... hours` `... days`",
    ///      "examples": [
    ///        "8 hours"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "pattern": "^\\d+ (hours|days)$"
    ///    },
    ///    "captureMode": {
    ///      "$ref": "#/components/schemas/capture-mode-response"
    ///    },
    ///    "countryCode": {
    ///      "description": "This optional field contains your customer's ISO
    /// 3166-1 alpha-2 country code, detected by us during checkout. This\nfield
    /// is omitted if the country code was not detected.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "BE"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "maxLength": 2,
    ///      "minLength": 2
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "customerId": {
    ///      "$ref": "#/components/schemas/customerToken"
    ///    },
    ///    "description": {
    ///      "description": "The description of the payment. This will be shown
    /// to your customer on their card or bank statement when possible.\nWe
    /// truncate the description automatically according to the limits of the
    /// used payment method. The description is\nalso visible in any exports you
    /// generate.\n\nWe recommend you use a unique identifier so that you can
    /// always link the payment to the order in your back office.\nThis is
    /// particularly useful for bookkeeping.\n\nThe maximum length of the
    /// description field differs per payment method, with the absolute maximum
    /// being 255\ncharacters. The API will not reject strings longer than the
    /// maximum length but it will truncate them to fit.",
    ///      "examples": [
    ///        "Chess Board"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "details": {
    ///      "description": "An object containing payment details collected
    /// during the payment process. For example, details may include
    /// the\ncustomer's card or bank details and a payment reference. For the
    /// full list of details, please refer to the\n[method-specific
    /// parameters](extra-payment-parameters) guide.",
    ///      "readOnly": true,
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "bankAccount": {
    ///          "description": "The bank account number the customer will need
    /// to make the bank transfer payment towards.",
    ///          "examples": [
    ///            "NL91ABNA0417164300"
    ///          ],
    ///          "type": "string",
    ///          "x-methodSpecific": true
    ///        },
    ///        "bankBic": {
    ///          "description": "The BIC of the bank the customer will need to
    /// make the bank transfer payment towards.",
    ///          "examples": [
    ///            "ABNANL2A"
    ///          ],
    ///          "type": "string",
    ///          "x-methodSpecific": true
    ///        },
    ///        "bankName": {
    ///          "description": "The name of the bank that the customer will
    /// need to make the bank transfer payment towards.",
    ///          "examples": [
    ///            "Mollie Bank"
    ///          ],
    ///          "type": "string",
    ///          "x-methodSpecific": true
    ///        },
    ///        "bankReason": {
    ///          "description": "A human-friendly description of the failure
    /// reason.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "bankReasonCode": {
    ///          "description": "The official reason why this payment has
    /// failed. A detailed description of each reason is available on
    /// the\nwebsite of the European Payments Council.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "batchReference": {
    ///          "description": "The batch reference you provided in the batch
    /// file.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "card3dsEci": {
    ///          "description": "The outcome of authentication attempted on
    /// transactions enforced by 3DS (ie valid only for oneoff and first).",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardAudition": {
    ///          "$ref":
    /// "#/components/schemas/payment-details-card-audition-response"
    ///        },
    ///        "cardBin": {
    ///          "description": "The first 6 digit of the card bank
    /// identification number.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardCountryCode": {
    ///          "description": "The ISO 3166-1 alpha-2 country code of the
    /// country the card was issued in.",
    ///          "examples": [
    ///            "NL"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardExpiryDate": {
    ///          "description": "The expiry date (MM/YY) of the card as
    /// displayed on the card.",
    ///          "examples": [
    ///            "12/25"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardFingerprint": {
    ///          "description": "A unique fingerprint for a specific card. Can
    /// be used to identify returning customers.\n\nIn the case of Point-of-sale
    /// payments, it's a unique identifier assigned to a cardholder's payment
    /// account,\nlinking multiple transactions from wallets and physical card
    /// to a single account, also across payment methods\nor when the card is
    /// reissued.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardFunding": {
    ///          "$ref":
    /// "#/components/schemas/payment-details-card-funding-response"
    ///        },
    ///        "cardHolder": {
    ///          "description": "The customer's name as shown on their card.",
    ///          "examples": [
    ///            "John Doe"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardIssuer": {
    ///          "description": "The issuer of the Card.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardLabel": {
    ///          "$ref":
    /// "#/components/schemas/payment-details-card-label-response"
    ///        },
    ///        "cardMaskedNumber": {
    ///          "description": "The first 6 and last 4 digits of the card
    /// number.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardNumber": {
    ///          "description": "For bancontact, it will be the customer's
    /// masked card number. For cards, it will be the last 4-digit of the\nPAN.
    /// For Point-of-sale, it will be the the last 4 digits of the customer's
    /// masked card number.",
    ///          "examples": [
    ///            "************1234"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "cardSecurity": {
    ///          "$ref":
    /// "#/components/schemas/payment-details-card-security-response"
    ///        },
    ///        "consumerAccount": {
    ///          "description": "The customer's account reference.\n\nFor
    /// banking-based payment methods — such as iDEAL — this is normally either
    /// an IBAN or a domestic bank account\nnumber.\n\nFor PayPal, the account
    /// reference is an email address.\n\nFor card and Bancontact payments,
    /// refer to details.cardNumber.",
    ///          "examples": [
    ///            "NL91ABNA0417164300"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "consumerBic": {
    ///          "description": "The BIC of the customer's bank account, if
    /// applicable.",
    ///          "examples": [
    ///            "ABNANL2A"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "consumerName": {
    ///          "description": "The customer's name, if made available by the
    /// payment method. For card payments, refer to details.cardHolder.",
    ///          "examples": [
    ///            "John Doe"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "creditorIdentifier": {
    ///          "description": "The creditor identifier indicates who is
    /// authorized to execute the payment. In this case, it is a\nreference to
    /// Mollie.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "customerReference": {
    ///          "description": "The paysafecard customer reference either
    /// provided via the API or otherwise auto-generated by Mollie.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": "string",
    ///          "x-methodSpecific": true
    ///        },
    ///        "dueDate": {
    ///          "description": "Estimated date the payment is debited from the
    /// customer's bank account, in YYYY-MM-DD format.",
    ///          "examples": [
    ///            "2025-01-01"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "format": "date",
    ///          "x-methodSpecific": true
    ///        },
    ///        "endToEndIdentifier": {
    ///          "description": "The end-to-end identifier you provided in the
    /// batch file.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "failureMessage": {
    ///          "description": "A human-friendly failure message that can be
    /// shown to the customer. The message is translated in accordance\nwith the
    /// payment's locale setting.",
    ///          "examples": [
    ///            "Your card was declined."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "failureReason": {
    ///          "$ref":
    /// "#/components/schemas/payment-details-failure-reason-response"
    ///        },
    ///        "feeRegion": {
    ///          "$ref":
    /// "#/components/schemas/payment-details-fee-region-response"
    ///        },
    ///        "fileReference": {
    ///          "description": "The file reference you provided in the batch
    /// file.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "giftcards": {
    ///          "description": "An array of detail objects for each gift card
    /// that was used on this payment, if any.",
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "additionalProperties": true
    ///          },
    ///          "x-methodSpecific": true
    ///        },
    ///        "issuer": {
    ///          "description": "For payments with vouchers: the brand name of
    /// the first voucher applied.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": "string",
    ///          "x-methodSpecific": true
    ///        },
    ///        "mandateReference": {
    ///          "description": "The mandate reference you provided in the batch
    /// file.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "maskedNumber": {
    ///          "description": "The first 6 digits & last 4 digits of the
    /// customer's masked card number.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "paypalFee": {
    ///          "$ref": "#/components/schemas/amount-nullable"
    ///        },
    ///        "paypalPayerId": {
    ///          "description": "ID of the customer's PayPal account.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "paypalReference": {
    ///          "description": "PayPal's reference for the payment.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "qrCode": {
    ///          "description": "Optional include. If a QR code was requested
    /// during payment creation for a QR-compatible payment method,\nthe QR code
    /// details will be available in this object.\n\nThe QR code can be scanned
    /// by the customer to complete the payment on their mobile device. For
    /// example,\nBancontact QR payments can be completed by the customer using
    /// the Bancontact app.",
    ///          "type": "object",
    ///          "properties": {
    ///            "height": {
    ///              "description": "The height of the QR code image in
    /// pixels.",
    ///              "examples": [
    ///                300
    ///              ],
    ///              "type": "integer"
    ///            },
    ///            "src": {
    ///              "description": "The URL to the QR code image. The image is
    /// a PNG file, and can be displayed directly in the browser
    /// or\ndownloaded.",
    ///              "examples": [
    ///                "https://www.mollie.com/images/qr-code.png"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "width": {
    ///              "description": "The width of the QR code image in pixels.",
    ///              "examples": [
    ///                300
    ///              ],
    ///              "type": "integer"
    ///            }
    ///          },
    ///          "x-methodSpecific": true
    ///        },
    ///        "receipt": {
    ///          "description": "The Point of sale receipt object.",
    ///          "type": "object",
    ///          "properties": {
    ///            "applicationIdentifier": {
    ///              "description": "The unique number that identifies a
    /// specific payment application on a chip card.",
    ///              "examples": [
    ///                "..."
    ///              ],
    ///              "type": [
    ///                "string",
    ///                "null"
    ///              ]
    ///            },
    ///            "authorizationCode": {
    ///              "description": "A unique code provided by the cardholder’s
    /// bank to confirm that the transaction was successfully approved.",
    ///              "examples": [
    ///                "..."
    ///              ],
    ///              "type": [
    ///                "string",
    ///                "null"
    ///              ]
    ///            },
    ///            "cardReadMethod": {
    ///              "$ref":
    /// "#/components/schemas/payment-details-receipt-card-read-method-response"
    ///            },
    ///            "cardVerificationMethod": {
    ///              "$ref":
    /// "#/components/schemas/
    /// payment-details-receipt-card-verification-method-response"
    ///            }
    ///          },
    ///          "x-methodSpecific": true
    ///        },
    ///        "remainderAmount": {
    ///          "$ref": "#/components/schemas/amount"
    ///        },
    ///        "remainderDetails": {
    ///          "description": "Optional include. The full payment method
    /// details of the remainder payment.",
    ///          "type": "object",
    ///          "additionalProperties": true,
    ///          "x-methodSpecific": true
    ///        },
    ///        "remainderMethod": {
    ///          "description": "The payment method used to pay the remainder
    /// amount, after all gift cards or vouchers were applied.",
    ///          "examples": [
    ///            "creditcard"
    ///          ],
    ///          "type": "string",
    ///          "x-methodSpecific": true
    ///        },
    ///        "sellerProtection": {
    ///          "$ref":
    /// "#/components/schemas/payment-details-seller-protection-response"
    ///        },
    ///        "shippingAddress": {
    ///          "description": "For wallet payment methods — such as Apple Pay
    /// and PayPal — the shipping address is often already known by the\nwallet
    /// provider. In these cases the shipping address may be available as a
    /// payment detail.",
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "additionalProperties": true,
    ///          "x-methodSpecific": true
    ///        },
    ///        "signatureDate": {
    ///          "description": "Date the payment has been signed by the
    /// customer, in YYYY-MM-DD format. Only available if the payment\nhas been
    /// signed.",
    ///          "examples": [
    ///            "2024-03-20"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "format": "date",
    ///          "x-methodSpecific": true
    ///        },
    ///        "terminalId": {
    ///          "description": "The ID of the terminal device where the payment
    /// took place on.",
    ///          "examples": [
    ///            "term_12345"
    ///          ],
    ///          "type": "string",
    ///          "x-methodSpecific": true
    ///        },
    ///        "transferReference": {
    ///          "description": "The Mollie-generated reference the customer
    /// needs to use when transfering the amount. Do not apply any\nformatting
    /// here; show it to the customer as-is.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "x-methodSpecific": true
    ///        },
    ///        "voucherNumber": {
    ///          "description": "For payments with gift cards: the masked gift
    /// card number of the first gift card applied to the payment.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": "string",
    ///          "x-methodSpecific": true
    ///        },
    ///        "vouchers": {
    ///          "description": "An array of detail objects for each voucher
    /// that was used on this payment, if any.",
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "additionalProperties": true
    ///          },
    ///          "x-methodSpecific": true
    ///        },
    ///        "wallet": {
    ///          "$ref": "#/components/schemas/payment-details-wallet-response"
    ///        }
    ///      }
    ///    },
    ///    "dueDate": {
    ///      "description": "The date by which the payment should be completed
    /// in `YYYY-MM-DD` format",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "2025-01-01"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "expiredAt": {
    ///      "description": "The date and time the payment was expired, in ISO
    /// 8601 format. This parameter is omitted if the payment did not\nexpire
    /// (yet).",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-03-20T09:28:37.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "expiresAt": {
    ///      "description": "The date and time the payment will expire, in ISO
    /// 8601 format. This parameter is omitted if the payment can no\nlonger
    /// expire.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-03-20T09:28:37.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "failedAt": {
    ///      "description": "The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail\n(yet).",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-03-20T09:28:37.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    },
    ///    "isCancelable": {
    ///      "description": "Whether the payment can be canceled. This parameter
    /// is omitted if the payment reaches a final state.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "issuer": {
    ///      "description": "**Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**\n\n**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information\non the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**\n\nSome payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment\nmethod, the customer may still need to select the appropriate issuer before the payment can proceed.\n\nWe provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API\nup front.\n\nThe full list of issuers for a specific method can be retrieved via the Methods API by using the optional\n`issuers` include.\n\nA valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "ideal_INGBNL2A"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "lines": {
    ///      "description": "Optionally provide the order lines for the payment.
    /// Each line contains details such as a description of the item\nordered
    /// and its price.\n\nAll lines must have the same currency as the
    /// payment.\n\nRequired for payment methods `billie`, `in3`, `klarna`,
    /// `riverty` and `voucher`.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "allOf": [
    ///          {
    ///            "$ref": "#/components/schemas/payment-line-item-response"
    ///          },
    ///          {
    ///            "type": "object",
    ///            "properties": {
    ///              "recurring": {
    ///                "$ref": "#/components/schemas/recurring-line-item"
    ///              }
    ///            }
    ///          }
    ///        ]
    ///      }
    ///    },
    ///    "locale": {
    ///      "$ref": "#/components/schemas/locale-response"
    ///    },
    ///    "mandateId": {
    ///      "$ref": "#/components/schemas/mandateToken"
    ///    },
    ///    "metadata": {
    ///      "$ref": "#/components/schemas/metadata"
    ///    },
    ///    "method": {
    ///      "$ref": "#/components/schemas/method-response"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "orderId": {
    ///      "$ref": "#/components/schemas/orderToken"
    ///    },
    ///    "paidAt": {
    ///      "description": "The date and time the payment became paid, in ISO
    /// 8601 format. This parameter is omitted if the payment is not\ncompleted
    /// (yet).",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-03-20T09:28:37.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "profileId": {
    ///      "$ref": "#/components/schemas/profileToken"
    ///    },
    ///    "redirectUrl": {
    ///      "description": "The URL your customer will be redirected to after
    /// the payment process.\n\nIt could make sense for the redirectUrl to
    /// contain a unique identifier – like your order ID – so you can show
    /// the\nright page referencing the order when your customer returns.\n\nThe
    /// parameter is normally required, but can be omitted for recurring
    /// payments (`sequenceType: recurring`) and for\nApple Pay payments with an
    /// `applePayPaymentToken`.",
    ///      "examples": [
    ///        "https://example.org/redirect"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a payment object.
    /// Will always contain the string `payment` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "payment"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "restrictPaymentMethodsToCountry": {
    ///      "description": "For digital goods in most jurisdictions, you must
    /// apply the VAT rate from your customer's country. Choose the VAT\nrates
    /// you have used for the order to ensure your customer's country matches
    /// the VAT country.\n\nUse this parameter to restrict the payment methods
    /// available to your customer to those from a single country.\n\nIf
    /// available, the credit card method will still be offered, but only cards
    /// from the allowed country are accepted.\n\nThe field expects a country
    /// code in ISO 3166-1 alpha-2 format, for example `NL`.",
    ///      "examples": [
    ///        "NL"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "routing": {
    ///      "description": "*This functionality is not enabled by default.
    /// Reach out to our partner management team if you wish to use it.*\n\nWith
    /// Mollie Connect you can charge fees on payments that your app is
    /// processing on behalf of other Mollie\nmerchants.\n\nIf you create
    /// payments on your own account that you want to split between yourself and
    /// one or more connected\nmerchants, you can use this `routing` parameter
    /// to route the payment accordingly.\n\nThe `routing` parameter should
    /// contain an array of objects, with each object describing the destination
    /// for a\nspecific portion of the payment.\n\nIt is not necessary to
    /// indicate in the array which portion goes to yourself. After all portions
    /// of the total\npayment amount have been routed, the amount left will be
    /// routed to the current organization automatically.\n\nIf instead you use
    /// OAuth to create payments on a connected merchant's account, refer to the
    /// `applicationFee`\nparameter.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-payment-route-response"
    ///      }
    ///    },
    ///    "sequenceType": {
    ///      "$ref": "#/components/schemas/sequence-type-response"
    ///    },
    ///    "settlementAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "settlementId": {
    ///      "$ref": "#/components/schemas/settlementToken"
    ///    },
    ///    "shippingAddress": {
    ///      "$ref": "#/components/schemas/payment-address"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/payment-status"
    ///    },
    ///    "statusReason": {
    ///      "$ref": "#/components/schemas/status-reason"
    ///    },
    ///    "subscriptionId": {
    ///      "$ref": "#/components/schemas/subscriptionToken"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    },
    ///    "webhookUrl": {
    ///      "description": "The webhook URL where we will send payment status
    /// updates to.\n\nThe webhookUrl is optional, but without a webhook you
    /// will miss out on important status changes to your payment.\n\nThe
    /// webhookUrl must be reachable from Mollie's point of view, so you cannot
    /// use `localhost`. If you want to use\nwebhook during development on
    /// `localhost`, you must use a tool like ngrok to have the webhooks
    /// delivered to your\nlocal machine.",
    ///      "examples": [
    ///        "https://example.org/webhooks"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<Amount>,
        #[serde(
            rename = "amountCaptured",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub amount_captured: ::std::option::Option<Amount>,
        #[serde(
            rename = "amountChargedBack",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub amount_charged_back: ::std::option::Option<Amount>,
        #[serde(
            rename = "amountRefunded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub amount_refunded: ::std::option::Option<Amount>,
        #[serde(
            rename = "amountRemaining",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub amount_remaining: ::std::option::Option<Amount>,
        ///With Mollie Connect you can charge fees on payments that your app is
        /// processing on behalf of other Mollie merchants.
        ///
        ///If you use OAuth to create payments on a connected merchant's
        /// account, you can charge a fee using this `applicationFee`
        /// parameter. If the payment succeeds, the fee will be deducted from
        /// the merchant's balance and sent to your own account balance.
        ///
        ///If instead you want to split a payment on your own account between
        /// yourself and a connected merchant, refer to the
        /// `routing` parameter.
        #[serde(
            rename = "applicationFee",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub application_fee: ::std::option::Option<EntityPaymentResponseApplicationFee>,
        ///The date and time the payment became authorized, in ISO 8601 format.
        /// This parameter is omitted if the payment is not authorized
        /// (yet).
        #[serde(
            rename = "authorizedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub authorized_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "billingAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub billing_address: ::std::option::Option<PaymentAddress>,
        ///The URL your customer will be redirected to when the customer
        /// explicitly cancels the payment. If this URL is not provided,
        /// the customer will be redirected to the `redirectUrl` instead — see
        /// above.
        ///
        ///Mollie will always give you status updates via webhooks, including
        /// for the canceled status. This parameter is
        /// therefore entirely optional, but can be useful when implementing a
        /// dedicated customer-facing flow to handle
        /// payment cancellations.
        #[serde(
            rename = "cancelUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub cancel_url: ::std::option::Option<::std::string::String>,
        ///The date and time the payment was canceled, in ISO 8601 format. This
        /// parameter is omitted if the payment is not canceled (yet).
        #[serde(
            rename = "canceledAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub canceled_at: ::std::option::Option<::std::string::String>,
        ///Indicates the date before which the payment needs to be captured, in
        /// ISO 8601 format. From this date onwards we can no longer
        /// guarantee a successful capture. The parameter is omitted if the
        /// payment is not authorized (yet).
        #[serde(
            rename = "captureBefore",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub capture_before: ::std::option::Option<::std::string::String>,
        ///**Only relevant if you wish to manage authorization and capturing
        /// separately.**
        ///
        ///Some payment methods allow placing a hold on the card or bank
        /// account. This hold or 'authorization' can then at a
        /// later point either be 'captured' or canceled.
        ///
        ///By default, we charge the customer's card or bank account
        /// immediately when they complete the payment. If you set a
        /// capture delay however, we will delay the automatic capturing of the
        /// payment for the specified amount of time. For example `8
        /// hours` or `2 days`.
        ///
        ///To schedule an automatic capture, the `captureMode` must be set to
        /// `automatic`.
        ///
        ///The maximum delay is 7 days (168 hours).
        ///
        ///Possible values: `... hours` `... days`
        #[serde(
            rename = "captureDelay",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub capture_delay: ::std::option::Option<EntityPaymentResponseCaptureDelay>,
        #[serde(
            rename = "captureMode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub capture_mode: ::std::option::Option<CaptureModeResponse>,
        ///This optional field contains your customer's ISO 3166-1 alpha-2
        /// country code, detected by us during checkout. This
        /// field is omitted if the country code was not detected.
        #[serde(
            rename = "countryCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub country_code: ::std::option::Option<EntityPaymentResponseCountryCode>,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        #[serde(
            rename = "customerId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub customer_id: ::std::option::Option<CustomerToken>,
        ///The description of the payment. This will be shown to your customer
        /// on their card or bank statement when possible. We truncate
        /// the description automatically according to the limits of the used
        /// payment method. The description is also visible in any
        /// exports you generate.
        ///
        ///We recommend you use a unique identifier so that you can always link
        /// the payment to the order in your back office.
        /// This is particularly useful for bookkeeping.
        ///
        ///The maximum length of the description field differs per payment
        /// method, with the absolute maximum being 255 characters. The
        /// API will not reject strings longer than the maximum length but it
        /// will truncate them to fit.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<EntityPaymentResponseDescription>,
        ///An object containing payment details collected during the payment
        /// process. For example, details may include the customer's
        /// card or bank details and a payment reference. For the full list of
        /// details, please refer to the [method-specific
        /// parameters](extra-payment-parameters) guide.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub details: ::std::option::Option<EntityPaymentResponseDetails>,
        ///The date by which the payment should be completed in `YYYY-MM-DD`
        /// format
        #[serde(
            rename = "dueDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub due_date: ::std::option::Option<::std::string::String>,
        ///The date and time the payment was expired, in ISO 8601 format. This
        /// parameter is omitted if the payment did not expire (yet).
        #[serde(
            rename = "expiredAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub expired_at: ::std::option::Option<::std::string::String>,
        ///The date and time the payment will expire, in ISO 8601 format. This
        /// parameter is omitted if the payment can no longer expire.
        #[serde(
            rename = "expiresAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub expires_at: ::std::option::Option<::std::string::String>,
        ///The date and time the payment failed, in ISO 8601 format. This
        /// parameter is omitted if the payment did not fail (yet).
        #[serde(
            rename = "failedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub failed_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<PaymentToken>,
        ///Whether the payment can be canceled. This parameter is omitted if
        /// the payment reaches a final state.
        #[serde(
            rename = "isCancelable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub is_cancelable: ::std::option::Option<bool>,
        ///**Only relevant for iDEAL, KBC/CBC, gift card, and voucher
        /// payments.**
        ///
        ///**⚠️ With the introduction of iDEAL 2 in 2025, this field will be
        /// ignored for iDEAL payments. For more information on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
        ///
        ///Some payment methods are a network of connected banks or card
        /// issuers. In these cases, after selecting the payment method,
        /// the customer may still need to select the appropriate issuer before
        /// the payment can proceed.
        ///
        ///We provide hosted issuer selection screens, but these screens can be
        /// skipped by providing the `issuer` via the API up front.
        ///
        ///The full list of issuers for a specific method can be retrieved via
        /// the Methods API by using the optional `issuers` include.
        ///
        ///A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING
        /// Bank).
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub issuer: ::std::option::Option<::std::string::String>,
        ///Optionally provide the order lines for the payment. Each line
        /// contains details such as a description of the item
        /// ordered and its price.
        ///
        ///All lines must have the same currency as the payment.
        ///
        ///Required for payment methods `billie`, `in3`, `klarna`, `riverty`
        /// and `voucher`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub lines: ::std::option::Option<::std::vec::Vec<EntityPaymentResponseLinesItem>>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityPaymentResponseLinks>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub locale: ::std::option::Option<LocaleResponse>,
        #[serde(
            rename = "mandateId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub mandate_id: ::std::option::Option<MandateToken>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<Metadata>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub method: ::std::option::Option<MethodResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<Mode>,
        #[serde(
            rename = "orderId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub order_id: ::std::option::Option<OrderToken>,
        ///The date and time the payment became paid, in ISO 8601 format. This
        /// parameter is omitted if the payment is not completed (yet).
        #[serde(
            rename = "paidAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paid_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "profileId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub profile_id: ::std::option::Option<ProfileToken>,
        ///The URL your customer will be redirected to after the payment
        /// process.
        ///
        ///It could make sense for the redirectUrl to contain a unique
        /// identifier – like your order ID – so you can show the
        /// right page referencing the order when your customer returns.
        ///
        ///The parameter is normally required, but can be omitted for recurring
        /// payments (`sequenceType: recurring`) and for
        /// Apple Pay payments with an `applePayPaymentToken`.
        #[serde(
            rename = "redirectUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub redirect_url: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a payment object. Will always
        /// contain the string `payment` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        ///For digital goods in most jurisdictions, you must apply the VAT rate
        /// from your customer's country. Choose the VAT rates you have
        /// used for the order to ensure your customer's country matches the VAT
        /// country.
        ///
        ///Use this parameter to restrict the payment methods available to your
        /// customer to those from a single country.
        ///
        ///If available, the credit card method will still be offered, but only
        /// cards from the allowed country are accepted.
        ///
        ///The field expects a country code in ISO 3166-1 alpha-2 format, for
        /// example `NL`.
        #[serde(
            rename = "restrictPaymentMethodsToCountry",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub restrict_payment_methods_to_country: ::std::option::Option<::std::string::String>,
        ///*This functionality is not enabled by default. Reach out to our
        /// partner management team if you wish to use it.*
        ///
        ///With Mollie Connect you can charge fees on payments that your app is
        /// processing on behalf of other Mollie merchants.
        ///
        ///If you create payments on your own account that you want to split
        /// between yourself and one or more connected merchants, you
        /// can use this `routing` parameter to route the payment accordingly.
        ///
        ///The `routing` parameter should contain an array of objects, with
        /// each object describing the destination for a
        /// specific portion of the payment.
        ///
        ///It is not necessary to indicate in the array which portion goes to
        /// yourself. After all portions of the total payment amount
        /// have been routed, the amount left will be routed to the current
        /// organization automatically.
        ///
        ///If instead you use OAuth to create payments on a connected
        /// merchant's account, refer to the `applicationFee` parameter.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub routing: ::std::option::Option<::std::vec::Vec<EntityPaymentRouteResponse>>,
        #[serde(
            rename = "sequenceType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub sequence_type: ::std::option::Option<SequenceTypeResponse>,
        #[serde(
            rename = "settlementAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_amount: ::std::option::Option<Amount>,
        #[serde(
            rename = "settlementId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_id: ::std::option::Option<SettlementToken>,
        #[serde(
            rename = "shippingAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub shipping_address: ::std::option::Option<PaymentAddress>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<PaymentStatus>,
        #[serde(
            rename = "statusReason",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub status_reason: ::std::option::Option<StatusReason>,
        #[serde(
            rename = "subscriptionId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subscription_id: ::std::option::Option<SubscriptionToken>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
        ///The webhook URL where we will send payment status updates to.
        ///
        ///The webhookUrl is optional, but without a webhook you will miss out
        /// on important status changes to your payment.
        ///
        ///The webhookUrl must be reachable from Mollie's point of view, so you
        /// cannot use `localhost`. If you want to use webhook during
        /// development on `localhost`, you must use a tool like ngrok to have
        /// the webhooks delivered to your local machine.
        #[serde(
            rename = "webhookUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub webhook_url: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityPaymentResponse> for EntityPaymentResponse {
        fn from(value: &EntityPaymentResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityPaymentResponse {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                amount_captured: Default::default(),
                amount_charged_back: Default::default(),
                amount_refunded: Default::default(),
                amount_remaining: Default::default(),
                application_fee: Default::default(),
                authorized_at: Default::default(),
                billing_address: Default::default(),
                cancel_url: Default::default(),
                canceled_at: Default::default(),
                capture_before: Default::default(),
                capture_delay: Default::default(),
                capture_mode: Default::default(),
                country_code: Default::default(),
                created_at: Default::default(),
                customer_id: Default::default(),
                description: Default::default(),
                details: Default::default(),
                due_date: Default::default(),
                expired_at: Default::default(),
                expires_at: Default::default(),
                failed_at: Default::default(),
                id: Default::default(),
                is_cancelable: Default::default(),
                issuer: Default::default(),
                lines: Default::default(),
                links: Default::default(),
                locale: Default::default(),
                mandate_id: Default::default(),
                metadata: Default::default(),
                method: Default::default(),
                mode: Default::default(),
                order_id: Default::default(),
                paid_at: Default::default(),
                profile_id: Default::default(),
                redirect_url: Default::default(),
                resource: Default::default(),
                restrict_payment_methods_to_country: Default::default(),
                routing: Default::default(),
                sequence_type: Default::default(),
                settlement_amount: Default::default(),
                settlement_id: Default::default(),
                shipping_address: Default::default(),
                status: Default::default(),
                status_reason: Default::default(),
                subscription_id: Default::default(),
                testmode: Default::default(),
                webhook_url: Default::default(),
            }
        }
    }

    ///With Mollie Connect you can charge fees on payments that your app is
    /// processing on behalf of other Mollie merchants.
    ///
    ///If you use OAuth to create payments on a connected merchant's account,
    /// you can charge a fee using this `applicationFee` parameter. If the
    /// payment succeeds, the fee will be deducted from the merchant's balance
    /// and sent to your own account balance.
    ///
    ///If instead you want to split a payment on your own account between
    /// yourself and a connected merchant, refer to the `routing` parameter.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "With Mollie Connect you can charge fees on payments
    /// that your app is processing on behalf of other Mollie\nmerchants.\n\nIf
    /// you use OAuth to create payments on a connected merchant's account, you
    /// can charge a fee using this\n`applicationFee` parameter. If the payment
    /// succeeds, the fee will be deducted from the merchant's balance and
    /// sent\nto your own account balance.\n\nIf instead you want to split a
    /// payment on your own account between yourself and a connected merchant,
    /// refer to the\n`routing` parameter.",
    ///  "type": "object",
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "description": {
    ///      "description": "The description of the application fee. This will
    /// appear on settlement reports towards both you and the\nconnected
    /// merchant.",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentResponseApplicationFee {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<Amount>,
        ///The description of the application fee. This will appear on
        /// settlement reports towards both you and the
        /// connected merchant.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<EntityPaymentResponseApplicationFeeDescription>,
    }

    impl ::std::convert::From<&EntityPaymentResponseApplicationFee>
        for EntityPaymentResponseApplicationFee
    {
        fn from(value: &EntityPaymentResponseApplicationFee) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityPaymentResponseApplicationFee {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                description: Default::default(),
            }
        }
    }

    ///The description of the application fee. This will appear on settlement
    /// reports towards both you and the connected merchant.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The description of the application fee. This will
    /// appear on settlement reports towards both you and the\nconnected
    /// merchant.",
    ///  "examples": [
    ///    10
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityPaymentResponseApplicationFeeDescription(::std::string::String);
    impl ::std::ops::Deref for EntityPaymentResponseApplicationFeeDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityPaymentResponseApplicationFeeDescription>
        for ::std::string::String
    {
        fn from(value: EntityPaymentResponseApplicationFeeDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityPaymentResponseApplicationFeeDescription>
        for EntityPaymentResponseApplicationFeeDescription
    {
        fn from(value: &EntityPaymentResponseApplicationFeeDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityPaymentResponseApplicationFeeDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityPaymentResponseApplicationFeeDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for EntityPaymentResponseApplicationFeeDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for EntityPaymentResponseApplicationFeeDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityPaymentResponseApplicationFeeDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///**Only relevant if you wish to manage authorization and capturing
    /// separately.**
    ///
    ///Some payment methods allow placing a hold on the card or bank account.
    /// This hold or 'authorization' can then at a later point either be
    /// 'captured' or canceled.
    ///
    ///By default, we charge the customer's card or bank account immediately
    /// when they complete the payment. If you set a capture delay however,
    /// we will delay the automatic capturing of the payment for the specified
    /// amount of time. For example `8 hours` or `2 days`.
    ///
    ///To schedule an automatic capture, the `captureMode` must be set to
    /// `automatic`.
    ///
    ///The maximum delay is 7 days (168 hours).
    ///
    ///Possible values: `... hours` `... days`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "**Only relevant if you wish to manage authorization and
    /// capturing separately.**\n\nSome payment methods allow placing a hold on
    /// the card or bank account. This hold or 'authorization' can then at
    /// a\nlater point either be 'captured' or canceled.\n\nBy default, we
    /// charge the customer's card or bank account immediately when they
    /// complete the payment. If you set a\ncapture delay however, we will delay
    /// the automatic capturing of the payment for the specified amount of time.
    /// For\nexample `8 hours` or `2 days`.\n\nTo schedule an automatic capture,
    /// the `captureMode` must be set to `automatic`.\n\nThe maximum delay is 7
    /// days (168 hours).\n\nPossible values: `... hours` `... days`",
    ///  "examples": [
    ///    "8 hours"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+ (hours|days)$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityPaymentResponseCaptureDelay(::std::string::String);
    impl ::std::ops::Deref for EntityPaymentResponseCaptureDelay {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityPaymentResponseCaptureDelay> for ::std::string::String {
        fn from(value: EntityPaymentResponseCaptureDelay) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityPaymentResponseCaptureDelay>
        for EntityPaymentResponseCaptureDelay
    {
        fn from(value: &EntityPaymentResponseCaptureDelay) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityPaymentResponseCaptureDelay {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^\\d+ (hours|days)$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+ (hours|days)$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityPaymentResponseCaptureDelay {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityPaymentResponseCaptureDelay {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityPaymentResponseCaptureDelay {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityPaymentResponseCaptureDelay {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///This optional field contains your customer's ISO 3166-1 alpha-2 country
    /// code, detected by us during checkout. This field is omitted if the
    /// country code was not detected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This optional field contains your customer's ISO 3166-1
    /// alpha-2 country code, detected by us during checkout. This\nfield is
    /// omitted if the country code was not detected.",
    ///  "readOnly": true,
    ///  "examples": [
    ///    "BE"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 2,
    ///  "minLength": 2
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityPaymentResponseCountryCode(::std::string::String);
    impl ::std::ops::Deref for EntityPaymentResponseCountryCode {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityPaymentResponseCountryCode> for ::std::string::String {
        fn from(value: EntityPaymentResponseCountryCode) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityPaymentResponseCountryCode> for EntityPaymentResponseCountryCode {
        fn from(value: &EntityPaymentResponseCountryCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityPaymentResponseCountryCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 2usize {
                return Err("longer than 2 characters".into());
            }
            if value.chars().count() < 2usize {
                return Err("shorter than 2 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityPaymentResponseCountryCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityPaymentResponseCountryCode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityPaymentResponseCountryCode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityPaymentResponseCountryCode {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The description of the payment. This will be shown to your customer on
    /// their card or bank statement when possible. We truncate the
    /// description automatically according to the limits of the used payment
    /// method. The description is also visible in any exports you generate.
    ///
    ///We recommend you use a unique identifier so that you can always link the
    /// payment to the order in your back office. This is particularly
    /// useful for bookkeeping.
    ///
    ///The maximum length of the description field differs per payment method,
    /// with the absolute maximum being 255 characters. The API will not
    /// reject strings longer than the maximum length but it will truncate them
    /// to fit.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The description of the payment. This will be shown to
    /// your customer on their card or bank statement when possible.\nWe
    /// truncate the description automatically according to the limits of the
    /// used payment method. The description is\nalso visible in any exports you
    /// generate.\n\nWe recommend you use a unique identifier so that you can
    /// always link the payment to the order in your back office.\nThis is
    /// particularly useful for bookkeeping.\n\nThe maximum length of the
    /// description field differs per payment method, with the absolute maximum
    /// being 255\ncharacters. The API will not reject strings longer than the
    /// maximum length but it will truncate them to fit.",
    ///  "examples": [
    ///    "Chess Board"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityPaymentResponseDescription(::std::string::String);
    impl ::std::ops::Deref for EntityPaymentResponseDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityPaymentResponseDescription> for ::std::string::String {
        fn from(value: EntityPaymentResponseDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityPaymentResponseDescription> for EntityPaymentResponseDescription {
        fn from(value: &EntityPaymentResponseDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityPaymentResponseDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityPaymentResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityPaymentResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityPaymentResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityPaymentResponseDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///An object containing payment details collected during the payment
    /// process. For example, details may include the customer's card or
    /// bank details and a payment reference. For the full list of details,
    /// please refer to the [method-specific
    /// parameters](extra-payment-parameters) guide.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object containing payment details collected during
    /// the payment process. For example, details may include the\ncustomer's
    /// card or bank details and a payment reference. For the full list of
    /// details, please refer to the\n[method-specific
    /// parameters](extra-payment-parameters) guide.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "bankAccount": {
    ///      "description": "The bank account number the customer will need to
    /// make the bank transfer payment towards.",
    ///      "examples": [
    ///        "NL91ABNA0417164300"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "bankBic": {
    ///      "description": "The BIC of the bank the customer will need to make
    /// the bank transfer payment towards.",
    ///      "examples": [
    ///        "ABNANL2A"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "bankName": {
    ///      "description": "The name of the bank that the customer will need to
    /// make the bank transfer payment towards.",
    ///      "examples": [
    ///        "Mollie Bank"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "bankReason": {
    ///      "description": "A human-friendly description of the failure
    /// reason.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "bankReasonCode": {
    ///      "description": "The official reason why this payment has failed. A
    /// detailed description of each reason is available on the\nwebsite of the
    /// European Payments Council.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "batchReference": {
    ///      "description": "The batch reference you provided in the batch
    /// file.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "card3dsEci": {
    ///      "description": "The outcome of authentication attempted on
    /// transactions enforced by 3DS (ie valid only for oneoff and first).",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardAudition": {
    ///      "$ref":
    /// "#/components/schemas/payment-details-card-audition-response"
    ///    },
    ///    "cardBin": {
    ///      "description": "The first 6 digit of the card bank identification
    /// number.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardCountryCode": {
    ///      "description": "The ISO 3166-1 alpha-2 country code of the country
    /// the card was issued in.",
    ///      "examples": [
    ///        "NL"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardExpiryDate": {
    ///      "description": "The expiry date (MM/YY) of the card as displayed on
    /// the card.",
    ///      "examples": [
    ///        "12/25"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardFingerprint": {
    ///      "description": "A unique fingerprint for a specific card. Can be
    /// used to identify returning customers.\n\nIn the case of Point-of-sale
    /// payments, it's a unique identifier assigned to a cardholder's payment
    /// account,\nlinking multiple transactions from wallets and physical card
    /// to a single account, also across payment methods\nor when the card is
    /// reissued.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardFunding": {
    ///      "$ref":
    /// "#/components/schemas/payment-details-card-funding-response"
    ///    },
    ///    "cardHolder": {
    ///      "description": "The customer's name as shown on their card.",
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardIssuer": {
    ///      "description": "The issuer of the Card.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardLabel": {
    ///      "$ref": "#/components/schemas/payment-details-card-label-response"
    ///    },
    ///    "cardMaskedNumber": {
    ///      "description": "The first 6 and last 4 digits of the card number.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardNumber": {
    ///      "description": "For bancontact, it will be the customer's masked
    /// card number. For cards, it will be the last 4-digit of the\nPAN. For
    /// Point-of-sale, it will be the the last 4 digits of the customer's masked
    /// card number.",
    ///      "examples": [
    ///        "************1234"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardSecurity": {
    ///      "$ref":
    /// "#/components/schemas/payment-details-card-security-response"
    ///    },
    ///    "consumerAccount": {
    ///      "description": "The customer's account reference.\n\nFor
    /// banking-based payment methods — such as iDEAL — this is normally either
    /// an IBAN or a domestic bank account\nnumber.\n\nFor PayPal, the account
    /// reference is an email address.\n\nFor card and Bancontact payments,
    /// refer to details.cardNumber.",
    ///      "examples": [
    ///        "NL91ABNA0417164300"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "consumerBic": {
    ///      "description": "The BIC of the customer's bank account, if
    /// applicable.",
    ///      "examples": [
    ///        "ABNANL2A"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "consumerName": {
    ///      "description": "The customer's name, if made available by the
    /// payment method. For card payments, refer to details.cardHolder.",
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "creditorIdentifier": {
    ///      "description": "The creditor identifier indicates who is authorized to execute the payment. In this case, it is a\nreference to Mollie.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "customerReference": {
    ///      "description": "The paysafecard customer reference either provided
    /// via the API or otherwise auto-generated by Mollie.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "dueDate": {
    ///      "description": "Estimated date the payment is debited from the
    /// customer's bank account, in YYYY-MM-DD format.",
    ///      "examples": [
    ///        "2025-01-01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "date",
    ///      "x-methodSpecific": true
    ///    },
    ///    "endToEndIdentifier": {
    ///      "description": "The end-to-end identifier you provided in the batch
    /// file.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "failureMessage": {
    ///      "description": "A human-friendly failure message that can be shown
    /// to the customer. The message is translated in accordance\nwith the
    /// payment's locale setting.",
    ///      "examples": [
    ///        "Your card was declined."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "failureReason": {
    ///      "$ref":
    /// "#/components/schemas/payment-details-failure-reason-response"
    ///    },
    ///    "feeRegion": {
    ///      "$ref": "#/components/schemas/payment-details-fee-region-response"
    ///    },
    ///    "fileReference": {
    ///      "description": "The file reference you provided in the batch
    /// file.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "giftcards": {
    ///      "description": "An array of detail objects for each gift card that
    /// was used on this payment, if any.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "additionalProperties": true
    ///      },
    ///      "x-methodSpecific": true
    ///    },
    ///    "issuer": {
    ///      "description": "For payments with vouchers: the brand name of the
    /// first voucher applied.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "mandateReference": {
    ///      "description": "The mandate reference you provided in the batch
    /// file.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "maskedNumber": {
    ///      "description": "The first 6 digits & last 4 digits of the
    /// customer's masked card number.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "paypalFee": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "paypalPayerId": {
    ///      "description": "ID of the customer's PayPal account.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "paypalReference": {
    ///      "description": "PayPal's reference for the payment.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "qrCode": {
    ///      "description": "Optional include. If a QR code was requested during
    /// payment creation for a QR-compatible payment method,\nthe QR code
    /// details will be available in this object.\n\nThe QR code can be scanned
    /// by the customer to complete the payment on their mobile device. For
    /// example,\nBancontact QR payments can be completed by the customer using
    /// the Bancontact app.",
    ///      "type": "object",
    ///      "properties": {
    ///        "height": {
    ///          "description": "The height of the QR code image in pixels.",
    ///          "examples": [
    ///            300
    ///          ],
    ///          "type": "integer"
    ///        },
    ///        "src": {
    ///          "description": "The URL to the QR code image. The image is a PNG file, and can be displayed directly in the browser or\ndownloaded.",
    ///          "examples": [
    ///            "https://www.mollie.com/images/qr-code.png"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "width": {
    ///          "description": "The width of the QR code image in pixels.",
    ///          "examples": [
    ///            300
    ///          ],
    ///          "type": "integer"
    ///        }
    ///      },
    ///      "x-methodSpecific": true
    ///    },
    ///    "receipt": {
    ///      "description": "The Point of sale receipt object.",
    ///      "type": "object",
    ///      "properties": {
    ///        "applicationIdentifier": {
    ///          "description": "The unique number that identifies a specific
    /// payment application on a chip card.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "authorizationCode": {
    ///          "description": "A unique code provided by the cardholder’s bank
    /// to confirm that the transaction was successfully approved.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "cardReadMethod": {
    ///          "$ref":
    /// "#/components/schemas/payment-details-receipt-card-read-method-response"
    ///        },
    ///        "cardVerificationMethod": {
    ///          "$ref":
    /// "#/components/schemas/
    /// payment-details-receipt-card-verification-method-response"
    ///        }
    ///      },
    ///      "x-methodSpecific": true
    ///    },
    ///    "remainderAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "remainderDetails": {
    ///      "description": "Optional include. The full payment method details
    /// of the remainder payment.",
    ///      "type": "object",
    ///      "additionalProperties": true,
    ///      "x-methodSpecific": true
    ///    },
    ///    "remainderMethod": {
    ///      "description": "The payment method used to pay the remainder
    /// amount, after all gift cards or vouchers were applied.",
    ///      "examples": [
    ///        "creditcard"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "sellerProtection": {
    ///      "$ref":
    /// "#/components/schemas/payment-details-seller-protection-response"
    ///    },
    ///    "shippingAddress": {
    ///      "description": "For wallet payment methods — such as Apple Pay and
    /// PayPal — the shipping address is often already known by the\nwallet
    /// provider. In these cases the shipping address may be available as a
    /// payment detail.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "additionalProperties": true,
    ///      "x-methodSpecific": true
    ///    },
    ///    "signatureDate": {
    ///      "description": "Date the payment has been signed by the customer, in YYYY-MM-DD format. Only available if the payment\nhas been signed.",
    ///      "examples": [
    ///        "2024-03-20"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "date",
    ///      "x-methodSpecific": true
    ///    },
    ///    "terminalId": {
    ///      "description": "The ID of the terminal device where the payment
    /// took place on.",
    ///      "examples": [
    ///        "term_12345"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "transferReference": {
    ///      "description": "The Mollie-generated reference the customer needs
    /// to use when transfering the amount. Do not apply any\nformatting here;
    /// show it to the customer as-is.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "voucherNumber": {
    ///      "description": "For payments with gift cards: the masked gift card
    /// number of the first gift card applied to the payment.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "vouchers": {
    ///      "description": "An array of detail objects for each voucher that
    /// was used on this payment, if any.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "additionalProperties": true
    ///      },
    ///      "x-methodSpecific": true
    ///    },
    ///    "wallet": {
    ///      "$ref": "#/components/schemas/payment-details-wallet-response"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentResponseDetails {
        ///The bank account number the customer will need to make the bank
        /// transfer payment towards.
        #[serde(
            rename = "bankAccount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub bank_account: ::std::option::Option<::std::string::String>,
        ///The BIC of the bank the customer will need to make the bank transfer
        /// payment towards.
        #[serde(
            rename = "bankBic",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub bank_bic: ::std::option::Option<::std::string::String>,
        ///The name of the bank that the customer will need to make the bank
        /// transfer payment towards.
        #[serde(
            rename = "bankName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub bank_name: ::std::option::Option<::std::string::String>,
        ///A human-friendly description of the failure reason.
        #[serde(
            rename = "bankReason",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub bank_reason: ::std::option::Option<::std::string::String>,
        ///The official reason why this payment has failed. A detailed
        /// description of each reason is available on the website of
        /// the European Payments Council.
        #[serde(
            rename = "bankReasonCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub bank_reason_code: ::std::option::Option<::std::string::String>,
        ///The batch reference you provided in the batch file.
        #[serde(
            rename = "batchReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub batch_reference: ::std::option::Option<::std::string::String>,
        ///The outcome of authentication attempted on transactions enforced by
        /// 3DS (ie valid only for oneoff and first).
        #[serde(
            rename = "card3dsEci",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card3ds_eci: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cardAudition",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_audition: ::std::option::Option<PaymentDetailsCardAuditionResponse>,
        ///The first 6 digit of the card bank identification number.
        #[serde(
            rename = "cardBin",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_bin: ::std::option::Option<::std::string::String>,
        ///The ISO 3166-1 alpha-2 country code of the country the card was
        /// issued in.
        #[serde(
            rename = "cardCountryCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_country_code: ::std::option::Option<::std::string::String>,
        ///The expiry date (MM/YY) of the card as displayed on the card.
        #[serde(
            rename = "cardExpiryDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_expiry_date: ::std::option::Option<::std::string::String>,
        ///A unique fingerprint for a specific card. Can be used to identify
        /// returning customers.
        ///
        ///In the case of Point-of-sale payments, it's a unique identifier
        /// assigned to a cardholder's payment account, linking multiple
        /// transactions from wallets and physical card to a single account,
        /// also across payment methods or when the card is reissued.
        #[serde(
            rename = "cardFingerprint",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_fingerprint: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cardFunding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_funding: ::std::option::Option<PaymentDetailsCardFundingResponse>,
        ///The customer's name as shown on their card.
        #[serde(
            rename = "cardHolder",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_holder: ::std::option::Option<::std::string::String>,
        ///The issuer of the Card.
        #[serde(
            rename = "cardIssuer",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_issuer: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cardLabel",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_label: ::std::option::Option<PaymentDetailsCardLabelResponse>,
        ///The first 6 and last 4 digits of the card number.
        #[serde(
            rename = "cardMaskedNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_masked_number: ::std::option::Option<::std::string::String>,
        ///For bancontact, it will be the customer's masked card number. For
        /// cards, it will be the last 4-digit of the
        /// PAN. For Point-of-sale, it will be the the last 4 digits of the
        /// customer's masked card number.
        #[serde(
            rename = "cardNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_number: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cardSecurity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_security: ::std::option::Option<PaymentDetailsCardSecurityResponse>,
        ///The customer's account reference.
        ///
        ///For banking-based payment methods — such as iDEAL — this is normally
        /// either an IBAN or a domestic bank account number.
        ///
        ///For PayPal, the account reference is an email address.
        ///
        ///For card and Bancontact payments, refer to details.cardNumber.
        #[serde(
            rename = "consumerAccount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_account: ::std::option::Option<::std::string::String>,
        ///The BIC of the customer's bank account, if applicable.
        #[serde(
            rename = "consumerBic",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_bic: ::std::option::Option<::std::string::String>,
        ///The customer's name, if made available by the payment method. For
        /// card payments, refer to details.cardHolder.
        #[serde(
            rename = "consumerName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_name: ::std::option::Option<::std::string::String>,
        ///The creditor identifier indicates who is authorized to execute the
        /// payment. In this case, it is a reference to Mollie.
        #[serde(
            rename = "creditorIdentifier",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub creditor_identifier: ::std::option::Option<::std::string::String>,
        ///The paysafecard customer reference either provided via the API or
        /// otherwise auto-generated by Mollie.
        #[serde(
            rename = "customerReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub customer_reference: ::std::option::Option<::std::string::String>,
        ///Estimated date the payment is debited from the customer's bank
        /// account, in YYYY-MM-DD format.
        #[serde(
            rename = "dueDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub due_date: ::std::option::Option<::chrono::naive::NaiveDate>,
        ///The end-to-end identifier you provided in the batch file.
        #[serde(
            rename = "endToEndIdentifier",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub end_to_end_identifier: ::std::option::Option<::std::string::String>,
        ///A human-friendly failure message that can be shown to the customer.
        /// The message is translated in accordance with the payment's
        /// locale setting.
        #[serde(
            rename = "failureMessage",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub failure_message: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "failureReason",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub failure_reason: ::std::option::Option<PaymentDetailsFailureReasonResponse>,
        #[serde(
            rename = "feeRegion",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub fee_region: ::std::option::Option<PaymentDetailsFeeRegionResponse>,
        ///The file reference you provided in the batch file.
        #[serde(
            rename = "fileReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub file_reference: ::std::option::Option<::std::string::String>,
        ///An array of detail objects for each gift card that was used on this
        /// payment, if any.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub giftcards:
            ::std::vec::Vec<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        ///For payments with vouchers: the brand name of the first voucher
        /// applied.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub issuer: ::std::option::Option<::std::string::String>,
        ///The mandate reference you provided in the batch file.
        #[serde(
            rename = "mandateReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub mandate_reference: ::std::option::Option<::std::string::String>,
        ///The first 6 digits & last 4 digits of the customer's masked card
        /// number.
        #[serde(
            rename = "maskedNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub masked_number: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paypalFee",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paypal_fee: ::std::option::Option<AmountNullable>,
        ///ID of the customer's PayPal account.
        #[serde(
            rename = "paypalPayerId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paypal_payer_id: ::std::option::Option<::std::string::String>,
        ///PayPal's reference for the payment.
        #[serde(
            rename = "paypalReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paypal_reference: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "qrCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub qr_code: ::std::option::Option<EntityPaymentResponseDetailsQrCode>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub receipt: ::std::option::Option<EntityPaymentResponseDetailsReceipt>,
        #[serde(
            rename = "remainderAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub remainder_amount: ::std::option::Option<Amount>,
        ///Optional include. The full payment method details of the remainder
        /// payment.
        #[serde(
            rename = "remainderDetails",
            default,
            skip_serializing_if = "::serde_json::Map::is_empty"
        )]
        pub remainder_details: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        ///The payment method used to pay the remainder amount, after all gift
        /// cards or vouchers were applied.
        #[serde(
            rename = "remainderMethod",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub remainder_method: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "sellerProtection",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub seller_protection: ::std::option::Option<PaymentDetailsSellerProtectionResponse>,
        ///For wallet payment methods — such as Apple Pay and PayPal — the
        /// shipping address is often already known by the
        /// wallet provider. In these cases the shipping address may be
        /// available as a payment detail.
        #[serde(
            rename = "shippingAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub shipping_address:
            ::std::option::Option<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        ///Date the payment has been signed by the customer, in YYYY-MM-DD
        /// format. Only available if the payment has been signed.
        #[serde(
            rename = "signatureDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub signature_date: ::std::option::Option<::chrono::naive::NaiveDate>,
        ///The ID of the terminal device where the payment took place on.
        #[serde(
            rename = "terminalId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub terminal_id: ::std::option::Option<::std::string::String>,
        ///The Mollie-generated reference the customer needs to use when
        /// transfering the amount. Do not apply any formatting here;
        /// show it to the customer as-is.
        #[serde(
            rename = "transferReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub transfer_reference: ::std::option::Option<::std::string::String>,
        ///For payments with gift cards: the masked gift card number of the
        /// first gift card applied to the payment.
        #[serde(
            rename = "voucherNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub voucher_number: ::std::option::Option<::std::string::String>,
        ///An array of detail objects for each voucher that was used on this
        /// payment, if any.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub vouchers:
            ::std::vec::Vec<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub wallet: ::std::option::Option<PaymentDetailsWalletResponse>,
    }

    impl ::std::convert::From<&EntityPaymentResponseDetails> for EntityPaymentResponseDetails {
        fn from(value: &EntityPaymentResponseDetails) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityPaymentResponseDetails {
        fn default() -> Self {
            Self {
                bank_account: Default::default(),
                bank_bic: Default::default(),
                bank_name: Default::default(),
                bank_reason: Default::default(),
                bank_reason_code: Default::default(),
                batch_reference: Default::default(),
                card3ds_eci: Default::default(),
                card_audition: Default::default(),
                card_bin: Default::default(),
                card_country_code: Default::default(),
                card_expiry_date: Default::default(),
                card_fingerprint: Default::default(),
                card_funding: Default::default(),
                card_holder: Default::default(),
                card_issuer: Default::default(),
                card_label: Default::default(),
                card_masked_number: Default::default(),
                card_number: Default::default(),
                card_security: Default::default(),
                consumer_account: Default::default(),
                consumer_bic: Default::default(),
                consumer_name: Default::default(),
                creditor_identifier: Default::default(),
                customer_reference: Default::default(),
                due_date: Default::default(),
                end_to_end_identifier: Default::default(),
                failure_message: Default::default(),
                failure_reason: Default::default(),
                fee_region: Default::default(),
                file_reference: Default::default(),
                giftcards: Default::default(),
                issuer: Default::default(),
                mandate_reference: Default::default(),
                masked_number: Default::default(),
                paypal_fee: Default::default(),
                paypal_payer_id: Default::default(),
                paypal_reference: Default::default(),
                qr_code: Default::default(),
                receipt: Default::default(),
                remainder_amount: Default::default(),
                remainder_details: Default::default(),
                remainder_method: Default::default(),
                seller_protection: Default::default(),
                shipping_address: Default::default(),
                signature_date: Default::default(),
                terminal_id: Default::default(),
                transfer_reference: Default::default(),
                voucher_number: Default::default(),
                vouchers: Default::default(),
                wallet: Default::default(),
            }
        }
    }

    ///Optional include. If a QR code was requested during payment creation for
    /// a QR-compatible payment method, the QR code details will be
    /// available in this object.
    ///
    ///The QR code can be scanned by the customer to complete the payment on
    /// their mobile device. For example, Bancontact QR payments can be
    /// completed by the customer using the Bancontact app.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Optional include. If a QR code was requested during
    /// payment creation for a QR-compatible payment method,\nthe QR code
    /// details will be available in this object.\n\nThe QR code can be scanned
    /// by the customer to complete the payment on their mobile device. For
    /// example,\nBancontact QR payments can be completed by the customer using
    /// the Bancontact app.",
    ///  "type": "object",
    ///  "properties": {
    ///    "height": {
    ///      "description": "The height of the QR code image in pixels.",
    ///      "examples": [
    ///        300
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "src": {
    ///      "description": "The URL to the QR code image. The image is a PNG
    /// file, and can be displayed directly in the browser or\ndownloaded.",
    ///      "examples": [
    ///        "https://www.mollie.com/images/qr-code.png"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "width": {
    ///      "description": "The width of the QR code image in pixels.",
    ///      "examples": [
    ///        300
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  },
    ///  "x-methodSpecific": true
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentResponseDetailsQrCode {
        ///The height of the QR code image in pixels.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub height: ::std::option::Option<i64>,
        ///The URL to the QR code image. The image is a PNG file, and can be
        /// displayed directly in the browser or downloaded.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub src: ::std::option::Option<::std::string::String>,
        ///The width of the QR code image in pixels.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub width: ::std::option::Option<i64>,
    }

    impl ::std::convert::From<&EntityPaymentResponseDetailsQrCode>
        for EntityPaymentResponseDetailsQrCode
    {
        fn from(value: &EntityPaymentResponseDetailsQrCode) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityPaymentResponseDetailsQrCode {
        fn default() -> Self {
            Self {
                height: Default::default(),
                src: Default::default(),
                width: Default::default(),
            }
        }
    }

    ///The Point of sale receipt object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The Point of sale receipt object.",
    ///  "type": "object",
    ///  "properties": {
    ///    "applicationIdentifier": {
    ///      "description": "The unique number that identifies a specific
    /// payment application on a chip card.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "authorizationCode": {
    ///      "description": "A unique code provided by the cardholder’s bank to
    /// confirm that the transaction was successfully approved.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "cardReadMethod": {
    ///      "$ref":
    /// "#/components/schemas/payment-details-receipt-card-read-method-response"
    ///    },
    ///    "cardVerificationMethod": {
    ///      "$ref":
    /// "#/components/schemas/
    /// payment-details-receipt-card-verification-method-response"
    ///    }
    ///  },
    ///  "x-methodSpecific": true
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentResponseDetailsReceipt {
        ///The unique number that identifies a specific payment application on
        /// a chip card.
        #[serde(
            rename = "applicationIdentifier",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub application_identifier: ::std::option::Option<::std::string::String>,
        ///A unique code provided by the cardholder’s bank to confirm that the
        /// transaction was successfully approved.
        #[serde(
            rename = "authorizationCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub authorization_code: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cardReadMethod",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_read_method: ::std::option::Option<PaymentDetailsReceiptCardReadMethodResponse>,
        #[serde(
            rename = "cardVerificationMethod",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_verification_method:
            ::std::option::Option<PaymentDetailsReceiptCardVerificationMethodResponse>,
    }

    impl ::std::convert::From<&EntityPaymentResponseDetailsReceipt>
        for EntityPaymentResponseDetailsReceipt
    {
        fn from(value: &EntityPaymentResponseDetailsReceipt) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityPaymentResponseDetailsReceipt {
        fn default() -> Self {
            Self {
                application_identifier: Default::default(),
                authorization_code: Default::default(),
                card_read_method: Default::default(),
                card_verification_method: Default::default(),
            }
        }
    }

    ///`EntityPaymentResponseLinesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/payment-line-item-response"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "recurring": {
    ///          "$ref": "#/components/schemas/recurring-line-item"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentResponseLinesItem {
        ///An array with the voucher categories, in case of a line eligible for
        /// a voucher. See the [Integrating Vouchers](https://docs.mollie.com/docs/integrating-vouchers/) guide for more information.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub categories: ::std::vec::Vec<LineCategoriesResponse>,
        ///A description of the line item. For example *LEGO 4440 Forest Police
        /// Station*.
        pub description: ::std::string::String,
        #[serde(
            rename = "discountAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub discount_amount: ::std::option::Option<Amount>,
        ///A link pointing to an image of the product sold.
        #[serde(
            rename = "imageUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub image_url: ::std::option::Option<::std::string::String>,
        ///A link pointing to the product page in your web shop of the product
        /// sold.
        #[serde(
            rename = "productUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub product_url: ::std::option::Option<::std::string::String>,
        ///The number of items.
        pub quantity: ::std::num::NonZeroU64,
        ///The unit for the quantity. For example *pcs*, *kg*, or *cm*.
        #[serde(
            rename = "quantityUnit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub quantity_unit: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub recurring: ::std::option::Option<RecurringLineItem>,
        ///The SKU, EAN, ISBN or UPC of the product sold.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sku: ::std::option::Option<EntityPaymentResponseLinesItemSku>,
        #[serde(rename = "totalAmount")]
        pub total_amount: Amount,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<PaymentLineTypeResponse>,
        #[serde(rename = "unitPrice")]
        pub unit_price: Amount,
        #[serde(
            rename = "vatAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_amount: ::std::option::Option<Amount>,
        ///The VAT rate applied to the line, for example `21.00` for 21%. The
        /// vatRate should be passed as a string and not as a float, to
        /// ensure the correct number of decimals are passed.
        #[serde(
            rename = "vatRate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_rate: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityPaymentResponseLinesItem> for EntityPaymentResponseLinesItem {
        fn from(value: &EntityPaymentResponseLinesItem) -> Self {
            value.clone()
        }
    }

    ///The SKU, EAN, ISBN or UPC of the product sold.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The SKU, EAN, ISBN or UPC of the product sold.",
    ///  "examples": [
    ///    "9780241661628"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 64
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityPaymentResponseLinesItemSku(::std::string::String);
    impl ::std::ops::Deref for EntityPaymentResponseLinesItemSku {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityPaymentResponseLinesItemSku> for ::std::string::String {
        fn from(value: EntityPaymentResponseLinesItemSku) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityPaymentResponseLinesItemSku>
        for EntityPaymentResponseLinesItemSku
    {
        fn from(value: &EntityPaymentResponseLinesItemSku) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityPaymentResponseLinesItemSku {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 64usize {
                return Err("longer than 64 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityPaymentResponseLinesItemSku {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityPaymentResponseLinesItemSku {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityPaymentResponseLinesItemSku {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityPaymentResponseLinesItemSku {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "dashboard",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "captures": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "changePaymentState": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "chargebacks": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "checkout": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "customer": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "dashboard": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "mandate": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "mobileAppCheckout": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "order": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "payOnline": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "refunds": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "settlement": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "subscription": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "terminal": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentResponseLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub captures: ::std::option::Option<Url>,
        #[serde(
            rename = "changePaymentState",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub change_payment_state: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chargebacks: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub checkout: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub customer: ::std::option::Option<Url>,
        pub dashboard: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mandate: ::std::option::Option<Url>,
        #[serde(
            rename = "mobileAppCheckout",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub mobile_app_checkout: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub order: ::std::option::Option<Url>,
        #[serde(
            rename = "payOnline",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub pay_online: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub refunds: ::std::option::Option<Url>,
        #[serde(rename = "self")]
        pub self_: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub settlement: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub subscription: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub terminal: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&EntityPaymentResponseLinks> for EntityPaymentResponseLinks {
        fn from(value: &EntityPaymentResponseLinks) -> Self {
            value.clone()
        }
    }

    ///`EntityPaymentRoute`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_links",
    ///    "amount",
    ///    "createdAt",
    ///    "destination",
    ///    "id",
    ///    "mode",
    ///    "resource"
    ///  ],
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "type": "object",
    ///      "required": [
    ///        "payment",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "payment": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "createdAt": {
    ///      "description": "The date and time when the route was created. The
    /// date is given in ISO 8601 format.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-12-12T10:00:00Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "destination": {
    ///      "description": "The destination of this portion of the payment.",
    ///      "type": "object",
    ///      "required": [
    ///        "organizationId",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "organizationId": {
    ///          "$ref": "#/components/schemas/organizationToken"
    ///        },
    ///        "type": {
    ///          "$ref": "#/components/schemas/route-destination-type"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/routeToken"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "releaseDate": {
    ///      "description": "Optionally, schedule this portion of the payment to be transferred to its destination on a later date. The\ndate must be given in `YYYY-MM-DD` format.\n\nIf no date is given, the funds become available to the connected merchant as soon as the payment succeeds.",
    ///      "examples": [
    ///        "2024-12-12"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a route object.
    /// Will always contain the string `route` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "route"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentRoute {
        pub amount: Amount,
        ///The date and time when the route was created. The date is given in
        /// ISO 8601 format.
        #[serde(rename = "createdAt")]
        pub created_at: ::std::string::String,
        pub destination: EntityPaymentRouteDestination,
        pub id: RouteToken,
        #[serde(rename = "_links")]
        pub links: EntityPaymentRouteLinks,
        pub mode: Mode,
        ///Optionally, schedule this portion of the payment to be transferred
        /// to its destination on a later date. The date must be given
        /// in `YYYY-MM-DD` format.
        ///
        ///If no date is given, the funds become available to the connected
        /// merchant as soon as the payment succeeds.
        #[serde(
            rename = "releaseDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub release_date: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a route object. Will always contain
        /// the string `route` for this endpoint.
        pub resource: ::std::string::String,
    }

    impl ::std::convert::From<&EntityPaymentRoute> for EntityPaymentRoute {
        fn from(value: &EntityPaymentRoute) -> Self {
            value.clone()
        }
    }

    ///The destination of this portion of the payment.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The destination of this portion of the payment.",
    ///  "type": "object",
    ///  "required": [
    ///    "organizationId",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "organizationId": {
    ///      "$ref": "#/components/schemas/organizationToken"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/route-destination-type"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentRouteDestination {
        #[serde(rename = "organizationId")]
        pub organization_id: OrganizationToken,
        #[serde(rename = "type")]
        pub type_: RouteDestinationType,
    }

    impl ::std::convert::From<&EntityPaymentRouteDestination> for EntityPaymentRouteDestination {
        fn from(value: &EntityPaymentRouteDestination) -> Self {
            value.clone()
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "type": "object",
    ///  "required": [
    ///    "payment",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "payment": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentRouteLinks {
        pub payment: Url,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&EntityPaymentRouteLinks> for EntityPaymentRouteLinks {
        fn from(value: &EntityPaymentRouteLinks) -> Self {
            value.clone()
        }
    }

    ///`EntityPaymentRouteResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_links",
    ///    "amount",
    ///    "createdAt",
    ///    "destination",
    ///    "id",
    ///    "mode",
    ///    "resource"
    ///  ],
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "type": "object",
    ///      "required": [
    ///        "payment",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "payment": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "createdAt": {
    ///      "description": "The date and time when the route was created. The
    /// date is given in ISO 8601 format.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-12-12T10:00:00Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "destination": {
    ///      "description": "The destination of this portion of the payment.",
    ///      "type": "object",
    ///      "required": [
    ///        "organizationId",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "organizationId": {
    ///          "$ref": "#/components/schemas/organizationToken"
    ///        },
    ///        "type": {
    ///          "$ref": "#/components/schemas/route-destination-type-response"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/routeToken"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "releaseDate": {
    ///      "description": "Optionally, schedule this portion of the payment to be transferred to its destination on a later date. The\ndate must be given in `YYYY-MM-DD` format.\n\nIf no date is given, the funds become available to the connected merchant as soon as the payment succeeds.",
    ///      "examples": [
    ///        "2024-12-12"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a route object.
    /// Will always contain the string `route` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "route"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentRouteResponse {
        pub amount: Amount,
        ///The date and time when the route was created. The date is given in
        /// ISO 8601 format.
        #[serde(rename = "createdAt")]
        pub created_at: ::std::string::String,
        pub destination: EntityPaymentRouteResponseDestination,
        pub id: RouteToken,
        #[serde(rename = "_links")]
        pub links: EntityPaymentRouteResponseLinks,
        pub mode: Mode,
        ///Optionally, schedule this portion of the payment to be transferred
        /// to its destination on a later date. The date must be given
        /// in `YYYY-MM-DD` format.
        ///
        ///If no date is given, the funds become available to the connected
        /// merchant as soon as the payment succeeds.
        #[serde(
            rename = "releaseDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub release_date: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a route object. Will always contain
        /// the string `route` for this endpoint.
        pub resource: ::std::string::String,
    }

    impl ::std::convert::From<&EntityPaymentRouteResponse> for EntityPaymentRouteResponse {
        fn from(value: &EntityPaymentRouteResponse) -> Self {
            value.clone()
        }
    }

    ///The destination of this portion of the payment.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The destination of this portion of the payment.",
    ///  "type": "object",
    ///  "required": [
    ///    "organizationId",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "organizationId": {
    ///      "$ref": "#/components/schemas/organizationToken"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/route-destination-type-response"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentRouteResponseDestination {
        #[serde(rename = "organizationId")]
        pub organization_id: OrganizationToken,
        #[serde(rename = "type")]
        pub type_: RouteDestinationTypeResponse,
    }

    impl ::std::convert::From<&EntityPaymentRouteResponseDestination>
        for EntityPaymentRouteResponseDestination
    {
        fn from(value: &EntityPaymentRouteResponseDestination) -> Self {
            value.clone()
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "type": "object",
    ///  "required": [
    ///    "payment",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "payment": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPaymentRouteResponseLinks {
        pub payment: Url,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&EntityPaymentRouteResponseLinks> for EntityPaymentRouteResponseLinks {
        fn from(value: &EntityPaymentRouteResponseLinks) -> Self {
            value.clone()
        }
    }

    ///`EntityPermission`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "description": {
    ///      "description": "A short description of what kind of access the
    /// permission enables.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "View your payments"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "granted": {
    ///      "description": "Whether this permission is granted to the app by
    /// the organization.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/permissionToken"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a permission
    /// object. Will always contain the string `permission` for
    /// this\nendpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "permission"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPermission {
        ///A short description of what kind of access the permission enables.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        ///Whether this permission is granted to the app by the organization.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub granted: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<PermissionToken>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityPermissionLinks>,
        ///Indicates the response contains a permission object. Will always
        /// contain the string `permission` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityPermission> for EntityPermission {
        fn from(value: &EntityPermission) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityPermission {
        fn default() -> Self {
            Self {
                description: Default::default(),
                granted: Default::default(),
                id: Default::default(),
                links: Default::default(),
                resource: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityPermissionLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&EntityPermissionLinks> for EntityPermissionLinks {
        fn from(value: &EntityPermissionLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityPermissionLinks {
        fn default() -> Self {
            Self {
                documentation: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///`EntityProfile`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        {
    ///          "chargebacks": {
    ///            "href": "https://api.mollie.com/v2/chargebacks?profileId=pfl_2q3RyuMGry",
    ///            "type": "application/json"
    ///          },
    ///          "checkoutPreviewUrl": {
    ///            "href": "https://www.mollie.com/checkout/preview/pfl_2q3RyuMGry",
    ///            "type": "text/html"
    ///          },
    ///          "dashboard": {
    ///            "href": "https://www.mollie.com/dashboard/org_7049691/settings/profiles/pfl_2q3RyuMGry",
    ///            "type": "text/html"
    ///          },
    ///          "documentation": {
    ///            "href": "...",
    ///            "type": "text/html"
    ///          },
    ///          "methods": {
    ///            "href": "https://api.mollie.com/v2/methods?profileId=pfl_2q3RyuMGry",
    ///            "type": "application/json"
    ///          },
    ///          "payments": {
    ///            "href": "https://api.mollie.com/v2/payments?profileId=pfl_2q3RyuMGry",
    ///            "type": "application/json"
    ///          },
    ///          "refunds": {
    ///            "href": "https://api.mollie.com/v2/refunds?profileId=pfl_2q3RyuMGry",
    ///            "type": "application/json"
    ///          },
    ///          "self": {
    ///            "href": "...",
    ///            "type": "application/json"
    ///          }
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "properties": {
    ///        "chargebacks": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "checkoutPreviewUrl": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "dashboard": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "methods": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "payments": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "refunds": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "businessCategory": {
    ///      "description": "The industry associated with the profile's trade name or brand. Please refer to the\n[business category list](common-data-types#business-category) for all possible options.",
    ///      "examples": [
    ///        "OTHER_MERCHANDISE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "countriesOfActivity": {
    ///      "description": "A list of countries where you expect that the majority of the profile's customers reside,\nin [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.",
    ///      "examples": [
    ///        [
    ///          "NL",
    ///          "GB"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "description": {
    ///      "description": "The products or services offered by the profile's
    /// website or application.",
    ///      "examples": [
    ///        "My website description"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 500
    ///    },
    ///    "email": {
    ///      "description": "The email address associated with the profile's
    /// trade name or brand.",
    ///      "examples": [
    ///        "test@mollie.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "The identifier uniquely referring to this profile.
    /// Example: `pfl_v9hTwCvYqw`.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "pfl_QkEhN94Ba"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "name": {
    ///      "description": "The profile's name, this will usually reflect the
    /// trade name or brand name of the profile's website or\napplication.",
    ///      "examples": [
    ///        "My website name"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "phone": {
    ///      "description": "The phone number associated with the profile's
    /// trade name or brand.",
    ///      "examples": [
    ///        "+31208202070"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a profile object.
    /// Will always contain the string `profile` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "profile"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "review": {
    ///      "description": "Present if changes have been made that have not yet
    /// been approved by Mollie. Changes to test profiles are
    /// approved\nautomatically, unless a switch to a live profile has been
    /// requested. The review object will therefore usually be\n`null` in test
    /// mode.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        {
    ///          "status": "pending"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "properties": {
    ///        "status": {
    ///          "$ref": "#/components/schemas/profile-review-status"
    ///        }
    ///      }
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/profile-status"
    ///    },
    ///    "website": {
    ///      "description": "The URL to the profile's website or application. Only `https` or `http` URLs are allowed. No `@` signs are\nallowed.",
    ///      "examples": [
    ///        "https://example.com"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityProfile {
        ///The industry associated with the profile's trade name or brand.
        /// Please refer to the [business category
        /// list](common-data-types#business-category) for all possible options.
        #[serde(
            rename = "businessCategory",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub business_category: ::std::option::Option<::std::string::String>,
        ///A list of countries where you expect that the majority of the
        /// profile's customers reside, in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
        #[serde(
            rename = "countriesOfActivity",
            default,
            skip_serializing_if = "::std::vec::Vec::is_empty"
        )]
        pub countries_of_activity: ::std::vec::Vec<::std::string::String>,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        ///The products or services offered by the profile's website or
        /// application.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<EntityProfileDescription>,
        ///The email address associated with the profile's trade name or brand.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        ///The identifier uniquely referring to this profile. Example:
        /// `pfl_v9hTwCvYqw`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityProfileLinks>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<Mode>,
        ///The profile's name, this will usually reflect the trade name or
        /// brand name of the profile's website or application.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///The phone number associated with the profile's trade name or brand.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub phone: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a profile object. Will always
        /// contain the string `profile` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub review: ::std::option::Option<EntityProfileReview>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<ProfileStatus>,
        ///The URL to the profile's website or application. Only `https` or
        /// `http` URLs are allowed. No `@` signs are allowed.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub website: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityProfile> for EntityProfile {
        fn from(value: &EntityProfile) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityProfile {
        fn default() -> Self {
            Self {
                business_category: Default::default(),
                countries_of_activity: Default::default(),
                created_at: Default::default(),
                description: Default::default(),
                email: Default::default(),
                id: Default::default(),
                links: Default::default(),
                mode: Default::default(),
                name: Default::default(),
                phone: Default::default(),
                resource: Default::default(),
                review: Default::default(),
                status: Default::default(),
                website: Default::default(),
            }
        }
    }

    ///The products or services offered by the profile's website or
    /// application.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The products or services offered by the profile's
    /// website or application.",
    ///  "examples": [
    ///    "My website description"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 500
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityProfileDescription(::std::string::String);
    impl ::std::ops::Deref for EntityProfileDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityProfileDescription> for ::std::string::String {
        fn from(value: EntityProfileDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityProfileDescription> for EntityProfileDescription {
        fn from(value: &EntityProfileDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityProfileDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 500usize {
                return Err("longer than 500 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityProfileDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityProfileDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityProfileDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityProfileDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "examples": [
    ///    {
    ///      "chargebacks": {
    ///        "href": "https://api.mollie.com/v2/chargebacks?profileId=pfl_2q3RyuMGry",
    ///        "type": "application/json"
    ///      },
    ///      "checkoutPreviewUrl": {
    ///        "href": "https://www.mollie.com/checkout/preview/pfl_2q3RyuMGry",
    ///        "type": "text/html"
    ///      },
    ///      "dashboard": {
    ///        "href": "https://www.mollie.com/dashboard/org_7049691/settings/profiles/pfl_2q3RyuMGry",
    ///        "type": "text/html"
    ///      },
    ///      "documentation": {
    ///        "href": "...",
    ///        "type": "text/html"
    ///      },
    ///      "methods": {
    ///        "href": "https://api.mollie.com/v2/methods?profileId=pfl_2q3RyuMGry",
    ///        "type": "application/json"
    ///      },
    ///      "payments": {
    ///        "href": "https://api.mollie.com/v2/payments?profileId=pfl_2q3RyuMGry",
    ///        "type": "application/json"
    ///      },
    ///      "refunds": {
    ///        "href": "https://api.mollie.com/v2/refunds?profileId=pfl_2q3RyuMGry",
    ///        "type": "application/json"
    ///      },
    ///      "self": {
    ///        "href": "...",
    ///        "type": "application/json"
    ///      }
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "chargebacks": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "checkoutPreviewUrl": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "dashboard": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "methods": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "payments": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "refunds": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityProfileLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chargebacks: ::std::option::Option<Url>,
        #[serde(
            rename = "checkoutPreviewUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub checkout_preview_url: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub dashboard: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub methods: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payments: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub refunds: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&EntityProfileLinks> for EntityProfileLinks {
        fn from(value: &EntityProfileLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityProfileLinks {
        fn default() -> Self {
            Self {
                chargebacks: Default::default(),
                checkout_preview_url: Default::default(),
                dashboard: Default::default(),
                documentation: Default::default(),
                methods: Default::default(),
                payments: Default::default(),
                refunds: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///`EntityProfileResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        {
    ///          "chargebacks": {
    ///            "href": "https://api.mollie.com/v2/chargebacks?profileId=pfl_2q3RyuMGry",
    ///            "type": "application/json"
    ///          },
    ///          "checkoutPreviewUrl": {
    ///            "href": "https://www.mollie.com/checkout/preview/pfl_2q3RyuMGry",
    ///            "type": "text/html"
    ///          },
    ///          "dashboard": {
    ///            "href": "https://www.mollie.com/dashboard/org_7049691/settings/profiles/pfl_2q3RyuMGry",
    ///            "type": "text/html"
    ///          },
    ///          "documentation": {
    ///            "href": "...",
    ///            "type": "text/html"
    ///          },
    ///          "methods": {
    ///            "href": "https://api.mollie.com/v2/methods?profileId=pfl_2q3RyuMGry",
    ///            "type": "application/json"
    ///          },
    ///          "payments": {
    ///            "href": "https://api.mollie.com/v2/payments?profileId=pfl_2q3RyuMGry",
    ///            "type": "application/json"
    ///          },
    ///          "refunds": {
    ///            "href": "https://api.mollie.com/v2/refunds?profileId=pfl_2q3RyuMGry",
    ///            "type": "application/json"
    ///          },
    ///          "self": {
    ///            "href": "...",
    ///            "type": "application/json"
    ///          }
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "properties": {
    ///        "chargebacks": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "checkoutPreviewUrl": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "dashboard": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "methods": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "payments": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "refunds": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "businessCategory": {
    ///      "description": "The industry associated with the profile's trade name or brand. Please refer to the\n[business category list](common-data-types#business-category) for all possible options.",
    ///      "examples": [
    ///        "OTHER_MERCHANDISE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "countriesOfActivity": {
    ///      "description": "A list of countries where you expect that the majority of the profile's customers reside,\nin [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.",
    ///      "examples": [
    ///        [
    ///          "NL",
    ///          "GB"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "description": {
    ///      "description": "The products or services offered by the profile's
    /// website or application.",
    ///      "examples": [
    ///        "My website description"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 500
    ///    },
    ///    "email": {
    ///      "description": "The email address associated with the profile's
    /// trade name or brand.",
    ///      "examples": [
    ///        "test@mollie.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "The identifier uniquely referring to this profile.
    /// Example: `pfl_v9hTwCvYqw`.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "pfl_QkEhN94Ba"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "name": {
    ///      "description": "The profile's name, this will usually reflect the
    /// trade name or brand name of the profile's website or\napplication.",
    ///      "examples": [
    ///        "My website name"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "phone": {
    ///      "description": "The phone number associated with the profile's
    /// trade name or brand.",
    ///      "examples": [
    ///        "+31208202070"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a profile object.
    /// Will always contain the string `profile` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "profile"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "review": {
    ///      "description": "Present if changes have been made that have not yet
    /// been approved by Mollie. Changes to test profiles are
    /// approved\nautomatically, unless a switch to a live profile has been
    /// requested. The review object will therefore usually be\n`null` in test
    /// mode.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        {
    ///          "status": "pending"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "properties": {
    ///        "status": {
    ///          "$ref": "#/components/schemas/profile-review-status-response"
    ///        }
    ///      }
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/profile-status"
    ///    },
    ///    "website": {
    ///      "description": "The URL to the profile's website or application. Only `https` or `http` URLs are allowed. No `@` signs are\nallowed.",
    ///      "examples": [
    ///        "https://example.com"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityProfileResponse {
        ///The industry associated with the profile's trade name or brand.
        /// Please refer to the [business category
        /// list](common-data-types#business-category) for all possible options.
        #[serde(
            rename = "businessCategory",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub business_category: ::std::option::Option<::std::string::String>,
        ///A list of countries where you expect that the majority of the
        /// profile's customers reside, in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
        #[serde(
            rename = "countriesOfActivity",
            default,
            skip_serializing_if = "::std::vec::Vec::is_empty"
        )]
        pub countries_of_activity: ::std::vec::Vec<::std::string::String>,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        ///The products or services offered by the profile's website or
        /// application.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<EntityProfileResponseDescription>,
        ///The email address associated with the profile's trade name or brand.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        ///The identifier uniquely referring to this profile. Example:
        /// `pfl_v9hTwCvYqw`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityProfileResponseLinks>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<Mode>,
        ///The profile's name, this will usually reflect the trade name or
        /// brand name of the profile's website or application.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///The phone number associated with the profile's trade name or brand.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub phone: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a profile object. Will always
        /// contain the string `profile` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub review: ::std::option::Option<EntityProfileResponseReview>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<ProfileStatus>,
        ///The URL to the profile's website or application. Only `https` or
        /// `http` URLs are allowed. No `@` signs are allowed.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub website: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntityProfileResponse> for EntityProfileResponse {
        fn from(value: &EntityProfileResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityProfileResponse {
        fn default() -> Self {
            Self {
                business_category: Default::default(),
                countries_of_activity: Default::default(),
                created_at: Default::default(),
                description: Default::default(),
                email: Default::default(),
                id: Default::default(),
                links: Default::default(),
                mode: Default::default(),
                name: Default::default(),
                phone: Default::default(),
                resource: Default::default(),
                review: Default::default(),
                status: Default::default(),
                website: Default::default(),
            }
        }
    }

    ///The products or services offered by the profile's website or
    /// application.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The products or services offered by the profile's
    /// website or application.",
    ///  "examples": [
    ///    "My website description"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 500
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityProfileResponseDescription(::std::string::String);
    impl ::std::ops::Deref for EntityProfileResponseDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityProfileResponseDescription> for ::std::string::String {
        fn from(value: EntityProfileResponseDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityProfileResponseDescription> for EntityProfileResponseDescription {
        fn from(value: &EntityProfileResponseDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityProfileResponseDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 500usize {
                return Err("longer than 500 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityProfileResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityProfileResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityProfileResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityProfileResponseDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "examples": [
    ///    {
    ///      "chargebacks": {
    ///        "href": "https://api.mollie.com/v2/chargebacks?profileId=pfl_2q3RyuMGry",
    ///        "type": "application/json"
    ///      },
    ///      "checkoutPreviewUrl": {
    ///        "href": "https://www.mollie.com/checkout/preview/pfl_2q3RyuMGry",
    ///        "type": "text/html"
    ///      },
    ///      "dashboard": {
    ///        "href": "https://www.mollie.com/dashboard/org_7049691/settings/profiles/pfl_2q3RyuMGry",
    ///        "type": "text/html"
    ///      },
    ///      "documentation": {
    ///        "href": "...",
    ///        "type": "text/html"
    ///      },
    ///      "methods": {
    ///        "href": "https://api.mollie.com/v2/methods?profileId=pfl_2q3RyuMGry",
    ///        "type": "application/json"
    ///      },
    ///      "payments": {
    ///        "href": "https://api.mollie.com/v2/payments?profileId=pfl_2q3RyuMGry",
    ///        "type": "application/json"
    ///      },
    ///      "refunds": {
    ///        "href": "https://api.mollie.com/v2/refunds?profileId=pfl_2q3RyuMGry",
    ///        "type": "application/json"
    ///      },
    ///      "self": {
    ///        "href": "...",
    ///        "type": "application/json"
    ///      }
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "chargebacks": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "checkoutPreviewUrl": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "dashboard": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "methods": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "payments": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "refunds": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityProfileResponseLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chargebacks: ::std::option::Option<Url>,
        #[serde(
            rename = "checkoutPreviewUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub checkout_preview_url: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub dashboard: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub methods: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payments: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub refunds: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&EntityProfileResponseLinks> for EntityProfileResponseLinks {
        fn from(value: &EntityProfileResponseLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityProfileResponseLinks {
        fn default() -> Self {
            Self {
                chargebacks: Default::default(),
                checkout_preview_url: Default::default(),
                dashboard: Default::default(),
                documentation: Default::default(),
                methods: Default::default(),
                payments: Default::default(),
                refunds: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///Present if changes have been made that have not yet been approved by
    /// Mollie. Changes to test profiles are approved automatically, unless
    /// a switch to a live profile has been requested. The review object will
    /// therefore usually be `null` in test mode.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Present if changes have been made that have not yet
    /// been approved by Mollie. Changes to test profiles are
    /// approved\nautomatically, unless a switch to a live profile has been
    /// requested. The review object will therefore usually be\n`null` in test
    /// mode.",
    ///  "readOnly": true,
    ///  "examples": [
    ///    {
    ///      "status": "pending"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "status": {
    ///      "$ref": "#/components/schemas/profile-review-status-response"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityProfileResponseReview {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<ProfileReviewStatusResponse>,
    }

    impl ::std::convert::From<&EntityProfileResponseReview> for EntityProfileResponseReview {
        fn from(value: &EntityProfileResponseReview) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityProfileResponseReview {
        fn default() -> Self {
            Self {
                status: Default::default(),
            }
        }
    }

    ///Present if changes have been made that have not yet been approved by
    /// Mollie. Changes to test profiles are approved automatically, unless
    /// a switch to a live profile has been requested. The review object will
    /// therefore usually be `null` in test mode.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Present if changes have been made that have not yet
    /// been approved by Mollie. Changes to test profiles are
    /// approved\nautomatically, unless a switch to a live profile has been
    /// requested. The review object will therefore usually be\n`null` in test
    /// mode.",
    ///  "readOnly": true,
    ///  "examples": [
    ///    {
    ///      "status": "pending"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "status": {
    ///      "$ref": "#/components/schemas/profile-review-status"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityProfileReview {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<ProfileReviewStatus>,
    }

    impl ::std::convert::From<&EntityProfileReview> for EntityProfileReview {
        fn from(value: &EntityProfileReview) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityProfileReview {
        fn default() -> Self {
            Self {
                status: Default::default(),
            }
        }
    }

    ///`EntityRefund`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_links",
    ///    "amount",
    ///    "createdAt",
    ///    "description",
    ///    "id",
    ///    "metadata",
    ///    "mode",
    ///    "resource",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "documentation",
    ///        "payment",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "payment": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "settlement": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        }
    ///      }
    ///    },
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "description": {
    ///      "description": "The description of the refund that may be shown to
    /// your customer, depending on the payment method used.",
    ///      "examples": [
    ///        "Refunding a Chess Board"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "externalReference": {
    ///      "type": "object",
    ///      "properties": {
    ///        "id": {
    ///          "description": "Unique reference from the payment provider",
    ///          "examples": [
    ///            123456789012345
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "$ref": "#/components/schemas/refund-external-reference-type"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/refundToken"
    ///    },
    ///    "metadata": {
    ///      "$ref": "#/components/schemas/metadata"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a refund object.
    /// Will always contain the string `refund` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "refund"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "reverseRouting": {
    ///      "description": "*This feature is only available to marketplace
    /// operators.*\n\nWith Mollie Connect you can charge fees on payments that
    /// your app is processing on behalf of other Mollie\nmerchants, by
    /// providing the `routing` object during [payment
    /// creation](create-payment).\n\nWhen creating refunds for these *routed*
    /// payments, by default the full amount is deducted from your
    /// balance.\n\nIf you want to pull back the funds that were routed to the
    /// connected merchant(s), you can set this parameter to\n`true` when
    /// issuing a full refund.\n\nFor more fine-grained control and for partial
    /// refunds, use the `routingReversals` parameter instead.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "routingReversals": {
    ///      "description": "*This feature is only available to marketplace
    /// operators.*\n\nWhen creating refunds for *routed* payments, by default
    /// the full amount is deducted from your balance.\n\nIf you want to pull
    /// back funds from the connected merchant(s), you can use this parameter to
    /// specify what amount\nneeds to be reversed from which merchant(s).\n\nIf
    /// you simply want to fully reverse the routed funds, you can also use the
    /// `reverseRouting` parameter instead.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "type": "object",
    ///        "properties": {
    ///          "amount": {
    ///            "$ref": "#/components/schemas/amount"
    ///          },
    ///          "source": {
    ///            "description": "Where the funds will be pulled back from.",
    ///            "type": "object",
    ///            "properties": {
    ///              "organizationId": {
    ///                "$ref": "#/components/schemas/organizationToken"
    ///              },
    ///              "type": {
    ///                "$ref":
    /// "#/components/schemas/refund-routing-reversals-source-type"
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "settlementAmount": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "settlementId": {
    ///      "$ref": "#/components/schemas/settlementToken"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/refund-status"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityRefund {
        pub amount: Amount,
        #[serde(rename = "createdAt")]
        pub created_at: CreatedAt,
        ///The description of the refund that may be shown to your customer,
        /// depending on the payment method used.
        pub description: EntityRefundDescription,
        #[serde(
            rename = "externalReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub external_reference: ::std::option::Option<EntityRefundExternalReference>,
        pub id: RefundToken,
        #[serde(rename = "_links")]
        pub links: EntityRefundLinks,
        pub metadata: Metadata,
        pub mode: Mode,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
        ///Indicates the response contains a refund object. Will always contain
        /// the string `refund` for this endpoint.
        pub resource: ::std::string::String,
        ///*This feature is only available to marketplace operators.*
        ///
        ///With Mollie Connect you can charge fees on payments that your app is
        /// processing on behalf of other Mollie merchants, by providing
        /// the `routing` object during [payment creation](create-payment).
        ///
        ///When creating refunds for these *routed* payments, by default the
        /// full amount is deducted from your balance.
        ///
        ///If you want to pull back the funds that were routed to the connected
        /// merchant(s), you can set this parameter to `true` when
        /// issuing a full refund.
        ///
        ///For more fine-grained control and for partial refunds, use the
        /// `routingReversals` parameter instead.
        #[serde(
            rename = "reverseRouting",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub reverse_routing: ::std::option::Option<bool>,
        ///*This feature is only available to marketplace operators.*
        ///
        ///When creating refunds for *routed* payments, by default the full
        /// amount is deducted from your balance.
        ///
        ///If you want to pull back funds from the connected merchant(s), you
        /// can use this parameter to specify what amount needs to be
        /// reversed from which merchant(s).
        ///
        ///If you simply want to fully reverse the routed funds, you can also
        /// use the `reverseRouting` parameter instead.
        #[serde(
            rename = "routingReversals",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub routing_reversals:
            ::std::option::Option<::std::vec::Vec<EntityRefundRoutingReversalsItem>>,
        #[serde(
            rename = "settlementAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_amount: ::std::option::Option<AmountNullable>,
        #[serde(
            rename = "settlementId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_id: ::std::option::Option<SettlementToken>,
        pub status: RefundStatus,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
    }

    impl ::std::convert::From<&EntityRefund> for EntityRefund {
        fn from(value: &EntityRefund) -> Self {
            value.clone()
        }
    }

    ///The description of the refund that may be shown to your customer,
    /// depending on the payment method used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The description of the refund that may be shown to your
    /// customer, depending on the payment method used.",
    ///  "examples": [
    ///    "Refunding a Chess Board"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityRefundDescription(::std::string::String);
    impl ::std::ops::Deref for EntityRefundDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityRefundDescription> for ::std::string::String {
        fn from(value: EntityRefundDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityRefundDescription> for EntityRefundDescription {
        fn from(value: &EntityRefundDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityRefundDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityRefundDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityRefundDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityRefundDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityRefundDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`EntityRefundExternalReference`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "id": {
    ///      "description": "Unique reference from the payment provider",
    ///      "examples": [
    ///        123456789012345
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/refund-external-reference-type"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityRefundExternalReference {
        ///Unique reference from the payment provider
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<RefundExternalReferenceType>,
    }

    impl ::std::convert::From<&EntityRefundExternalReference> for EntityRefundExternalReference {
        fn from(value: &EntityRefundExternalReference) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityRefundExternalReference {
        fn default() -> Self {
            Self {
                id: Default::default(),
                type_: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "documentation",
    ///    "payment",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "payment": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "settlement": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityRefundLinks {
        pub documentation: Url,
        pub payment: Url,
        #[serde(rename = "self")]
        pub self_: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub settlement: ::std::option::Option<UrlNullable>,
    }

    impl ::std::convert::From<&EntityRefundLinks> for EntityRefundLinks {
        fn from(value: &EntityRefundLinks) -> Self {
            value.clone()
        }
    }

    ///`EntityRefundResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_links",
    ///    "amount",
    ///    "createdAt",
    ///    "description",
    ///    "id",
    ///    "metadata",
    ///    "mode",
    ///    "resource",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "documentation",
    ///        "payment",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "payment": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "settlement": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        }
    ///      }
    ///    },
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "description": {
    ///      "description": "The description of the refund that may be shown to
    /// your customer, depending on the payment method used.",
    ///      "examples": [
    ///        "Refunding a Chess Board"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "externalReference": {
    ///      "type": "object",
    ///      "properties": {
    ///        "id": {
    ///          "description": "Unique reference from the payment provider",
    ///          "examples": [
    ///            123456789012345
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "$ref":
    /// "#/components/schemas/refund-external-reference-type-response"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/refundToken"
    ///    },
    ///    "metadata": {
    ///      "$ref": "#/components/schemas/metadata"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a refund object.
    /// Will always contain the string `refund` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "refund"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "reverseRouting": {
    ///      "description": "*This feature is only available to marketplace
    /// operators.*\n\nWith Mollie Connect you can charge fees on payments that
    /// your app is processing on behalf of other Mollie\nmerchants, by
    /// providing the `routing` object during [payment
    /// creation](create-payment).\n\nWhen creating refunds for these *routed*
    /// payments, by default the full amount is deducted from your
    /// balance.\n\nIf you want to pull back the funds that were routed to the
    /// connected merchant(s), you can set this parameter to\n`true` when
    /// issuing a full refund.\n\nFor more fine-grained control and for partial
    /// refunds, use the `routingReversals` parameter instead.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "routingReversals": {
    ///      "description": "*This feature is only available to marketplace
    /// operators.*\n\nWhen creating refunds for *routed* payments, by default
    /// the full amount is deducted from your balance.\n\nIf you want to pull
    /// back funds from the connected merchant(s), you can use this parameter to
    /// specify what amount\nneeds to be reversed from which merchant(s).\n\nIf
    /// you simply want to fully reverse the routed funds, you can also use the
    /// `reverseRouting` parameter instead.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "type": "object",
    ///        "properties": {
    ///          "amount": {
    ///            "$ref": "#/components/schemas/amount"
    ///          },
    ///          "source": {
    ///            "description": "Where the funds will be pulled back from.",
    ///            "type": "object",
    ///            "properties": {
    ///              "organizationId": {
    ///                "$ref": "#/components/schemas/organizationToken"
    ///              },
    ///              "type": {
    ///                "$ref":
    /// "#/components/schemas/refund-routing-reversals-source-type"
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "settlementAmount": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "settlementId": {
    ///      "$ref": "#/components/schemas/settlementToken"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/refund-status"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityRefundResponse {
        pub amount: Amount,
        #[serde(rename = "createdAt")]
        pub created_at: CreatedAt,
        ///The description of the refund that may be shown to your customer,
        /// depending on the payment method used.
        pub description: EntityRefundResponseDescription,
        #[serde(
            rename = "externalReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub external_reference: ::std::option::Option<EntityRefundResponseExternalReference>,
        pub id: RefundToken,
        #[serde(rename = "_links")]
        pub links: EntityRefundResponseLinks,
        pub metadata: Metadata,
        pub mode: Mode,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
        ///Indicates the response contains a refund object. Will always contain
        /// the string `refund` for this endpoint.
        pub resource: ::std::string::String,
        ///*This feature is only available to marketplace operators.*
        ///
        ///With Mollie Connect you can charge fees on payments that your app is
        /// processing on behalf of other Mollie merchants, by providing
        /// the `routing` object during [payment creation](create-payment).
        ///
        ///When creating refunds for these *routed* payments, by default the
        /// full amount is deducted from your balance.
        ///
        ///If you want to pull back the funds that were routed to the connected
        /// merchant(s), you can set this parameter to `true` when
        /// issuing a full refund.
        ///
        ///For more fine-grained control and for partial refunds, use the
        /// `routingReversals` parameter instead.
        #[serde(
            rename = "reverseRouting",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub reverse_routing: ::std::option::Option<bool>,
        ///*This feature is only available to marketplace operators.*
        ///
        ///When creating refunds for *routed* payments, by default the full
        /// amount is deducted from your balance.
        ///
        ///If you want to pull back funds from the connected merchant(s), you
        /// can use this parameter to specify what amount needs to be
        /// reversed from which merchant(s).
        ///
        ///If you simply want to fully reverse the routed funds, you can also
        /// use the `reverseRouting` parameter instead.
        #[serde(
            rename = "routingReversals",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub routing_reversals:
            ::std::option::Option<::std::vec::Vec<EntityRefundResponseRoutingReversalsItem>>,
        #[serde(
            rename = "settlementAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_amount: ::std::option::Option<AmountNullable>,
        #[serde(
            rename = "settlementId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_id: ::std::option::Option<SettlementToken>,
        pub status: RefundStatus,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
    }

    impl ::std::convert::From<&EntityRefundResponse> for EntityRefundResponse {
        fn from(value: &EntityRefundResponse) -> Self {
            value.clone()
        }
    }

    ///The description of the refund that may be shown to your customer,
    /// depending on the payment method used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The description of the refund that may be shown to your
    /// customer, depending on the payment method used.",
    ///  "examples": [
    ///    "Refunding a Chess Board"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityRefundResponseDescription(::std::string::String);
    impl ::std::ops::Deref for EntityRefundResponseDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityRefundResponseDescription> for ::std::string::String {
        fn from(value: EntityRefundResponseDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityRefundResponseDescription> for EntityRefundResponseDescription {
        fn from(value: &EntityRefundResponseDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityRefundResponseDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityRefundResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityRefundResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityRefundResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityRefundResponseDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`EntityRefundResponseExternalReference`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "id": {
    ///      "description": "Unique reference from the payment provider",
    ///      "examples": [
    ///        123456789012345
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "$ref":
    /// "#/components/schemas/refund-external-reference-type-response"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityRefundResponseExternalReference {
        ///Unique reference from the payment provider
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<RefundExternalReferenceTypeResponse>,
    }

    impl ::std::convert::From<&EntityRefundResponseExternalReference>
        for EntityRefundResponseExternalReference
    {
        fn from(value: &EntityRefundResponseExternalReference) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityRefundResponseExternalReference {
        fn default() -> Self {
            Self {
                id: Default::default(),
                type_: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "documentation",
    ///    "payment",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "payment": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "settlement": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityRefundResponseLinks {
        pub documentation: Url,
        pub payment: Url,
        #[serde(rename = "self")]
        pub self_: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub settlement: ::std::option::Option<UrlNullable>,
    }

    impl ::std::convert::From<&EntityRefundResponseLinks> for EntityRefundResponseLinks {
        fn from(value: &EntityRefundResponseLinks) -> Self {
            value.clone()
        }
    }

    ///`EntityRefundResponseRoutingReversalsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "source": {
    ///      "description": "Where the funds will be pulled back from.",
    ///      "type": "object",
    ///      "properties": {
    ///        "organizationId": {
    ///          "$ref": "#/components/schemas/organizationToken"
    ///        },
    ///        "type": {
    ///          "$ref":
    /// "#/components/schemas/refund-routing-reversals-source-type"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityRefundResponseRoutingReversalsItem {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<Amount>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source: ::std::option::Option<EntityRefundResponseRoutingReversalsItemSource>,
    }

    impl ::std::convert::From<&EntityRefundResponseRoutingReversalsItem>
        for EntityRefundResponseRoutingReversalsItem
    {
        fn from(value: &EntityRefundResponseRoutingReversalsItem) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityRefundResponseRoutingReversalsItem {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                source: Default::default(),
            }
        }
    }

    ///Where the funds will be pulled back from.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Where the funds will be pulled back from.",
    ///  "type": "object",
    ///  "properties": {
    ///    "organizationId": {
    ///      "$ref": "#/components/schemas/organizationToken"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/refund-routing-reversals-source-type"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityRefundResponseRoutingReversalsItemSource {
        #[serde(
            rename = "organizationId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub organization_id: ::std::option::Option<OrganizationToken>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<RefundRoutingReversalsSourceType>,
    }

    impl ::std::convert::From<&EntityRefundResponseRoutingReversalsItemSource>
        for EntityRefundResponseRoutingReversalsItemSource
    {
        fn from(value: &EntityRefundResponseRoutingReversalsItemSource) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityRefundResponseRoutingReversalsItemSource {
        fn default() -> Self {
            Self {
                organization_id: Default::default(),
                type_: Default::default(),
            }
        }
    }

    ///`EntityRefundRoutingReversalsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "source": {
    ///      "description": "Where the funds will be pulled back from.",
    ///      "type": "object",
    ///      "properties": {
    ///        "organizationId": {
    ///          "$ref": "#/components/schemas/organizationToken"
    ///        },
    ///        "type": {
    ///          "$ref":
    /// "#/components/schemas/refund-routing-reversals-source-type"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityRefundRoutingReversalsItem {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<Amount>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source: ::std::option::Option<EntityRefundRoutingReversalsItemSource>,
    }

    impl ::std::convert::From<&EntityRefundRoutingReversalsItem> for EntityRefundRoutingReversalsItem {
        fn from(value: &EntityRefundRoutingReversalsItem) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityRefundRoutingReversalsItem {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                source: Default::default(),
            }
        }
    }

    ///Where the funds will be pulled back from.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Where the funds will be pulled back from.",
    ///  "type": "object",
    ///  "properties": {
    ///    "organizationId": {
    ///      "$ref": "#/components/schemas/organizationToken"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/refund-routing-reversals-source-type"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityRefundRoutingReversalsItemSource {
        #[serde(
            rename = "organizationId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub organization_id: ::std::option::Option<OrganizationToken>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<RefundRoutingReversalsSourceType>,
    }

    impl ::std::convert::From<&EntityRefundRoutingReversalsItemSource>
        for EntityRefundRoutingReversalsItemSource
    {
        fn from(value: &EntityRefundRoutingReversalsItemSource) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityRefundRoutingReversalsItemSource {
        fn default() -> Self {
            Self {
                organization_id: Default::default(),
                type_: Default::default(),
            }
        }
    }

    ///`EntityRoute`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "documentation",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "description": {
    ///      "description": "The description of the route. This description is
    /// shown in the reports.",
    ///      "examples": [
    ///        "Payment for Order #12345"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "destination": {
    ///      "description": "The destination of the route.",
    ///      "type": "object",
    ///      "required": [
    ///        "organizationId",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "organizationId": {
    ///          "$ref": "#/components/schemas/organizationToken"
    ///        },
    ///        "type": {
    ///          "$ref": "#/components/schemas/route-destination-type-response"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/connectRouteToken"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a route object.
    /// Will always contain the string `route` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "route"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityRoute {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<Amount>,
        ///The description of the route. This description is shown in the
        /// reports.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<EntityRouteDescription>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub destination: ::std::option::Option<EntityRouteDestination>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<ConnectRouteToken>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntityRouteLinks>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
        ///Indicates the response contains a route object. Will always contain
        /// the string `route` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
    }

    impl ::std::convert::From<&EntityRoute> for EntityRoute {
        fn from(value: &EntityRoute) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityRoute {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                description: Default::default(),
                destination: Default::default(),
                id: Default::default(),
                links: Default::default(),
                payment_id: Default::default(),
                resource: Default::default(),
                testmode: Default::default(),
            }
        }
    }

    ///The description of the route. This description is shown in the reports.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The description of the route. This description is shown
    /// in the reports.",
    ///  "examples": [
    ///    "Payment for Order #12345"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityRouteDescription(::std::string::String);
    impl ::std::ops::Deref for EntityRouteDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityRouteDescription> for ::std::string::String {
        fn from(value: EntityRouteDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityRouteDescription> for EntityRouteDescription {
        fn from(value: &EntityRouteDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityRouteDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityRouteDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityRouteDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityRouteDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityRouteDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The destination of the route.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The destination of the route.",
    ///  "type": "object",
    ///  "required": [
    ///    "organizationId",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "organizationId": {
    ///      "$ref": "#/components/schemas/organizationToken"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/route-destination-type-response"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityRouteDestination {
        #[serde(rename = "organizationId")]
        pub organization_id: OrganizationToken,
        #[serde(rename = "type")]
        pub type_: RouteDestinationTypeResponse,
    }

    impl ::std::convert::From<&EntityRouteDestination> for EntityRouteDestination {
        fn from(value: &EntityRouteDestination) -> Self {
            value.clone()
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "documentation",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityRouteLinks {
        pub documentation: Url,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&EntityRouteLinks> for EntityRouteLinks {
        fn from(value: &EntityRouteLinks) -> Self {
            value.clone()
        }
    }

    ///`EntitySalesInvoice`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "invoicePayment": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "next": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "pdfLink": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "previous": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "amountDue": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "customerId": {
    ///      "description": "The identifier referring to the
    /// [customer](get-customer) you want to attempt an automated payment for.
    /// If\nprovided, `mandateId` becomes required as well. Only allowed for
    /// invoices with status `paid`.",
    ///      "examples": [
    ///        "cst_8wmqcHMN4U"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "discount": {
    ///      "$ref": "#/components/schemas/sales-invoice-discount"
    ///    },
    ///    "discountedSubtotalAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "dueAt": {
    ///      "description": "If issued, the date when the sales invoice payment is due, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)\nformat.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-11-01T10:47:38+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "emailDetails": {
    ///      "$ref": "#/components/schemas/sales-invoice-email-details"
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/salesInvoiceToken"
    ///    },
    ///    "invoiceNumber": {
    ///      "description": "When issued, an invoice number will be set for the
    /// sales invoice.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "INV-0000001"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "isEInvoice": {
    ///      "description": "This indicates whether the invoice is an e-invoice.
    /// The default value is `false` and can't be changed\nafter the invoice has
    /// been issued. When `emailDetails` is provided, an additional email is
    /// sent to the\nrecipient.\n\nE-invoicing is only available for merchants
    /// based in Belgium, Germany, and the Netherlands, and only when\nthe
    /// recipient is also located in one of these countries.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "issuedAt": {
    ///      "description": "If issued, the date when the sales invoice was issued, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)\nformat.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-10-03T10:47:38+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "lines": {
    ///      "description": "Provide the line items for the invoice. Each line
    /// contains details such as a description of the item\nordered and its
    /// price.\n\nAll lines must have the same currency as the invoice.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/sales-invoice-line-item"
    ///      }
    ///    },
    ///    "mandateId": {
    ///      "description": "The identifier referring to the
    /// [mandate](get-mandate) you want to use for the automated payment. If
    /// provided,\n`customerId` becomes required as well. Only allowed for
    /// invoices with status `paid`.",
    ///      "examples": [
    ///        "mdt_pWUnw6pkBN"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "memo": {
    ///      "description": "A free-form memo you can set on the invoice, and
    /// will be shown on the invoice PDF.",
    ///      "examples": [
    ///        "This is a memo!"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "metadata": {
    ///      "description": "Provide any data you like as a JSON object. We will
    /// save the data alongside the entity. Whenever\nyou fetch the entity with
    /// our API, we will also include the metadata. You can use up to
    /// approximately 1kB.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ]
    ///    },
    ///    "paidAt": {
    ///      "description": "If paid, the date when the sales invoice was paid, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)\nformat.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-10-04T10:47:38+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "paymentDetails": {
    ///      "$ref": "#/components/schemas/sales-invoice-payment-details"
    ///    },
    ///    "paymentTerm": {
    ///      "$ref": "#/components/schemas/sales-invoice-payment-term"
    ///    },
    ///    "profileId": {
    ///      "description": "The identifier referring to the
    /// [profile](get-profile) this entity belongs to.\n\nMost API credentials
    /// are linked to a single profile. In these cases the `profileId` can be
    /// omitted in the creation\nrequest. For organization-level credentials
    /// such as OAuth access tokens however, the `profileId` parameter
    /// is\nrequired.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "pfl_QkEhN94Ba"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "recipient": {
    ///      "$ref": "#/components/schemas/sales-invoice-recipient"
    ///    },
    ///    "recipientIdentifier": {
    ///      "description": "An identifier tied to the recipient data. This
    /// should be a unique value based on data your system contains,\nso that
    /// both you and us know who we're referring to. It is a value you provide
    /// to us so that recipient management\nis not required to send a first
    /// invoice to a recipient.",
    ///      "examples": [
    ///        "customer-xyz-0123"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a sales invoice
    /// object. Will always contain the string `sales-invoice` for
    /// this\nendpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "sales-invoice"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/sales-invoice-status"
    ///    },
    ///    "subtotalAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    },
    ///    "totalAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "totalVatAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "vatMode": {
    ///      "$ref": "#/components/schemas/sales-invoice-vat-mode"
    ///    },
    ///    "vatScheme": {
    ///      "$ref": "#/components/schemas/sales-invoice-vat-scheme"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntitySalesInvoice {
        #[serde(
            rename = "amountDue",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub amount_due: ::std::option::Option<Amount>,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        ///The identifier referring to the [customer](get-customer) you want to
        /// attempt an automated payment for. If provided, `mandateId`
        /// becomes required as well. Only allowed for invoices with status
        /// `paid`.
        #[serde(
            rename = "customerId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub customer_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub discount: ::std::option::Option<SalesInvoiceDiscount>,
        #[serde(
            rename = "discountedSubtotalAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub discounted_subtotal_amount: ::std::option::Option<Amount>,
        ///If issued, the date when the sales invoice payment is due, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
        ///format.
        #[serde(
            rename = "dueAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub due_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "emailDetails",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub email_details: ::std::option::Option<SalesInvoiceEmailDetails>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<SalesInvoiceToken>,
        ///When issued, an invoice number will be set for the sales invoice.
        #[serde(
            rename = "invoiceNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub invoice_number: ::std::option::Option<::std::string::String>,
        ///This indicates whether the invoice is an e-invoice. The default
        /// value is `false` and can't be changed after the invoice has
        /// been issued. When `emailDetails` is provided, an additional email is
        /// sent to the recipient.
        ///
        ///E-invoicing is only available for merchants based in Belgium,
        /// Germany, and the Netherlands, and only when the recipient is
        /// also located in one of these countries.
        #[serde(
            rename = "isEInvoice",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub is_e_invoice: ::std::option::Option<bool>,
        ///If issued, the date when the sales invoice was issued, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
        ///format.
        #[serde(
            rename = "issuedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub issued_at: ::std::option::Option<::std::string::String>,
        ///Provide the line items for the invoice. Each line contains details
        /// such as a description of the item ordered and its price.
        ///
        ///All lines must have the same currency as the invoice.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub lines: ::std::option::Option<::std::vec::Vec<SalesInvoiceLineItem>>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntitySalesInvoiceLinks>,
        ///The identifier referring to the [mandate](get-mandate) you want to
        /// use for the automated payment. If provided, `customerId`
        /// becomes required as well. Only allowed for invoices with status
        /// `paid`.
        #[serde(
            rename = "mandateId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub mandate_id: ::std::option::Option<::std::string::String>,
        ///A free-form memo you can set on the invoice, and will be shown on
        /// the invoice PDF.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub memo: ::std::option::Option<::std::string::String>,
        ///Provide any data you like as a JSON object. We will save the data
        /// alongside the entity. Whenever you fetch the entity with our
        /// API, we will also include the metadata. You can use up to
        /// approximately 1kB.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata:
            ::std::option::Option<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        ///If paid, the date when the sales invoice was paid, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
        ///format.
        #[serde(
            rename = "paidAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paid_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentDetails",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_details: ::std::option::Option<SalesInvoicePaymentDetails>,
        #[serde(
            rename = "paymentTerm",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_term: ::std::option::Option<SalesInvoicePaymentTerm>,
        ///The identifier referring to the [profile](get-profile) this entity
        /// belongs to.
        ///
        ///Most API credentials are linked to a single profile. In these cases
        /// the `profileId` can be omitted in the creation request. For
        /// organization-level credentials such as OAuth access tokens however,
        /// the `profileId` parameter is required.
        #[serde(
            rename = "profileId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub profile_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub recipient: ::std::option::Option<SalesInvoiceRecipient>,
        ///An identifier tied to the recipient data. This should be a unique
        /// value based on data your system contains, so that both you
        /// and us know who we're referring to. It is a value you provide to us
        /// so that recipient management is not required to send a first
        /// invoice to a recipient.
        #[serde(
            rename = "recipientIdentifier",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub recipient_identifier: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a sales invoice object. Will always
        /// contain the string `sales-invoice` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<SalesInvoiceStatus>,
        #[serde(
            rename = "subtotalAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtotal_amount: ::std::option::Option<Amount>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
        #[serde(
            rename = "totalAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub total_amount: ::std::option::Option<Amount>,
        #[serde(
            rename = "totalVatAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub total_vat_amount: ::std::option::Option<Amount>,
        #[serde(
            rename = "vatMode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_mode: ::std::option::Option<SalesInvoiceVatMode>,
        #[serde(
            rename = "vatScheme",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_scheme: ::std::option::Option<SalesInvoiceVatScheme>,
    }

    impl ::std::convert::From<&EntitySalesInvoice> for EntitySalesInvoice {
        fn from(value: &EntitySalesInvoice) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntitySalesInvoice {
        fn default() -> Self {
            Self {
                amount_due: Default::default(),
                created_at: Default::default(),
                customer_id: Default::default(),
                discount: Default::default(),
                discounted_subtotal_amount: Default::default(),
                due_at: Default::default(),
                email_details: Default::default(),
                id: Default::default(),
                invoice_number: Default::default(),
                is_e_invoice: Default::default(),
                issued_at: Default::default(),
                lines: Default::default(),
                links: Default::default(),
                mandate_id: Default::default(),
                memo: Default::default(),
                metadata: Default::default(),
                paid_at: Default::default(),
                payment_details: Default::default(),
                payment_term: Default::default(),
                profile_id: Default::default(),
                recipient: Default::default(),
                recipient_identifier: Default::default(),
                resource: Default::default(),
                status: Default::default(),
                subtotal_amount: Default::default(),
                testmode: Default::default(),
                total_amount: Default::default(),
                total_vat_amount: Default::default(),
                vat_mode: Default::default(),
                vat_scheme: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "invoicePayment": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "next": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "pdfLink": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "previous": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntitySalesInvoiceLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(
            rename = "invoicePayment",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub invoice_payment: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next: ::std::option::Option<Url>,
        #[serde(
            rename = "pdfLink",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub pdf_link: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub previous: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&EntitySalesInvoiceLinks> for EntitySalesInvoiceLinks {
        fn from(value: &EntitySalesInvoiceLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntitySalesInvoiceLinks {
        fn default() -> Self {
            Self {
                documentation: Default::default(),
                invoice_payment: Default::default(),
                next: Default::default(),
                pdf_link: Default::default(),
                previous: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///`EntitySalesInvoiceResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "invoicePayment": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "next": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "pdfLink": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "previous": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "amountDue": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "customerId": {
    ///      "description": "The identifier referring to the
    /// [customer](get-customer) you want to attempt an automated payment for.
    /// If\nprovided, `mandateId` becomes required as well. Only allowed for
    /// invoices with status `paid`.",
    ///      "examples": [
    ///        "cst_8wmqcHMN4U"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "discount": {
    ///      "$ref": "#/components/schemas/sales-invoice-discount-response"
    ///    },
    ///    "discountedSubtotalAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "dueAt": {
    ///      "description": "If issued, the date when the sales invoice payment is due, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)\nformat.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-11-01T10:47:38+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "emailDetails": {
    ///      "$ref": "#/components/schemas/sales-invoice-email-details"
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/salesInvoiceToken"
    ///    },
    ///    "invoiceNumber": {
    ///      "description": "When issued, an invoice number will be set for the
    /// sales invoice.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "INV-0000001"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "isEInvoice": {
    ///      "description": "This indicates whether the invoice is an e-invoice.
    /// The default value is `false` and can't be changed\nafter the invoice has
    /// been issued. When `emailDetails` is provided, an additional email is
    /// sent to the\nrecipient.\n\nE-invoicing is only available for merchants
    /// based in Belgium, Germany, and the Netherlands, and only when\nthe
    /// recipient is also located in one of these countries.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "issuedAt": {
    ///      "description": "If issued, the date when the sales invoice was issued, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)\nformat.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-10-03T10:47:38+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "lines": {
    ///      "description": "Provide the line items for the invoice. Each line
    /// contains details such as a description of the item\nordered and its
    /// price.\n\nAll lines must have the same currency as the invoice.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/sales-invoice-line-item-response"
    ///      }
    ///    },
    ///    "mandateId": {
    ///      "description": "The identifier referring to the
    /// [mandate](get-mandate) you want to use for the automated payment. If
    /// provided,\n`customerId` becomes required as well. Only allowed for
    /// invoices with status `paid`.",
    ///      "examples": [
    ///        "mdt_pWUnw6pkBN"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "memo": {
    ///      "description": "A free-form memo you can set on the invoice, and
    /// will be shown on the invoice PDF.",
    ///      "examples": [
    ///        "This is a memo!"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "metadata": {
    ///      "description": "Provide any data you like as a JSON object. We will
    /// save the data alongside the entity. Whenever\nyou fetch the entity with
    /// our API, we will also include the metadata. You can use up to
    /// approximately 1kB.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ]
    ///    },
    ///    "paidAt": {
    ///      "description": "If paid, the date when the sales invoice was paid, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)\nformat.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-10-04T10:47:38+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "paymentDetails": {
    ///      "$ref":
    /// "#/components/schemas/sales-invoice-payment-details-response"
    ///    },
    ///    "paymentTerm": {
    ///      "$ref": "#/components/schemas/sales-invoice-payment-term-response"
    ///    },
    ///    "profileId": {
    ///      "description": "The identifier referring to the
    /// [profile](get-profile) this entity belongs to.\n\nMost API credentials
    /// are linked to a single profile. In these cases the `profileId` can be
    /// omitted in the creation\nrequest. For organization-level credentials
    /// such as OAuth access tokens however, the `profileId` parameter
    /// is\nrequired.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "pfl_QkEhN94Ba"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "recipient": {
    ///      "$ref": "#/components/schemas/sales-invoice-recipient-response"
    ///    },
    ///    "recipientIdentifier": {
    ///      "description": "An identifier tied to the recipient data. This
    /// should be a unique value based on data your system contains,\nso that
    /// both you and us know who we're referring to. It is a value you provide
    /// to us so that recipient management\nis not required to send a first
    /// invoice to a recipient.",
    ///      "examples": [
    ///        "customer-xyz-0123"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a sales invoice
    /// object. Will always contain the string `sales-invoice` for
    /// this\nendpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "sales-invoice"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/sales-invoice-status-response"
    ///    },
    ///    "subtotalAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    },
    ///    "totalAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "totalVatAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "vatMode": {
    ///      "$ref": "#/components/schemas/sales-invoice-vat-mode-response"
    ///    },
    ///    "vatScheme": {
    ///      "$ref": "#/components/schemas/sales-invoice-vat-scheme-response"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntitySalesInvoiceResponse {
        #[serde(
            rename = "amountDue",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub amount_due: ::std::option::Option<Amount>,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        ///The identifier referring to the [customer](get-customer) you want to
        /// attempt an automated payment for. If provided, `mandateId`
        /// becomes required as well. Only allowed for invoices with status
        /// `paid`.
        #[serde(
            rename = "customerId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub customer_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub discount: ::std::option::Option<SalesInvoiceDiscountResponse>,
        #[serde(
            rename = "discountedSubtotalAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub discounted_subtotal_amount: ::std::option::Option<Amount>,
        ///If issued, the date when the sales invoice payment is due, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
        ///format.
        #[serde(
            rename = "dueAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub due_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "emailDetails",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub email_details: ::std::option::Option<SalesInvoiceEmailDetails>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<SalesInvoiceToken>,
        ///When issued, an invoice number will be set for the sales invoice.
        #[serde(
            rename = "invoiceNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub invoice_number: ::std::option::Option<::std::string::String>,
        ///This indicates whether the invoice is an e-invoice. The default
        /// value is `false` and can't be changed after the invoice has
        /// been issued. When `emailDetails` is provided, an additional email is
        /// sent to the recipient.
        ///
        ///E-invoicing is only available for merchants based in Belgium,
        /// Germany, and the Netherlands, and only when the recipient is
        /// also located in one of these countries.
        #[serde(
            rename = "isEInvoice",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub is_e_invoice: ::std::option::Option<bool>,
        ///If issued, the date when the sales invoice was issued, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
        ///format.
        #[serde(
            rename = "issuedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub issued_at: ::std::option::Option<::std::string::String>,
        ///Provide the line items for the invoice. Each line contains details
        /// such as a description of the item ordered and its price.
        ///
        ///All lines must have the same currency as the invoice.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub lines: ::std::option::Option<::std::vec::Vec<SalesInvoiceLineItemResponse>>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntitySalesInvoiceResponseLinks>,
        ///The identifier referring to the [mandate](get-mandate) you want to
        /// use for the automated payment. If provided, `customerId`
        /// becomes required as well. Only allowed for invoices with status
        /// `paid`.
        #[serde(
            rename = "mandateId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub mandate_id: ::std::option::Option<::std::string::String>,
        ///A free-form memo you can set on the invoice, and will be shown on
        /// the invoice PDF.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub memo: ::std::option::Option<::std::string::String>,
        ///Provide any data you like as a JSON object. We will save the data
        /// alongside the entity. Whenever you fetch the entity with our
        /// API, we will also include the metadata. You can use up to
        /// approximately 1kB.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata:
            ::std::option::Option<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        ///If paid, the date when the sales invoice was paid, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
        ///format.
        #[serde(
            rename = "paidAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paid_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentDetails",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_details: ::std::option::Option<SalesInvoicePaymentDetailsResponse>,
        #[serde(
            rename = "paymentTerm",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_term: ::std::option::Option<SalesInvoicePaymentTermResponse>,
        ///The identifier referring to the [profile](get-profile) this entity
        /// belongs to.
        ///
        ///Most API credentials are linked to a single profile. In these cases
        /// the `profileId` can be omitted in the creation request. For
        /// organization-level credentials such as OAuth access tokens however,
        /// the `profileId` parameter is required.
        #[serde(
            rename = "profileId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub profile_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub recipient: ::std::option::Option<SalesInvoiceRecipientResponse>,
        ///An identifier tied to the recipient data. This should be a unique
        /// value based on data your system contains, so that both you
        /// and us know who we're referring to. It is a value you provide to us
        /// so that recipient management is not required to send a first
        /// invoice to a recipient.
        #[serde(
            rename = "recipientIdentifier",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub recipient_identifier: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a sales invoice object. Will always
        /// contain the string `sales-invoice` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<SalesInvoiceStatusResponse>,
        #[serde(
            rename = "subtotalAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtotal_amount: ::std::option::Option<Amount>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
        #[serde(
            rename = "totalAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub total_amount: ::std::option::Option<Amount>,
        #[serde(
            rename = "totalVatAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub total_vat_amount: ::std::option::Option<Amount>,
        #[serde(
            rename = "vatMode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_mode: ::std::option::Option<SalesInvoiceVatModeResponse>,
        #[serde(
            rename = "vatScheme",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_scheme: ::std::option::Option<SalesInvoiceVatSchemeResponse>,
    }

    impl ::std::convert::From<&EntitySalesInvoiceResponse> for EntitySalesInvoiceResponse {
        fn from(value: &EntitySalesInvoiceResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntitySalesInvoiceResponse {
        fn default() -> Self {
            Self {
                amount_due: Default::default(),
                created_at: Default::default(),
                customer_id: Default::default(),
                discount: Default::default(),
                discounted_subtotal_amount: Default::default(),
                due_at: Default::default(),
                email_details: Default::default(),
                id: Default::default(),
                invoice_number: Default::default(),
                is_e_invoice: Default::default(),
                issued_at: Default::default(),
                lines: Default::default(),
                links: Default::default(),
                mandate_id: Default::default(),
                memo: Default::default(),
                metadata: Default::default(),
                paid_at: Default::default(),
                payment_details: Default::default(),
                payment_term: Default::default(),
                profile_id: Default::default(),
                recipient: Default::default(),
                recipient_identifier: Default::default(),
                resource: Default::default(),
                status: Default::default(),
                subtotal_amount: Default::default(),
                testmode: Default::default(),
                total_amount: Default::default(),
                total_vat_amount: Default::default(),
                vat_mode: Default::default(),
                vat_scheme: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "invoicePayment": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "next": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "pdfLink": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "previous": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntitySalesInvoiceResponseLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(
            rename = "invoicePayment",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub invoice_payment: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next: ::std::option::Option<Url>,
        #[serde(
            rename = "pdfLink",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub pdf_link: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub previous: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&EntitySalesInvoiceResponseLinks> for EntitySalesInvoiceResponseLinks {
        fn from(value: &EntitySalesInvoiceResponseLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntitySalesInvoiceResponseLinks {
        fn default() -> Self {
            Self {
                documentation: Default::default(),
                invoice_payment: Default::default(),
                next: Default::default(),
                pdf_link: Default::default(),
                previous: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///`EntitySession`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "additionalProperties": true
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EntitySession(pub ::serde_json::Map<::std::string::String, ::serde_json::Value>);
    impl ::std::ops::Deref for EntitySession {
        type Target = ::serde_json::Map<::std::string::String, ::serde_json::Value>;
        fn deref(&self) -> &::serde_json::Map<::std::string::String, ::serde_json::Value> {
            &self.0
        }
    }

    impl ::std::convert::From<EntitySession>
        for ::serde_json::Map<::std::string::String, ::serde_json::Value>
    {
        fn from(value: EntitySession) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntitySession> for EntitySession {
        fn from(value: &EntitySession) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::serde_json::Map<::std::string::String, ::serde_json::Value>>
        for EntitySession
    {
        fn from(value: ::serde_json::Map<::std::string::String, ::serde_json::Value>) -> Self {
            Self(value)
        }
    }

    ///`EntitySettlement`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_links",
    ///    "amount",
    ///    "balanceId",
    ///    "id",
    ///    "resource",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "captures": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "chargebacks": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "invoice": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        },
    ///        "payments": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "refunds": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "balanceId": {
    ///      "$ref": "#/components/schemas/balanceToken"
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/settlementToken"
    ///    },
    ///    "invoiceId": {
    ///      "$ref": "#/components/schemas/invoiceToken"
    ///    },
    ///    "periods": {
    ///      "description": "For bookkeeping purposes, the settlement includes
    /// an overview of transactions included in the settlement.
    /// These\ntransactions are grouped into 'period' objects — one for each
    /// calendar month.\n\nFor example, if a settlement includes funds from 15
    /// April until 4 May, it will include two period objects. One for\nall
    /// transactions processed between 15 April and 30 April, and one for all
    /// transactions between 1 May and 4 May.\n\nPeriod objects are grouped by
    /// year, and then by month. So in the above example, the full `periods`
    /// collection will\nlook as follows: `{\"2024\": {\"04\": {...}, \"05\":
    /// {...}}}`. The year and month in this documentation are referred as
    /// `<year>` and `<month>`.\n\nThe example response should give a good idea
    /// of what this looks like in practise.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "type": "object",
    ///        "additionalProperties": {
    ///          "type": "object",
    ///          "properties": {
    ///            "costs": {
    ///              "description": "An array of cost objects, describing the
    /// fees withheld for each payment method during this period.",
    ///              "type": "array",
    ///              "items": {
    ///                "type": "object",
    ///                "required": [
    ///                  "amountGross",
    ///                  "amountNet",
    ///                  "amountVat",
    ///                  "count",
    ///                  "description",
    ///                  "method",
    ///                  "rate"
    ///                ],
    ///                "properties": {
    ///                  "amountGross": {
    ///                    "$ref": "#/components/schemas/amount"
    ///                  },
    ///                  "amountNet": {
    ///                    "$ref": "#/components/schemas/amount"
    ///                  },
    ///                  "amountVat": {
    ///                    "$ref": "#/components/schemas/amount-nullable"
    ///                  },
    ///                  "count": {
    ///                    "description": "The number of fees",
    ///                    "examples": [
    ///                      10
    ///                    ],
    ///                    "type": "integer"
    ///                  },
    ///                  "description": {
    ///                    "description": "A description of the cost subtotal",
    ///                    "examples": [
    ///                      "Credit card - Visa debit consumer domestic"
    ///                    ],
    ///                    "type": "string"
    ///                  },
    ///                  "method": {
    ///                    "$ref": "#/components/schemas/payment-method"
    ///                  },
    ///                  "rate": {
    ///                    "description": "The service rates, further divided
    /// into `fixed` and `percentage` costs.",
    ///                    "type": "object",
    ///                    "properties": {
    ///                      "fixed": {
    ///                        "$ref": "#/components/schemas/amount"
    ///                      },
    ///                      "percentage": {
    ///                        "examples": [
    ///                          "2.5"
    ///                        ],
    ///                        "type": "string"
    ///                      }
    ///                    }
    ///                  }
    ///                }
    ///              }
    ///            },
    ///            "invoiceId": {
    ///              "$ref": "#/components/schemas/invoiceToken"
    ///            },
    ///            "invoiceReference": {
    ///              "description": "The invoice reference, if the invoice has
    /// been created already.",
    ///              "examples": [
    ///                "MOLR2021.0001399669"
    ///              ],
    ///              "type": [
    ///                "string",
    ///                "null"
    ///              ]
    ///            },
    ///            "revenue": {
    ///              "description": "An array of revenue objects containing the
    /// total revenue for each payment method during this period.",
    ///              "type": "array",
    ///              "items": {
    ///                "type": "object",
    ///                "required": [
    ///                  "amountGross",
    ///                  "amountNet",
    ///                  "amountVat",
    ///                  "count",
    ///                  "description",
    ///                  "method"
    ///                ],
    ///                "properties": {
    ///                  "amountGross": {
    ///                    "$ref": "#/components/schemas/amount"
    ///                  },
    ///                  "amountNet": {
    ///                    "$ref": "#/components/schemas/amount"
    ///                  },
    ///                  "amountVat": {
    ///                    "$ref": "#/components/schemas/amount-nullable"
    ///                  },
    ///                  "count": {
    ///                    "description": "The number of payments",
    ///                    "examples": [
    ///                      10
    ///                    ],
    ///                    "type": "integer"
    ///                  },
    ///                  "description": {
    ///                    "description": "A description of the revenue
    /// subtotal",
    ///                    "examples": [
    ///                      "Credit card"
    ///                    ],
    ///                    "type": "string"
    ///                  },
    ///                  "method": {
    ///                    "$ref": "#/components/schemas/payment-method"
    ///                  }
    ///                }
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "reference": {
    ///      "description": "The settlement's bank reference, as found in your
    /// Mollie account and on your bank statement.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "07049691.2406.01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a settlement
    /// object. Will always contain the string `settlement` for
    /// this\nendpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "settlement"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "settledAt": {
    ///      "description": "The date on which the settlement was settled, in
    /// ISO 8601 format.\n\nFor an [open settlement](get-open-settlement) or for
    /// the [next settlement](get-next-settlement), no settlement\ndate is
    /// available.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2025-03-31T12:54:39Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/settlement-status"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntitySettlement {
        pub amount: Amount,
        #[serde(rename = "balanceId")]
        pub balance_id: BalanceToken,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        pub id: SettlementToken,
        #[serde(
            rename = "invoiceId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub invoice_id: ::std::option::Option<InvoiceToken>,
        #[serde(rename = "_links")]
        pub links: EntitySettlementLinks,
        ///For bookkeeping purposes, the settlement includes an overview of
        /// transactions included in the settlement. These transactions
        /// are grouped into 'period' objects — one for each calendar month.
        ///
        ///For example, if a settlement includes funds from 15 April until 4
        /// May, it will include two period objects. One for
        /// all transactions processed between 15 April and 30 April, and one
        /// for all transactions between 1 May and 4 May.
        ///
        ///Period objects are grouped by year, and then by month. So in the
        /// above example, the full `periods` collection will
        /// look as follows: `{"2024": {"04": {...}, "05": {...}}}`. The year
        /// and month in this documentation are referred as `<year>` and
        /// `<month>`.
        ///
        ///The example response should give a good idea of what this looks like
        /// in practise.
        #[serde(
            default,
            skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
        )]
        pub periods: ::std::collections::HashMap<
            ::std::string::String,
            ::std::collections::HashMap<::std::string::String, EntitySettlementPeriodsValueValue>,
        >,
        ///The settlement's bank reference, as found in your Mollie account and
        /// on your bank statement.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub reference: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a settlement object. Will always
        /// contain the string `settlement` for this endpoint.
        pub resource: ::std::string::String,
        ///The date on which the settlement was settled, in ISO 8601 format.
        ///
        ///For an [open settlement](get-open-settlement) or for the [next
        /// settlement](get-next-settlement), no settlement
        /// date is available.
        #[serde(
            rename = "settledAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settled_at: ::std::option::Option<::std::string::String>,
        pub status: SettlementStatus,
    }

    impl ::std::convert::From<&EntitySettlement> for EntitySettlement {
        fn from(value: &EntitySettlement) -> Self {
            value.clone()
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "captures": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "chargebacks": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "invoice": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "payments": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "refunds": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntitySettlementLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub captures: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chargebacks: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub invoice: ::std::option::Option<UrlNullable>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payments: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub refunds: ::std::option::Option<Url>,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&EntitySettlementLinks> for EntitySettlementLinks {
        fn from(value: &EntitySettlementLinks) -> Self {
            value.clone()
        }
    }

    ///`EntitySettlementPeriodsValueValue`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "costs": {
    ///      "description": "An array of cost objects, describing the fees
    /// withheld for each payment method during this period.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amountGross",
    ///          "amountNet",
    ///          "amountVat",
    ///          "count",
    ///          "description",
    ///          "method",
    ///          "rate"
    ///        ],
    ///        "properties": {
    ///          "amountGross": {
    ///            "$ref": "#/components/schemas/amount"
    ///          },
    ///          "amountNet": {
    ///            "$ref": "#/components/schemas/amount"
    ///          },
    ///          "amountVat": {
    ///            "$ref": "#/components/schemas/amount-nullable"
    ///          },
    ///          "count": {
    ///            "description": "The number of fees",
    ///            "examples": [
    ///              10
    ///            ],
    ///            "type": "integer"
    ///          },
    ///          "description": {
    ///            "description": "A description of the cost subtotal",
    ///            "examples": [
    ///              "Credit card - Visa debit consumer domestic"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "method": {
    ///            "$ref": "#/components/schemas/payment-method"
    ///          },
    ///          "rate": {
    ///            "description": "The service rates, further divided into
    /// `fixed` and `percentage` costs.",
    ///            "type": "object",
    ///            "properties": {
    ///              "fixed": {
    ///                "$ref": "#/components/schemas/amount"
    ///              },
    ///              "percentage": {
    ///                "examples": [
    ///                  "2.5"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "invoiceId": {
    ///      "$ref": "#/components/schemas/invoiceToken"
    ///    },
    ///    "invoiceReference": {
    ///      "description": "The invoice reference, if the invoice has been
    /// created already.",
    ///      "examples": [
    ///        "MOLR2021.0001399669"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "revenue": {
    ///      "description": "An array of revenue objects containing the total
    /// revenue for each payment method during this period.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amountGross",
    ///          "amountNet",
    ///          "amountVat",
    ///          "count",
    ///          "description",
    ///          "method"
    ///        ],
    ///        "properties": {
    ///          "amountGross": {
    ///            "$ref": "#/components/schemas/amount"
    ///          },
    ///          "amountNet": {
    ///            "$ref": "#/components/schemas/amount"
    ///          },
    ///          "amountVat": {
    ///            "$ref": "#/components/schemas/amount-nullable"
    ///          },
    ///          "count": {
    ///            "description": "The number of payments",
    ///            "examples": [
    ///              10
    ///            ],
    ///            "type": "integer"
    ///          },
    ///          "description": {
    ///            "description": "A description of the revenue subtotal",
    ///            "examples": [
    ///              "Credit card"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "method": {
    ///            "$ref": "#/components/schemas/payment-method"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntitySettlementPeriodsValueValue {
        ///An array of cost objects, describing the fees withheld for each
        /// payment method during this period.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub costs: ::std::vec::Vec<EntitySettlementPeriodsValueValueCostsItem>,
        #[serde(
            rename = "invoiceId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub invoice_id: ::std::option::Option<InvoiceToken>,
        ///The invoice reference, if the invoice has been created already.
        #[serde(
            rename = "invoiceReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub invoice_reference: ::std::option::Option<::std::string::String>,
        ///An array of revenue objects containing the total revenue for each
        /// payment method during this period.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub revenue: ::std::vec::Vec<EntitySettlementPeriodsValueValueRevenueItem>,
    }

    impl ::std::convert::From<&EntitySettlementPeriodsValueValue>
        for EntitySettlementPeriodsValueValue
    {
        fn from(value: &EntitySettlementPeriodsValueValue) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntitySettlementPeriodsValueValue {
        fn default() -> Self {
            Self {
                costs: Default::default(),
                invoice_id: Default::default(),
                invoice_reference: Default::default(),
                revenue: Default::default(),
            }
        }
    }

    ///`EntitySettlementPeriodsValueValueCostsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amountGross",
    ///    "amountNet",
    ///    "amountVat",
    ///    "count",
    ///    "description",
    ///    "method",
    ///    "rate"
    ///  ],
    ///  "properties": {
    ///    "amountGross": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "amountNet": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "amountVat": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "count": {
    ///      "description": "The number of fees",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "description": {
    ///      "description": "A description of the cost subtotal",
    ///      "examples": [
    ///        "Credit card - Visa debit consumer domestic"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "method": {
    ///      "$ref": "#/components/schemas/payment-method"
    ///    },
    ///    "rate": {
    ///      "description": "The service rates, further divided into `fixed` and
    /// `percentage` costs.",
    ///      "type": "object",
    ///      "properties": {
    ///        "fixed": {
    ///          "$ref": "#/components/schemas/amount"
    ///        },
    ///        "percentage": {
    ///          "examples": [
    ///            "2.5"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntitySettlementPeriodsValueValueCostsItem {
        #[serde(rename = "amountGross")]
        pub amount_gross: Amount,
        #[serde(rename = "amountNet")]
        pub amount_net: Amount,
        #[serde(rename = "amountVat")]
        pub amount_vat: AmountNullable,
        ///The number of fees
        pub count: i64,
        ///A description of the cost subtotal
        pub description: ::std::string::String,
        pub method: PaymentMethod,
        pub rate: EntitySettlementPeriodsValueValueCostsItemRate,
    }

    impl ::std::convert::From<&EntitySettlementPeriodsValueValueCostsItem>
        for EntitySettlementPeriodsValueValueCostsItem
    {
        fn from(value: &EntitySettlementPeriodsValueValueCostsItem) -> Self {
            value.clone()
        }
    }

    ///The service rates, further divided into `fixed` and `percentage` costs.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The service rates, further divided into `fixed` and
    /// `percentage` costs.",
    ///  "type": "object",
    ///  "properties": {
    ///    "fixed": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "percentage": {
    ///      "examples": [
    ///        "2.5"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntitySettlementPeriodsValueValueCostsItemRate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub fixed: ::std::option::Option<Amount>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub percentage: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntitySettlementPeriodsValueValueCostsItemRate>
        for EntitySettlementPeriodsValueValueCostsItemRate
    {
        fn from(value: &EntitySettlementPeriodsValueValueCostsItemRate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntitySettlementPeriodsValueValueCostsItemRate {
        fn default() -> Self {
            Self {
                fixed: Default::default(),
                percentage: Default::default(),
            }
        }
    }

    ///`EntitySettlementPeriodsValueValueRevenueItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amountGross",
    ///    "amountNet",
    ///    "amountVat",
    ///    "count",
    ///    "description",
    ///    "method"
    ///  ],
    ///  "properties": {
    ///    "amountGross": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "amountNet": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "amountVat": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "count": {
    ///      "description": "The number of payments",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "description": {
    ///      "description": "A description of the revenue subtotal",
    ///      "examples": [
    ///        "Credit card"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "method": {
    ///      "$ref": "#/components/schemas/payment-method"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntitySettlementPeriodsValueValueRevenueItem {
        #[serde(rename = "amountGross")]
        pub amount_gross: Amount,
        #[serde(rename = "amountNet")]
        pub amount_net: Amount,
        #[serde(rename = "amountVat")]
        pub amount_vat: AmountNullable,
        ///The number of payments
        pub count: i64,
        ///A description of the revenue subtotal
        pub description: ::std::string::String,
        pub method: PaymentMethod,
    }

    impl ::std::convert::From<&EntitySettlementPeriodsValueValueRevenueItem>
        for EntitySettlementPeriodsValueValueRevenueItem
    {
        fn from(value: &EntitySettlementPeriodsValueValueRevenueItem) -> Self {
            value.clone()
        }
    }

    ///`EntitySubscription`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "customer",
    ///        "documentation",
    ///        "profile",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "customer": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        },
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "mandate": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        },
    ///        "payments": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        },
    ///        "profile": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "applicationFee": {
    ///      "description": "With Mollie Connect you can charge fees on payments
    /// that your app is processing on behalf of other
    /// Mollie\nmerchants.\n\nSetting an application fee on the subscription
    /// will ensure this fee is charged on each individual payment.\n\nRefer to
    /// the `applicationFee` parameter on the [Get payment
    /// endpoint](get-payment) documentation for more\ninformation.",
    ///      "type": "object",
    ///      "required": [
    ///        "amount",
    ///        "description"
    ///      ],
    ///      "properties": {
    ///        "amount": {
    ///          "$ref": "#/components/schemas/amount"
    ///        },
    ///        "description": {
    ///          "examples": [
    ///            "Platform fee"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "canceledAt": {
    ///      "description": "The subscription's date and time of cancellation,
    /// in ISO 8601 format. This parameter is omitted if the\nsubscription is
    /// not canceled (yet).",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2025-01-01T13:10:19.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "customerId": {
    ///      "$ref": "#/components/schemas/customerToken"
    ///    },
    ///    "description": {
    ///      "description": "The subscription's description will be used as the
    /// description of the resulting individual payments and so showing\nup on
    /// the bank statement of the consumer.\n\n**Please note:** the description
    /// needs to be unique for the Customer in case it has multiple active
    /// subscriptions.",
    ///      "examples": [
    ///        "Subscription of streaming channel"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/subscriptionToken"
    ///    },
    ///    "interval": {
    ///      "description": "Interval to wait between payments, for example `1
    /// month` or `14 days`.\n\nThe maximum interval is one year (`12 months`,
    /// `52 weeks`, or `365 days`).\n\nPossible values: `... days`, `... weeks`,
    /// `... months`.",
    ///      "examples": [
    ///        "2 days"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\d+ (days|weeks|months)$"
    ///    },
    ///    "mandateId": {
    ///      "$ref": "#/components/schemas/mandateToken"
    ///    },
    ///    "metadata": {
    ///      "$ref": "#/components/schemas/metadata"
    ///    },
    ///    "method": {
    ///      "$ref": "#/components/schemas/subscription-method-response"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "nextPaymentDate": {
    ///      "description": "The date of the next scheduled payment in
    /// `YYYY-MM-DD` format. If the subscription has been completed or
    /// canceled,\nthis parameter will not be returned.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2025-01-01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a subscription
    /// object. Will always contain the string `subscription` for
    /// this\nendpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "subscription"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "startDate": {
    ///      "description": "The start date of the subscription in `YYYY-MM-DD`
    /// format.",
    ///      "examples": [
    ///        "2025-01-01"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/subscription-status"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    },
    ///    "times": {
    ///      "description": "Total number of payments for the subscription. Once
    /// this number of payments is reached, the subscription is\nconsidered
    /// completed.\n\nTest mode subscriptions will get canceled automatically
    /// after 10 payments.",
    ///      "examples": [
    ///        6
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "timesRemaining": {
    ///      "description": "Number of payments left for the subscription.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        5
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "webhookUrl": {
    ///      "description": "We will call this URL for any payment status
    /// changes of payments resulting from this subscription.\n\nThis webhook
    /// will receive **all** events for the subscription's payments. This may
    /// include payment failures as\nwell. Be sure to verify the payment's
    /// subscription ID and its status.",
    ///      "examples": [
    ///        "https://example.com/webhook"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntitySubscription {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<Amount>,
        #[serde(
            rename = "applicationFee",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub application_fee: ::std::option::Option<EntitySubscriptionApplicationFee>,
        ///The subscription's date and time of cancellation, in ISO 8601
        /// format. This parameter is omitted if the subscription is not
        /// canceled (yet).
        #[serde(
            rename = "canceledAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub canceled_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        #[serde(
            rename = "customerId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub customer_id: ::std::option::Option<CustomerToken>,
        ///The subscription's description will be used as the description of
        /// the resulting individual payments and so showing
        /// up on the bank statement of the consumer.
        ///
        ///**Please note:** the description needs to be unique for the Customer
        /// in case it has multiple active subscriptions.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<SubscriptionToken>,
        ///Interval to wait between payments, for example `1 month` or `14
        /// days`.
        ///
        ///The maximum interval is one year (`12 months`, `52 weeks`, or `365
        /// days`).
        ///
        ///Possible values: `... days`, `... weeks`, `... months`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub interval: ::std::option::Option<EntitySubscriptionInterval>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<EntitySubscriptionLinks>,
        #[serde(
            rename = "mandateId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub mandate_id: ::std::option::Option<MandateToken>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<Metadata>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub method: ::std::option::Option<SubscriptionMethodResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<Mode>,
        ///The date of the next scheduled payment in `YYYY-MM-DD` format. If
        /// the subscription has been completed or canceled,
        /// this parameter will not be returned.
        #[serde(
            rename = "nextPaymentDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub next_payment_date: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a subscription object. Will always
        /// contain the string `subscription` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        ///The start date of the subscription in `YYYY-MM-DD` format.
        #[serde(
            rename = "startDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub start_date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<SubscriptionStatus>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
        ///Total number of payments for the subscription. Once this number of
        /// payments is reached, the subscription is considered
        /// completed.
        ///
        ///Test mode subscriptions will get canceled automatically after 10
        /// payments.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub times: ::std::option::Option<i64>,
        ///Number of payments left for the subscription.
        #[serde(
            rename = "timesRemaining",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub times_remaining: ::std::option::Option<i64>,
        ///We will call this URL for any payment status changes of payments
        /// resulting from this subscription.
        ///
        ///This webhook will receive **all** events for the subscription's
        /// payments. This may include payment failures as well. Be sure
        /// to verify the payment's subscription ID and its status.
        #[serde(
            rename = "webhookUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub webhook_url: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EntitySubscription> for EntitySubscription {
        fn from(value: &EntitySubscription) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntitySubscription {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                application_fee: Default::default(),
                canceled_at: Default::default(),
                created_at: Default::default(),
                customer_id: Default::default(),
                description: Default::default(),
                id: Default::default(),
                interval: Default::default(),
                links: Default::default(),
                mandate_id: Default::default(),
                metadata: Default::default(),
                method: Default::default(),
                mode: Default::default(),
                next_payment_date: Default::default(),
                resource: Default::default(),
                start_date: Default::default(),
                status: Default::default(),
                testmode: Default::default(),
                times: Default::default(),
                times_remaining: Default::default(),
                webhook_url: Default::default(),
            }
        }
    }

    ///With Mollie Connect you can charge fees on payments that your app is
    /// processing on behalf of other Mollie merchants.
    ///
    ///Setting an application fee on the subscription will ensure this fee is
    /// charged on each individual payment.
    ///
    ///Refer to the `applicationFee` parameter on the [Get payment
    /// endpoint](get-payment) documentation for more information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "With Mollie Connect you can charge fees on payments
    /// that your app is processing on behalf of other
    /// Mollie\nmerchants.\n\nSetting an application fee on the subscription
    /// will ensure this fee is charged on each individual payment.\n\nRefer to
    /// the `applicationFee` parameter on the [Get payment
    /// endpoint](get-payment) documentation for more\ninformation.",
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "description"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "Platform fee"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntitySubscriptionApplicationFee {
        pub amount: Amount,
        pub description: ::std::string::String,
    }

    impl ::std::convert::From<&EntitySubscriptionApplicationFee> for EntitySubscriptionApplicationFee {
        fn from(value: &EntitySubscriptionApplicationFee) -> Self {
            value.clone()
        }
    }

    ///Interval to wait between payments, for example `1 month` or `14 days`.
    ///
    ///The maximum interval is one year (`12 months`, `52 weeks`, or `365
    /// days`).
    ///
    ///Possible values: `... days`, `... weeks`, `... months`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Interval to wait between payments, for example `1
    /// month` or `14 days`.\n\nThe maximum interval is one year (`12 months`,
    /// `52 weeks`, or `365 days`).\n\nPossible values: `... days`, `... weeks`,
    /// `... months`.",
    ///  "examples": [
    ///    "2 days"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+ (days|weeks|months)$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntitySubscriptionInterval(::std::string::String);
    impl ::std::ops::Deref for EntitySubscriptionInterval {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntitySubscriptionInterval> for ::std::string::String {
        fn from(value: EntitySubscriptionInterval) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntitySubscriptionInterval> for EntitySubscriptionInterval {
        fn from(value: &EntitySubscriptionInterval) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntitySubscriptionInterval {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^\\d+ (days|weeks|months)$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+ (days|weeks|months)$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntitySubscriptionInterval {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntitySubscriptionInterval {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntitySubscriptionInterval {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntitySubscriptionInterval {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "customer",
    ///    "documentation",
    ///    "profile",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "customer": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "mandate": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "payments": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "profile": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntitySubscriptionLinks {
        pub customer: UrlNullable,
        pub documentation: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mandate: ::std::option::Option<UrlNullable>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payments: ::std::option::Option<UrlNullable>,
        pub profile: UrlNullable,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&EntitySubscriptionLinks> for EntitySubscriptionLinks {
        fn from(value: &EntitySubscriptionLinks) -> Self {
            value.clone()
        }
    }

    ///`EntityTerminal`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_links",
    ///    "brand",
    ///    "createdAt",
    ///    "currency",
    ///    "description",
    ///    "id",
    ///    "mode",
    ///    "model",
    ///    "profileId",
    ///    "resource",
    ///    "serialNumber",
    ///    "status",
    ///    "updatedAt"
    ///  ],
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "documentation",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "brand": {
    ///      "$ref": "#/components/schemas/terminal-brand"
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "currency": {
    ///      "description": "The currency configured on the terminal, in ISO
    /// 4217 format. Currently most of our terminals are bound to a\nspecific
    /// currency, chosen during setup.",
    ///      "examples": [
    ///        "EUR"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "description": "A short description of the terminal. The
    /// description can be used as an identifier for the terminal. Currently,
    /// the\ndescription is set when the terminal is initially configured. It
    /// will be visible in the Mollie Dashboard, and it\nmay be visible on the
    /// device itself depending on the device.",
    ///      "examples": [
    ///        "Main Terminal"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/terminalToken"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "model": {
    ///      "$ref": "#/components/schemas/terminal-model"
    ///    },
    ///    "profileId": {
    ///      "$ref": "#/components/schemas/profileToken"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a terminal object.
    /// Will always contain the string `terminal` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "terminal"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "serialNumber": {
    ///      "description": "The serial number of the terminal. The serial
    /// number is provided at terminal creation time.",
    ///      "examples": [
    ///        "1234567890"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/terminal-status"
    ///    },
    ///    "updatedAt": {
    ///      "description": "The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.",
    ///      "examples": [
    ///        "2025-03-20T09:13:37.0Z"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityTerminal {
        pub brand: TerminalBrand,
        #[serde(rename = "createdAt")]
        pub created_at: CreatedAt,
        ///The currency configured on the terminal, in ISO 4217 format.
        /// Currently most of our terminals are bound to a
        /// specific currency, chosen during setup.
        pub currency: ::std::string::String,
        ///A short description of the terminal. The description can be used as
        /// an identifier for the terminal. Currently, the description
        /// is set when the terminal is initially configured. It will be visible
        /// in the Mollie Dashboard, and it may be visible on the device
        /// itself depending on the device.
        pub description: EntityTerminalDescription,
        pub id: TerminalToken,
        #[serde(rename = "_links")]
        pub links: EntityTerminalLinks,
        pub mode: Mode,
        pub model: TerminalModel,
        #[serde(rename = "profileId")]
        pub profile_id: ProfileToken,
        ///Indicates the response contains a terminal object. Will always
        /// contain the string `terminal` for this endpoint.
        pub resource: ::std::string::String,
        ///The serial number of the terminal. The serial number is provided at
        /// terminal creation time.
        #[serde(rename = "serialNumber")]
        pub serial_number: ::std::option::Option<::std::string::String>,
        pub status: TerminalStatus,
        ///The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        #[serde(rename = "updatedAt")]
        pub updated_at: ::std::string::String,
    }

    impl ::std::convert::From<&EntityTerminal> for EntityTerminal {
        fn from(value: &EntityTerminal) -> Self {
            value.clone()
        }
    }

    ///A short description of the terminal. The description can be used as an
    /// identifier for the terminal. Currently, the description is set when
    /// the terminal is initially configured. It will be visible in the Mollie
    /// Dashboard, and it may be visible on the device itself depending on
    /// the device.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A short description of the terminal. The description
    /// can be used as an identifier for the terminal. Currently,
    /// the\ndescription is set when the terminal is initially configured. It
    /// will be visible in the Mollie Dashboard, and it\nmay be visible on the
    /// device itself depending on the device.",
    ///  "examples": [
    ///    "Main Terminal"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EntityTerminalDescription(::std::string::String);
    impl ::std::ops::Deref for EntityTerminalDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EntityTerminalDescription> for ::std::string::String {
        fn from(value: EntityTerminalDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EntityTerminalDescription> for EntityTerminalDescription {
        fn from(value: &EntityTerminalDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EntityTerminalDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EntityTerminalDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EntityTerminalDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EntityTerminalDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EntityTerminalDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "documentation",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityTerminalLinks {
        pub documentation: Url,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&EntityTerminalLinks> for EntityTerminalLinks {
        fn from(value: &EntityTerminalLinks) -> Self {
            value.clone()
        }
    }

    ///`EntityWebhook`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_links",
    ///    "createdAt",
    ///    "eventTypes",
    ///    "id",
    ///    "mode",
    ///    "name",
    ///    "profileId",
    ///    "resource",
    ///    "status",
    ///    "url"
    ///  ],
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "documentation",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "createdAt": {
    ///      "description": "The subscription's date time of creation.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2023-03-15T10:00:00Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "eventTypes": {
    ///      "description": "The events types that are subscribed.",
    ///      "examples": [
    ///        [
    ///          "profile.create",
    ///          "profile.blocked"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/webhook-event-types-response"
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "The identifier uniquely referring to this
    /// subscription.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "hook_tNP6fpF9fLJpFWziRcgiH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "name": {
    ///      "description": "The subscription's name.",
    ///      "examples": [
    ///        "Profile Updates Webhook"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "profileId": {
    ///      "description": "The identifier uniquely referring to the profile
    /// that created the subscription.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "pfl_YyoaNFjtHc"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a webhook
    /// subscription object.\nWill always contain the string `webhook` for this
    /// endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "webhook"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/webhook-status"
    ///    },
    ///    "url": {
    ///      "description": "The subscription's events destination.",
    ///      "examples": [
    ///        "https://example.com/webhook-endpoint"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityWebhook {
        ///The subscription's date time of creation.
        #[serde(rename = "createdAt")]
        pub created_at: ::std::string::String,
        ///The events types that are subscribed.
        #[serde(rename = "eventTypes")]
        pub event_types: ::std::vec::Vec<WebhookEventTypesResponse>,
        ///The identifier uniquely referring to this subscription.
        pub id: ::std::string::String,
        #[serde(rename = "_links")]
        pub links: EntityWebhookLinks,
        pub mode: Mode,
        ///The subscription's name.
        pub name: ::std::string::String,
        ///The identifier uniquely referring to the profile that created the
        /// subscription.
        #[serde(rename = "profileId")]
        pub profile_id: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a webhook subscription object.
        ///Will always contain the string `webhook` for this endpoint.
        pub resource: ::std::string::String,
        pub status: WebhookStatus,
        ///The subscription's events destination.
        pub url: ::std::string::String,
    }

    impl ::std::convert::From<&EntityWebhook> for EntityWebhook {
        fn from(value: &EntityWebhook) -> Self {
            value.clone()
        }
    }

    ///`EntityWebhookEvent`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_links",
    ///    "createdAt",
    ///    "entityId",
    ///    "id",
    ///    "resource",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "description": "Full payload of the event.",
    ///      "readOnly": true,
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "properties": {
    ///        "entity": {
    ///          "oneOf": [
    ///            {
    ///              "$ref": "#/components/schemas/payment-link-response"
    ///            },
    ///            {
    ///              "$ref": "#/components/schemas/entity-profile-response"
    ///            }
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "documentation",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "entity": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "createdAt": {
    ///      "description": "The event's date time of creation.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2024-06-10T14:23:45Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "entityId": {
    ///      "description": "The entity token that triggered the event",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "pl_qng5gbbv8NAZ5gpM5ZYgx"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "The identifier uniquely referring to this event.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "event_GvJ8WHrp5isUdRub9CJyH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a webhook event
    /// object. Will always contain the string `event` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "event"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/webhook-event-types-response"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityWebhookEvent {
        ///The event's date time of creation.
        #[serde(rename = "createdAt")]
        pub created_at: ::std::string::String,
        ///Full payload of the event.
        #[serde(
            rename = "_embedded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub embedded: ::std::option::Option<EntityWebhookEventEmbedded>,
        ///The entity token that triggered the event
        #[serde(rename = "entityId")]
        pub entity_id: ::std::string::String,
        ///The identifier uniquely referring to this event.
        pub id: ::std::string::String,
        #[serde(rename = "_links")]
        pub links: EntityWebhookEventLinks,
        ///Indicates the response contains a webhook event object. Will always
        /// contain the string `event` for this endpoint.
        pub resource: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: WebhookEventTypesResponse,
    }

    impl ::std::convert::From<&EntityWebhookEvent> for EntityWebhookEvent {
        fn from(value: &EntityWebhookEvent) -> Self {
            value.clone()
        }
    }

    ///Full payload of the event.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Full payload of the event.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "entity": {
    ///      "oneOf": [
    ///        {
    ///          "$ref": "#/components/schemas/payment-link-response"
    ///        },
    ///        {
    ///          "$ref": "#/components/schemas/entity-profile-response"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityWebhookEventEmbedded {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub entity: ::std::option::Option<EntityWebhookEventEmbeddedEntity>,
    }

    impl ::std::convert::From<&EntityWebhookEventEmbedded> for EntityWebhookEventEmbedded {
        fn from(value: &EntityWebhookEventEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EntityWebhookEventEmbedded {
        fn default() -> Self {
            Self {
                entity: Default::default(),
            }
        }
    }

    ///`EntityWebhookEventEmbeddedEntity`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/payment-link-response"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/entity-profile-response"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EntityWebhookEventEmbeddedEntity {
        PaymentLinkResponse(PaymentLinkResponse),
        EntityProfileResponse(EntityProfileResponse),
    }

    impl ::std::convert::From<&Self> for EntityWebhookEventEmbeddedEntity {
        fn from(value: &EntityWebhookEventEmbeddedEntity) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<PaymentLinkResponse> for EntityWebhookEventEmbeddedEntity {
        fn from(value: PaymentLinkResponse) -> Self {
            Self::PaymentLinkResponse(value)
        }
    }

    impl ::std::convert::From<EntityProfileResponse> for EntityWebhookEventEmbeddedEntity {
        fn from(value: EntityProfileResponse) -> Self {
            Self::EntityProfileResponse(value)
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "documentation",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "entity": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityWebhookEventLinks {
        pub documentation: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub entity: ::std::option::Option<Url>,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&EntityWebhookEventLinks> for EntityWebhookEventLinks {
        fn from(value: &EntityWebhookEventLinks) -> Self {
            value.clone()
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "documentation",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EntityWebhookLinks {
        pub documentation: Url,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&EntityWebhookLinks> for EntityWebhookLinks {
        fn from(value: &EntityWebhookLinks) -> Self {
            value.clone()
        }
    }

    ///An error response object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An error response object.",
    ///  "type": "object",
    ///  "required": [
    ///    "_links",
    ///    "detail",
    ///    "status",
    ///    "title"
    ///  ],
    ///  "properties": {
    ///    "_links": {
    ///      "type": "object",
    ///      "required": [
    ///        "documentation"
    ///      ],
    ///      "properties": {
    ///        "documentation": {
    ///          "description": "The URL to the generic Mollie API error
    /// handling guide.",
    ///          "type": "object",
    ///          "required": [
    ///            "href",
    ///            "type"
    ///          ],
    ///          "properties": {
    ///            "href": {
    ///              "examples": [
    ///                "https://docs.mollie.com/errors"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "type": {
    ///              "examples": [
    ///                "text/html"
    ///              ],
    ///              "type": "string"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "detail": {
    ///      "description": "A detailed human-readable description of the error
    /// that occurred.",
    ///      "examples": [
    ///        "The resource does not exist"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "field": {
    ///      "description": "If the error was caused by a value provided by you
    /// in a specific field, the `field` property will contain the name\nof the
    /// field that caused the issue.",
    ///      "examples": [
    ///        "description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "description": "The status code of the error message. This is always the same code as the status code of the HTTP message itself.",
    ///      "examples": [
    ///        404
    ///      ],
    ///      "type": "integer",
    ///      "maximum": 599.0,
    ///      "minimum": 400.0
    ///    },
    ///    "title": {
    ///      "description": "The HTTP reason phrase of the error. For example,
    /// for a `404` error, the `title` will be `Not Found`.",
    ///      "examples": [
    ///        "Not Found"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ErrorResponse {
        ///A detailed human-readable description of the error that occurred.
        pub detail: ::std::string::String,
        ///If the error was caused by a value provided by you in a specific
        /// field, the `field` property will contain the name
        /// of the field that caused the issue.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub field: ::std::option::Option<::std::string::String>,
        #[serde(rename = "_links")]
        pub links: ErrorResponseLinks,
        ///The status code of the error message. This is always the same code
        /// as the status code of the HTTP message itself.
        pub status: i64,
        ///The HTTP reason phrase of the error. For example, for a `404` error,
        /// the `title` will be `Not Found`.
        pub title: ::std::string::String,
    }

    impl ::std::convert::From<&ErrorResponse> for ErrorResponse {
        fn from(value: &ErrorResponse) -> Self {
            value.clone()
        }
    }

    ///`ErrorResponseLinks`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "documentation"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "description": "The URL to the generic Mollie API error handling
    /// guide.",
    ///      "type": "object",
    ///      "required": [
    ///        "href",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "href": {
    ///          "examples": [
    ///            "https://docs.mollie.com/errors"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "examples": [
    ///            "text/html"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ErrorResponseLinks {
        pub documentation: ErrorResponseLinksDocumentation,
    }

    impl ::std::convert::From<&ErrorResponseLinks> for ErrorResponseLinks {
        fn from(value: &ErrorResponseLinks) -> Self {
            value.clone()
        }
    }

    ///The URL to the generic Mollie API error handling guide.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The URL to the generic Mollie API error handling
    /// guide.",
    ///  "type": "object",
    ///  "required": [
    ///    "href",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "examples": [
    ///        "https://docs.mollie.com/errors"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "text/html"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ErrorResponseLinksDocumentation {
        pub href: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }

    impl ::std::convert::From<&ErrorResponseLinksDocumentation> for ErrorResponseLinksDocumentation {
        fn from(value: &ErrorResponseLinksDocumentation) -> Self {
            value.clone()
        }
    }

    ///`ExtraParameterParameters`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "applePayPaymentToken": {
    ///      "description": "The Apple Pay Payment token object (encoded as
    /// JSON) that is part of the result of authorizing a payment request.\nThe
    /// token contains the payment information needed to authorize the
    /// payment.\n\nThe object should be passed encoded in a JSON string.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "{\"paymentData\": {\"version\": \"EC_v1\", \"data\":
    /// \"vK3BbrCbI/....\"}}"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardToken": {
    ///      "description": "When creating credit card payments using Mollie
    /// Components, you need to provide the card token you received from\nthe
    /// card component in this field. The token represents the customer's card
    /// information needed to complete the\npayment. Note: field only valid for
    /// oneoff and first payments. For recurring payments, the customerId alone
    /// is\nenough.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "tkn_12345"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "company": {
    ///      "description": "Billie is a business-to-business (B2B) payment
    /// method. It requires extra information to identify the organization\nthat
    /// is completing the payment. It is recommended to include these parameters
    /// up front for a seamless flow.\nOtherwise, Billie will ask the customer
    /// to complete the missing fields during checkout.",
    ///      "writeOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "entityType": {
    ///          "description": "The organization's entity type.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "registrationNumber": {
    ///          "description": "The organization's registration number.",
    ///          "examples": [
    ///            "12345678"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "vatNumber": {
    ///          "description": "The organization's VAT number.",
    ///          "examples": [
    ///            "NL123456789B01"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      },
    ///      "x-methodSpecific": true
    ///    },
    ///    "consumerDateOfBirth": {
    ///      "description": "The customer's date of birth. If not provided via
    /// the API, iDeal in3 will ask the customer to provide it during\nthe
    /// payment process.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "2000-01-01"
    ///      ],
    ///      "type": "string",
    ///      "format": "date",
    ///      "x-methodSpecific": true
    ///    },
    ///    "customerReference": {
    ///      "description": "Used by paysafecard for customer identification
    /// across payments. When you generate a customer reference yourself,\nmake
    /// sure not to put personal identifiable information or IP addresses in the
    /// customer reference directly.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "1234567890"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "digitalGoods": {
    ///      "description": "Indicate if you are about to deliver digital goods,
    /// such as for example a software license. Setting this parameter\ncan have
    /// consequences for your PayPal Seller Protection. Refer to PayPal's
    /// documentation for more information.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean",
    ///      "x-methodSpecific": true
    ///    },
    ///    "extraMerchantData": {
    ///      "description": "For some industries, additional purchase
    /// information can be sent to Klarna to increase the authorization
    /// rate.\nYou can submit your extra data in this field if you have agreed
    /// upon this with Klarna. This field should be an\nobject containing any of
    /// the allowed keys and sub-objects described at the Klarna Developer
    /// Documentation.",
    ///      "writeOnly": true,
    ///      "type": "object",
    ///      "additionalProperties": true,
    ///      "x-methodSpecific": true
    ///    },
    ///    "sessionId": {
    ///      "description": "The unique ID you have used for the PayPal fraud
    /// library. You should include this if you use PayPal for an\non-demand
    /// payment.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "terminalId": {
    ///      "description": "The ID of the terminal device where you want to
    /// initiate the payment on.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "term_1234567890"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "voucherNumber": {
    ///      "description": "The card token you received from the card component
    /// of Mollie Components. The token represents the customer's
    /// card\ninformation needed to complete the payment.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "1234567890"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "voucherPin": {
    ///      "description": "The PIN on the gift card. You can supply this to
    /// prefill the PIN, if the card has any.",
    ///      "writeOnly": true,
    ///      "examples": [
    ///        "1234"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ExtraParameterParameters {
        ///The Apple Pay Payment token object (encoded as JSON) that is part of
        /// the result of authorizing a payment request.
        /// The token contains the payment information needed to authorize the
        /// payment.
        ///
        ///The object should be passed encoded in a JSON string.
        #[serde(
            rename = "applePayPaymentToken",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub apple_pay_payment_token: ::std::option::Option<::std::string::String>,
        ///When creating credit card payments using Mollie Components, you need
        /// to provide the card token you received from
        /// the card component in this field. The token represents the
        /// customer's card information needed to complete the
        /// payment. Note: field only valid for oneoff and first payments. For
        /// recurring payments, the customerId alone is enough.
        #[serde(
            rename = "cardToken",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_token: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub company: ::std::option::Option<ExtraParameterParametersCompany>,
        ///The customer's date of birth. If not provided via the API, iDeal in3
        /// will ask the customer to provide it during the payment
        /// process.
        #[serde(
            rename = "consumerDateOfBirth",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_date_of_birth: ::std::option::Option<::chrono::naive::NaiveDate>,
        ///Used by paysafecard for customer identification across payments.
        /// When you generate a customer reference yourself,
        /// make sure not to put personal identifiable information or IP
        /// addresses in the customer reference directly.
        #[serde(
            rename = "customerReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub customer_reference: ::std::option::Option<::std::string::String>,
        ///Indicate if you are about to deliver digital goods, such as for
        /// example a software license. Setting this parameter
        /// can have consequences for your PayPal Seller Protection. Refer to
        /// PayPal's documentation for more information.
        #[serde(
            rename = "digitalGoods",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub digital_goods: ::std::option::Option<bool>,
        ///For some industries, additional purchase information can be sent to
        /// Klarna to increase the authorization rate. You can submit
        /// your extra data in this field if you have agreed upon this with
        /// Klarna. This field should be an object containing any of the
        /// allowed keys and sub-objects described at the Klarna Developer
        /// Documentation.
        #[serde(
            rename = "extraMerchantData",
            default,
            skip_serializing_if = "::serde_json::Map::is_empty"
        )]
        pub extra_merchant_data: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        ///The unique ID you have used for the PayPal fraud library. You should
        /// include this if you use PayPal for an on-demand payment.
        #[serde(
            rename = "sessionId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub session_id: ::std::option::Option<::std::string::String>,
        ///The ID of the terminal device where you want to initiate the payment
        /// on.
        #[serde(
            rename = "terminalId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub terminal_id: ::std::option::Option<::std::string::String>,
        ///The card token you received from the card component of Mollie
        /// Components. The token represents the customer's card
        /// information needed to complete the payment.
        #[serde(
            rename = "voucherNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub voucher_number: ::std::option::Option<::std::string::String>,
        ///The PIN on the gift card. You can supply this to prefill the PIN, if
        /// the card has any.
        #[serde(
            rename = "voucherPin",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub voucher_pin: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ExtraParameterParameters> for ExtraParameterParameters {
        fn from(value: &ExtraParameterParameters) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ExtraParameterParameters {
        fn default() -> Self {
            Self {
                apple_pay_payment_token: Default::default(),
                card_token: Default::default(),
                company: Default::default(),
                consumer_date_of_birth: Default::default(),
                customer_reference: Default::default(),
                digital_goods: Default::default(),
                extra_merchant_data: Default::default(),
                session_id: Default::default(),
                terminal_id: Default::default(),
                voucher_number: Default::default(),
                voucher_pin: Default::default(),
            }
        }
    }

    ///Billie is a business-to-business (B2B) payment method. It requires extra
    /// information to identify the organization that is completing the
    /// payment. It is recommended to include these parameters up front for a
    /// seamless flow. Otherwise, Billie will ask the customer to complete
    /// the missing fields during checkout.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Billie is a business-to-business (B2B) payment method.
    /// It requires extra information to identify the organization\nthat is
    /// completing the payment. It is recommended to include these parameters up
    /// front for a seamless flow.\nOtherwise, Billie will ask the customer to
    /// complete the missing fields during checkout.",
    ///  "writeOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "entityType": {
    ///      "description": "The organization's entity type.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "registrationNumber": {
    ///      "description": "The organization's registration number.",
    ///      "examples": [
    ///        "12345678"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "vatNumber": {
    ///      "description": "The organization's VAT number.",
    ///      "examples": [
    ///        "NL123456789B01"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-methodSpecific": true
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ExtraParameterParametersCompany {
        ///The organization's entity type.
        #[serde(
            rename = "entityType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub entity_type: ::std::option::Option<::std::string::String>,
        ///The organization's registration number.
        #[serde(
            rename = "registrationNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub registration_number: ::std::option::Option<::std::string::String>,
        ///The organization's VAT number.
        #[serde(
            rename = "vatNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_number: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ExtraParameterParametersCompany> for ExtraParameterParametersCompany {
        fn from(value: &ExtraParameterParametersCompany) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ExtraParameterParametersCompany {
        fn default() -> Self {
            Self {
                entity_type: Default::default(),
                registration_number: Default::default(),
                vat_number: Default::default(),
            }
        }
    }

    ///`GetBalanceReportGrouping`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "status-balances"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "status-balances",
    ///    "transaction-categories"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetBalanceReportGrouping {
        #[serde(rename = "status-balances")]
        StatusBalances,
        #[serde(rename = "transaction-categories")]
        TransactionCategories,
    }

    impl ::std::convert::From<&Self> for GetBalanceReportGrouping {
        fn from(value: &GetBalanceReportGrouping) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetBalanceReportGrouping {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::StatusBalances => f.write_str("status-balances"),
                Self::TransactionCategories => f.write_str("transaction-categories"),
            }
        }
    }

    impl ::std::str::FromStr for GetBalanceReportGrouping {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "status-balances" => Ok(Self::StatusBalances),
                "transaction-categories" => Ok(Self::TransactionCategories),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetBalanceReportGrouping {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetBalanceReportGrouping {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetBalanceReportGrouping {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetClientResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/entity-client"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "_embedded": {
    ///          "type": "object",
    ///          "properties": {
    ///            "capabilities": {
    ///              "$ref": "#/components/schemas/entity-capability"
    ///            },
    ///            "onboarding": {
    ///              "$ref": "#/components/schemas/entity-onboarding-status"
    ///            },
    ///            "organization": {
    ///              "$ref": "#/components/schemas/entity-organization"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetClientResponse {
        ///The commission object.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub commission: ::std::option::Option<GetClientResponseCommission>,
        #[serde(
            rename = "_embedded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub embedded: ::std::option::Option<GetClientResponseEmbedded>,
        ///The identifier uniquely referring to this client. Example:
        /// `org_12345678`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<GetClientResponseLinks>,
        ///The date and time the client organization was created, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
        ///format.
        #[serde(
            rename = "organizationCreatedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub organization_created_at: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a client object. Will always contain
        /// the string `client` for this resource type.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&GetClientResponse> for GetClientResponse {
        fn from(value: &GetClientResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GetClientResponse {
        fn default() -> Self {
            Self {
                commission: Default::default(),
                embedded: Default::default(),
                id: Default::default(),
                links: Default::default(),
                organization_created_at: Default::default(),
                resource: Default::default(),
            }
        }
    }

    ///The commission object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The commission object.",
    ///  "type": "object",
    ///  "properties": {
    ///    "count": {
    ///      "description": "The commission count.",
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetClientResponseCommission {
        ///The commission count.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<i64>,
    }

    impl ::std::convert::From<&GetClientResponseCommission> for GetClientResponseCommission {
        fn from(value: &GetClientResponseCommission) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GetClientResponseCommission {
        fn default() -> Self {
            Self {
                count: Default::default(),
            }
        }
    }

    ///`GetClientResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "capabilities": {
    ///      "$ref": "#/components/schemas/entity-capability"
    ///    },
    ///    "onboarding": {
    ///      "$ref": "#/components/schemas/entity-onboarding-status"
    ///    },
    ///    "organization": {
    ///      "$ref": "#/components/schemas/entity-organization"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetClientResponseEmbedded {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub capabilities: ::std::option::Option<EntityCapability>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub onboarding: ::std::option::Option<EntityOnboardingStatus>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub organization: ::std::option::Option<EntityOrganization>,
    }

    impl ::std::convert::From<&GetClientResponseEmbedded> for GetClientResponseEmbedded {
        fn from(value: &GetClientResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GetClientResponseEmbedded {
        fn default() -> Self {
            Self {
                capabilities: Default::default(),
                onboarding: Default::default(),
                organization: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "onboarding": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "organization": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetClientResponseLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub onboarding: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub organization: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&GetClientResponseLinks> for GetClientResponseLinks {
        fn from(value: &GetClientResponseLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GetClientResponseLinks {
        fn default() -> Self {
            Self {
                documentation: Default::default(),
                onboarding: Default::default(),
                organization: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///`GetCustomerResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/customer-response"
    ///    },
    ///    {
    ///      "properties": {
    ///        "events": {
    ///          "readOnly": true,
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-event"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetCustomerResponse {
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        ///The email address of the customer.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub events: ::std::vec::Vec<EntityEvent>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<CustomerToken>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<GetCustomerResponseLinks>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub locale: ::std::option::Option<LocaleResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<Metadata>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<Mode>,
        ///The full name of the customer.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a customer object. Will always
        /// contain the string `customer` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
    }

    impl ::std::convert::From<&GetCustomerResponse> for GetCustomerResponse {
        fn from(value: &GetCustomerResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GetCustomerResponse {
        fn default() -> Self {
            Self {
                created_at: Default::default(),
                email: Default::default(),
                events: Default::default(),
                id: Default::default(),
                links: Default::default(),
                locale: Default::default(),
                metadata: Default::default(),
                mode: Default::default(),
                name: Default::default(),
                resource: Default::default(),
                testmode: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "dashboard",
    ///    "documentation",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "dashboard": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "mandates": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "payments": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "subscriptions": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetCustomerResponseLinks {
        pub dashboard: Url,
        pub documentation: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mandates: ::std::option::Option<UrlNullable>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payments: ::std::option::Option<UrlNullable>,
        #[serde(rename = "self")]
        pub self_: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub subscriptions: ::std::option::Option<UrlNullable>,
    }

    impl ::std::convert::From<&GetCustomerResponseLinks> for GetCustomerResponseLinks {
        fn from(value: &GetCustomerResponseLinks) -> Self {
            value.clone()
        }
    }

    ///`GetMethodLocale`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "en_US"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "en_US",
    ///    "en_GB",
    ///    "nl_NL",
    ///    "nl_BE",
    ///    "de_DE",
    ///    "de_AT",
    ///    "de_CH",
    ///    "fr_FR",
    ///    "fr_BE",
    ///    "es_ES",
    ///    "ca_ES",
    ///    "pt_PT",
    ///    "it_IT",
    ///    "nb_NO",
    ///    "sv_SE",
    ///    "fi_FI",
    ///    "da_DK",
    ///    "is_IS",
    ///    "hu_HU",
    ///    "pl_PL",
    ///    "lv_LV",
    ///    "lt_LT"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetMethodLocale {
        #[serde(rename = "en_US")]
        EnUs,
        #[serde(rename = "en_GB")]
        EnGb,
        #[serde(rename = "nl_NL")]
        NlNl,
        #[serde(rename = "nl_BE")]
        NlBe,
        #[serde(rename = "de_DE")]
        DeDe,
        #[serde(rename = "de_AT")]
        DeAt,
        #[serde(rename = "de_CH")]
        DeCh,
        #[serde(rename = "fr_FR")]
        FrFr,
        #[serde(rename = "fr_BE")]
        FrBe,
        #[serde(rename = "es_ES")]
        EsEs,
        #[serde(rename = "ca_ES")]
        CaEs,
        #[serde(rename = "pt_PT")]
        PtPt,
        #[serde(rename = "it_IT")]
        ItIt,
        #[serde(rename = "nb_NO")]
        NbNo,
        #[serde(rename = "sv_SE")]
        SvSe,
        #[serde(rename = "fi_FI")]
        FiFi,
        #[serde(rename = "da_DK")]
        DaDk,
        #[serde(rename = "is_IS")]
        IsIs,
        #[serde(rename = "hu_HU")]
        HuHu,
        #[serde(rename = "pl_PL")]
        PlPl,
        #[serde(rename = "lv_LV")]
        LvLv,
        #[serde(rename = "lt_LT")]
        LtLt,
    }

    impl ::std::convert::From<&Self> for GetMethodLocale {
        fn from(value: &GetMethodLocale) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetMethodLocale {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EnUs => f.write_str("en_US"),
                Self::EnGb => f.write_str("en_GB"),
                Self::NlNl => f.write_str("nl_NL"),
                Self::NlBe => f.write_str("nl_BE"),
                Self::DeDe => f.write_str("de_DE"),
                Self::DeAt => f.write_str("de_AT"),
                Self::DeCh => f.write_str("de_CH"),
                Self::FrFr => f.write_str("fr_FR"),
                Self::FrBe => f.write_str("fr_BE"),
                Self::EsEs => f.write_str("es_ES"),
                Self::CaEs => f.write_str("ca_ES"),
                Self::PtPt => f.write_str("pt_PT"),
                Self::ItIt => f.write_str("it_IT"),
                Self::NbNo => f.write_str("nb_NO"),
                Self::SvSe => f.write_str("sv_SE"),
                Self::FiFi => f.write_str("fi_FI"),
                Self::DaDk => f.write_str("da_DK"),
                Self::IsIs => f.write_str("is_IS"),
                Self::HuHu => f.write_str("hu_HU"),
                Self::PlPl => f.write_str("pl_PL"),
                Self::LvLv => f.write_str("lv_LV"),
                Self::LtLt => f.write_str("lt_LT"),
            }
        }
    }

    impl ::std::str::FromStr for GetMethodLocale {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "en_US" => Ok(Self::EnUs),
                "en_GB" => Ok(Self::EnGb),
                "nl_NL" => Ok(Self::NlNl),
                "nl_BE" => Ok(Self::NlBe),
                "de_DE" => Ok(Self::DeDe),
                "de_AT" => Ok(Self::DeAt),
                "de_CH" => Ok(Self::DeCh),
                "fr_FR" => Ok(Self::FrFr),
                "fr_BE" => Ok(Self::FrBe),
                "es_ES" => Ok(Self::EsEs),
                "ca_ES" => Ok(Self::CaEs),
                "pt_PT" => Ok(Self::PtPt),
                "it_IT" => Ok(Self::ItIt),
                "nb_NO" => Ok(Self::NbNo),
                "sv_SE" => Ok(Self::SvSe),
                "fi_FI" => Ok(Self::FiFi),
                "da_DK" => Ok(Self::DaDk),
                "is_IS" => Ok(Self::IsIs),
                "hu_HU" => Ok(Self::HuHu),
                "pl_PL" => Ok(Self::PlPl),
                "lv_LV" => Ok(Self::LvLv),
                "lt_LT" => Ok(Self::LtLt),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetMethodLocale {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetMethodLocale {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetMethodLocale {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetPartnerStatusResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "partnerType",
    ///    "resource"
    ///  ],
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "type": "object",
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "signuplink": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "isCommissionPartner": {
    ///      "description": "Whether the current organization is receiving
    /// commissions.",
    ///      "readOnly": true,
    ///      "type": "boolean"
    ///    },
    ///    "partnerContractExpiresAt": {
    ///      "description": "The expiration date of the signed partner contract, in ISO 8601 format. Omitted if contract has no\nexpiration date (yet).",
    ///      "readOnly": true,
    ///      "type": "string"
    ///    },
    ///    "partnerContractSignedAt": {
    ///      "description": "The date the partner contract was signed, in ISO
    /// 8601 format. Omitted if no contract has been signed\n(yet).",
    ///      "readOnly": true,
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "partnerContractUpdateAvailable": {
    ///      "description": "Whether an update to the partner contract is
    /// available and requiring the organization's agreement.",
    ///      "readOnly": true,
    ///      "type": "boolean"
    ///    },
    ///    "partnerType": {
    ///      "description": "Indicates the type of partner. Will be `null` if
    /// the currently authenticated organization is not\nenrolled as a
    /// partner.",
    ///      "readOnly": true,
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "enum": [
    ///        "oauth",
    ///        "signuplink",
    ///        "useragent"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a partner status object. Will always contain the string `partner` for\nthis endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "partner"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "userAgentTokens": {
    ///      "description": "Array of User-Agent token objects. Present if the
    /// organization is a partner of type `useragent`, or if\nthey were in the
    /// past.",
    ///      "readOnly": true,
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "properties": {
    ///          "endsAt": {
    ///            "description": "The date until when the token will be active,
    /// in ISO 8601 format. Will be `null` if the token\ndoes not have an end
    /// date (yet).",
    ///            "type": [
    ///              "string",
    ///              "null"
    ///            ]
    ///          },
    ///          "startsAt": {
    ///            "description": "The date from which the token is active, in
    /// ISO 8601 format.",
    ///            "type": "string"
    ///          },
    ///          "token": {
    ///            "description": "The unique User-Agent token.",
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetPartnerStatusResponse {
        ///Whether the current organization is receiving commissions.
        #[serde(
            rename = "isCommissionPartner",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub is_commission_partner: ::std::option::Option<bool>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<GetPartnerStatusResponseLinks>,
        ///The expiration date of the signed partner contract, in ISO 8601
        /// format. Omitted if contract has no expiration date (yet).
        #[serde(
            rename = "partnerContractExpiresAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub partner_contract_expires_at: ::std::option::Option<::std::string::String>,
        ///The date the partner contract was signed, in ISO 8601 format.
        /// Omitted if no contract has been signed (yet).
        #[serde(
            rename = "partnerContractSignedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub partner_contract_signed_at: ::std::option::Option<::std::string::String>,
        ///Whether an update to the partner contract is available and requiring
        /// the organization's agreement.
        #[serde(
            rename = "partnerContractUpdateAvailable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub partner_contract_update_available: ::std::option::Option<bool>,
        ///Indicates the type of partner. Will be `null` if the currently
        /// authenticated organization is not enrolled as a partner.
        #[serde(rename = "partnerType")]
        pub partner_type: ::std::option::Option<GetPartnerStatusResponsePartnerType>,
        ///Indicates the response contains a partner status object. Will always
        /// contain the string `partner` for this endpoint.
        pub resource: ::std::string::String,
        ///Array of User-Agent token objects. Present if the organization is a
        /// partner of type `useragent`, or if they were in the past.
        #[serde(
            rename = "userAgentTokens",
            default,
            skip_serializing_if = "::std::vec::Vec::is_empty"
        )]
        pub user_agent_tokens: ::std::vec::Vec<GetPartnerStatusResponseUserAgentTokensItem>,
    }

    impl ::std::convert::From<&GetPartnerStatusResponse> for GetPartnerStatusResponse {
        fn from(value: &GetPartnerStatusResponse) -> Self {
            value.clone()
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "type": "object",
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "signuplink": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetPartnerStatusResponseLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub signuplink: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&GetPartnerStatusResponseLinks> for GetPartnerStatusResponseLinks {
        fn from(value: &GetPartnerStatusResponseLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GetPartnerStatusResponseLinks {
        fn default() -> Self {
            Self {
                documentation: Default::default(),
                self_: Default::default(),
                signuplink: Default::default(),
            }
        }
    }

    ///Indicates the type of partner. Will be `null` if the currently
    /// authenticated organization is not enrolled as a partner.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the type of partner. Will be `null` if the currently authenticated organization is not\nenrolled as a partner.",
    ///  "readOnly": true,
    ///  "type": "string",
    ///  "enum": [
    ///    "oauth",
    ///    "signuplink",
    ///    "useragent"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetPartnerStatusResponsePartnerType {
        #[serde(rename = "oauth")]
        Oauth,
        #[serde(rename = "signuplink")]
        Signuplink,
        #[serde(rename = "useragent")]
        Useragent,
    }

    impl ::std::convert::From<&Self> for GetPartnerStatusResponsePartnerType {
        fn from(value: &GetPartnerStatusResponsePartnerType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetPartnerStatusResponsePartnerType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Oauth => f.write_str("oauth"),
                Self::Signuplink => f.write_str("signuplink"),
                Self::Useragent => f.write_str("useragent"),
            }
        }
    }

    impl ::std::str::FromStr for GetPartnerStatusResponsePartnerType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "oauth" => Ok(Self::Oauth),
                "signuplink" => Ok(Self::Signuplink),
                "useragent" => Ok(Self::Useragent),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetPartnerStatusResponsePartnerType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetPartnerStatusResponsePartnerType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetPartnerStatusResponsePartnerType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetPartnerStatusResponseUserAgentTokensItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "endsAt": {
    ///      "description": "The date until when the token will be active, in
    /// ISO 8601 format. Will be `null` if the token\ndoes not have an end date
    /// (yet).",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "startsAt": {
    ///      "description": "The date from which the token is active, in ISO
    /// 8601 format.",
    ///      "type": "string"
    ///    },
    ///    "token": {
    ///      "description": "The unique User-Agent token.",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetPartnerStatusResponseUserAgentTokensItem {
        ///The date until when the token will be active, in ISO 8601 format.
        /// Will be `null` if the token does not have an end date (yet).
        #[serde(
            rename = "endsAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub ends_at: ::std::option::Option<::std::string::String>,
        ///The date from which the token is active, in ISO 8601 format.
        #[serde(
            rename = "startsAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub starts_at: ::std::option::Option<::std::string::String>,
        ///The unique User-Agent token.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub token: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&GetPartnerStatusResponseUserAgentTokensItem>
        for GetPartnerStatusResponseUserAgentTokensItem
    {
        fn from(value: &GetPartnerStatusResponseUserAgentTokensItem) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GetPartnerStatusResponseUserAgentTokensItem {
        fn default() -> Self {
            Self {
                ends_at: Default::default(),
                starts_at: Default::default(),
                token: Default::default(),
            }
        }
    }

    ///`GetPaymentLinkPaymentsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "payments": {
    ///          "description": "An array of payment objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/payment-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetPaymentLinkPaymentsResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: GetPaymentLinkPaymentsResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&GetPaymentLinkPaymentsResponse> for GetPaymentLinkPaymentsResponse {
        fn from(value: &GetPaymentLinkPaymentsResponse) -> Self {
            value.clone()
        }
    }

    ///`GetPaymentLinkPaymentsResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "payments": {
    ///      "description": "An array of payment objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/payment-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetPaymentLinkPaymentsResponseEmbedded {
        ///An array of payment objects.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub payments: ::std::vec::Vec<PaymentResponse>,
    }

    impl ::std::convert::From<&GetPaymentLinkPaymentsResponseEmbedded>
        for GetPaymentLinkPaymentsResponseEmbedded
    {
        fn from(value: &GetPaymentLinkPaymentsResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GetPaymentLinkPaymentsResponseEmbedded {
        fn default() -> Self {
            Self {
                payments: Default::default(),
            }
        }
    }

    ///`GetPaymentLinkPaymentsSort`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "desc"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetPaymentLinkPaymentsSort {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for GetPaymentLinkPaymentsSort {
        fn from(value: &GetPaymentLinkPaymentsSort) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetPaymentLinkPaymentsSort {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for GetPaymentLinkPaymentsSort {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetPaymentLinkPaymentsSort {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetPaymentLinkPaymentsSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetPaymentLinkPaymentsSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`Giftcard`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_links",
    ///    "description",
    ///    "id",
    ///    "resource",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "description": {
    ///      "description": "The full name of the payment method issuer.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "FestivalCadeau Giftcard"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "The unique identifier of the payment method
    /// issuer.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "festivalcadeau"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a payment method
    /// issuer object. Will always contain the string `issuer` for
    /// this\nendpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "issuer"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/method-issuer-status"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Giftcard {
        ///The full name of the payment method issuer.
        pub description: ::std::string::String,
        ///The unique identifier of the payment method issuer.
        pub id: ::std::string::String,
        #[serde(rename = "_links")]
        pub links: GiftcardLinks,
        ///Indicates the response contains a payment method issuer object. Will
        /// always contain the string `issuer` for this endpoint.
        pub resource: ::std::string::String,
        pub status: MethodIssuerStatus,
    }

    impl ::std::convert::From<&Giftcard> for Giftcard {
        fn from(value: &Giftcard) -> Self {
            value.clone()
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GiftcardLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&GiftcardLinks> for GiftcardLinks {
        fn from(value: &GiftcardLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GiftcardLinks {
        fn default() -> Self {
            Self {
                documentation: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///Status of the invoice.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Status of the invoice.",
    ///  "type": "string",
    ///  "enum": [
    ///    "open",
    ///    "paid",
    ///    "overdue"
    ///  ],
    ///  "x-enumDescriptions": {
    ///    "open": "The invoice is not paid yet.",
    ///    "overdue": "Payment of the invoice is overdue.",
    ///    "paid": "The invoice is paid."
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InvoiceStatus {
        #[serde(rename = "open")]
        Open,
        #[serde(rename = "paid")]
        Paid,
        #[serde(rename = "overdue")]
        Overdue,
    }

    impl ::std::convert::From<&Self> for InvoiceStatus {
        fn from(value: &InvoiceStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InvoiceStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Open => f.write_str("open"),
                Self::Paid => f.write_str("paid"),
                Self::Overdue => f.write_str("overdue"),
            }
        }
    }

    impl ::std::str::FromStr for InvoiceStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "open" => Ok(Self::Open),
                "paid" => Ok(Self::Paid),
                "overdue" => Ok(Self::Overdue),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InvoiceStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InvoiceStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InvoiceStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InvoiceToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "inv_aHbjjdrUdm"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct InvoiceToken(pub ::std::string::String);
    impl ::std::ops::Deref for InvoiceToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InvoiceToken> for ::std::string::String {
        fn from(value: InvoiceToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InvoiceToken> for InvoiceToken {
        fn from(value: &InvoiceToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for InvoiceToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for InvoiceToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for InvoiceToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///**Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
    ///
    ///**⚠️ With the introduction of iDEAL 2 in 2025, this field will be
    /// ignored for iDEAL payments. For more information on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
    ///
    ///Some payment methods are a network of connected banks or card issuers.
    /// In these cases, after selecting the payment method, the customer may
    /// still need to select the appropriate issuer before the payment can
    /// proceed.
    ///
    ///We provide hosted issuer selection screens, but these screens can be
    /// skipped by providing the `issuer` via the API up front.
    ///
    ///The full list of issuers for a specific method can be retrieved via the
    /// Methods API by using the optional `issuers` include.
    ///
    ///A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "**Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**\n\n**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information\non the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**\n\nSome payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment\nmethod, the customer may still need to select the appropriate issuer before the payment can proceed.\n\nWe provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API\nup front.\n\nThe full list of issuers for a specific method can be retrieved via the Methods API by using the optional\n`issuers` include.\n\nA valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).",
    ///  "writeOnly": true,
    ///  "examples": [
    ///    "ideal_INGBNL2A"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct Issuer(pub ::std::option::Option<::std::string::String>);
    impl ::std::ops::Deref for Issuer {
        type Target = ::std::option::Option<::std::string::String>;
        fn deref(&self) -> &::std::option::Option<::std::string::String> {
            &self.0
        }
    }

    impl ::std::convert::From<Issuer> for ::std::option::Option<::std::string::String> {
        fn from(value: Issuer) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&Issuer> for Issuer {
        fn from(value: &Issuer) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<::std::string::String>> for Issuer {
        fn from(value: ::std::option::Option<::std::string::String>) -> Self {
            Self(value)
        }
    }

    ///`LineCategories`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "eco"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "eco",
    ///    "gift",
    ///    "meal",
    ///    "sport_culture",
    ///    "additional",
    ///    "consume"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LineCategories {
        #[serde(rename = "eco")]
        Eco,
        #[serde(rename = "gift")]
        Gift,
        #[serde(rename = "meal")]
        Meal,
        #[serde(rename = "sport_culture")]
        SportCulture,
        #[serde(rename = "additional")]
        Additional,
        #[serde(rename = "consume")]
        Consume,
    }

    impl ::std::convert::From<&Self> for LineCategories {
        fn from(value: &LineCategories) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LineCategories {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Eco => f.write_str("eco"),
                Self::Gift => f.write_str("gift"),
                Self::Meal => f.write_str("meal"),
                Self::SportCulture => f.write_str("sport_culture"),
                Self::Additional => f.write_str("additional"),
                Self::Consume => f.write_str("consume"),
            }
        }
    }

    impl ::std::str::FromStr for LineCategories {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eco" => Ok(Self::Eco),
                "gift" => Ok(Self::Gift),
                "meal" => Ok(Self::Meal),
                "sport_culture" => Ok(Self::SportCulture),
                "additional" => Ok(Self::Additional),
                "consume" => Ok(Self::Consume),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LineCategories {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LineCategories {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LineCategories {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LineCategoriesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "eco"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "eco",
    ///    "gift",
    ///    "meal",
    ///    "sport_culture",
    ///    "additional",
    ///    "consume"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LineCategoriesResponse {
        #[serde(rename = "eco")]
        Eco,
        #[serde(rename = "gift")]
        Gift,
        #[serde(rename = "meal")]
        Meal,
        #[serde(rename = "sport_culture")]
        SportCulture,
        #[serde(rename = "additional")]
        Additional,
        #[serde(rename = "consume")]
        Consume,
    }

    impl ::std::convert::From<&Self> for LineCategoriesResponse {
        fn from(value: &LineCategoriesResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LineCategoriesResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Eco => f.write_str("eco"),
                Self::Gift => f.write_str("gift"),
                Self::Meal => f.write_str("meal"),
                Self::SportCulture => f.write_str("sport_culture"),
                Self::Additional => f.write_str("additional"),
                Self::Consume => f.write_str("consume"),
            }
        }
    }

    impl ::std::str::FromStr for LineCategoriesResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eco" => Ok(Self::Eco),
                "gift" => Ok(Self::Gift),
                "meal" => Ok(Self::Meal),
                "sport_culture" => Ok(Self::SportCulture),
                "additional" => Ok(Self::Additional),
                "consume" => Ok(Self::Consume),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LineCategoriesResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LineCategoriesResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LineCategoriesResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ListAllChargebacksResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "chargebacks": {
    ///          "description": "A list of chargeback objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-chargeback"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListAllChargebacksResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<ListCount>,
        #[serde(
            rename = "_embedded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub embedded: ::std::option::Option<ListAllChargebacksResponseEmbedded>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<ListLinks>,
    }

    impl ::std::convert::From<&ListAllChargebacksResponse> for ListAllChargebacksResponse {
        fn from(value: &ListAllChargebacksResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListAllChargebacksResponse {
        fn default() -> Self {
            Self {
                count: Default::default(),
                embedded: Default::default(),
                links: Default::default(),
            }
        }
    }

    ///`ListAllChargebacksResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "chargebacks": {
    ///      "description": "A list of chargeback objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-chargeback"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListAllChargebacksResponseEmbedded {
        ///A list of chargeback objects.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub chargebacks: ::std::vec::Vec<EntityChargeback>,
    }

    impl ::std::convert::From<&ListAllChargebacksResponseEmbedded>
        for ListAllChargebacksResponseEmbedded
    {
        fn from(value: &ListAllChargebacksResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListAllChargebacksResponseEmbedded {
        fn default() -> Self {
            Self {
                chargebacks: Default::default(),
            }
        }
    }

    ///`ListAllChargebacksSort`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "desc"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListAllChargebacksSort {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for ListAllChargebacksSort {
        fn from(value: &ListAllChargebacksSort) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListAllChargebacksSort {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for ListAllChargebacksSort {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListAllChargebacksSort {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListAllChargebacksSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListAllChargebacksSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ListAllMethodsLocale`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "en_US"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "en_US",
    ///    "en_GB",
    ///    "nl_NL",
    ///    "nl_BE",
    ///    "de_DE",
    ///    "de_AT",
    ///    "de_CH",
    ///    "fr_FR",
    ///    "fr_BE",
    ///    "es_ES",
    ///    "ca_ES",
    ///    "pt_PT",
    ///    "it_IT",
    ///    "nb_NO",
    ///    "sv_SE",
    ///    "fi_FI",
    ///    "da_DK",
    ///    "is_IS",
    ///    "hu_HU",
    ///    "pl_PL",
    ///    "lv_LV",
    ///    "lt_LT"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListAllMethodsLocale {
        #[serde(rename = "en_US")]
        EnUs,
        #[serde(rename = "en_GB")]
        EnGb,
        #[serde(rename = "nl_NL")]
        NlNl,
        #[serde(rename = "nl_BE")]
        NlBe,
        #[serde(rename = "de_DE")]
        DeDe,
        #[serde(rename = "de_AT")]
        DeAt,
        #[serde(rename = "de_CH")]
        DeCh,
        #[serde(rename = "fr_FR")]
        FrFr,
        #[serde(rename = "fr_BE")]
        FrBe,
        #[serde(rename = "es_ES")]
        EsEs,
        #[serde(rename = "ca_ES")]
        CaEs,
        #[serde(rename = "pt_PT")]
        PtPt,
        #[serde(rename = "it_IT")]
        ItIt,
        #[serde(rename = "nb_NO")]
        NbNo,
        #[serde(rename = "sv_SE")]
        SvSe,
        #[serde(rename = "fi_FI")]
        FiFi,
        #[serde(rename = "da_DK")]
        DaDk,
        #[serde(rename = "is_IS")]
        IsIs,
        #[serde(rename = "hu_HU")]
        HuHu,
        #[serde(rename = "pl_PL")]
        PlPl,
        #[serde(rename = "lv_LV")]
        LvLv,
        #[serde(rename = "lt_LT")]
        LtLt,
    }

    impl ::std::convert::From<&Self> for ListAllMethodsLocale {
        fn from(value: &ListAllMethodsLocale) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListAllMethodsLocale {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EnUs => f.write_str("en_US"),
                Self::EnGb => f.write_str("en_GB"),
                Self::NlNl => f.write_str("nl_NL"),
                Self::NlBe => f.write_str("nl_BE"),
                Self::DeDe => f.write_str("de_DE"),
                Self::DeAt => f.write_str("de_AT"),
                Self::DeCh => f.write_str("de_CH"),
                Self::FrFr => f.write_str("fr_FR"),
                Self::FrBe => f.write_str("fr_BE"),
                Self::EsEs => f.write_str("es_ES"),
                Self::CaEs => f.write_str("ca_ES"),
                Self::PtPt => f.write_str("pt_PT"),
                Self::ItIt => f.write_str("it_IT"),
                Self::NbNo => f.write_str("nb_NO"),
                Self::SvSe => f.write_str("sv_SE"),
                Self::FiFi => f.write_str("fi_FI"),
                Self::DaDk => f.write_str("da_DK"),
                Self::IsIs => f.write_str("is_IS"),
                Self::HuHu => f.write_str("hu_HU"),
                Self::PlPl => f.write_str("pl_PL"),
                Self::LvLv => f.write_str("lv_LV"),
                Self::LtLt => f.write_str("lt_LT"),
            }
        }
    }

    impl ::std::str::FromStr for ListAllMethodsLocale {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "en_US" => Ok(Self::EnUs),
                "en_GB" => Ok(Self::EnGb),
                "nl_NL" => Ok(Self::NlNl),
                "nl_BE" => Ok(Self::NlBe),
                "de_DE" => Ok(Self::DeDe),
                "de_AT" => Ok(Self::DeAt),
                "de_CH" => Ok(Self::DeCh),
                "fr_FR" => Ok(Self::FrFr),
                "fr_BE" => Ok(Self::FrBe),
                "es_ES" => Ok(Self::EsEs),
                "ca_ES" => Ok(Self::CaEs),
                "pt_PT" => Ok(Self::PtPt),
                "it_IT" => Ok(Self::ItIt),
                "nb_NO" => Ok(Self::NbNo),
                "sv_SE" => Ok(Self::SvSe),
                "fi_FI" => Ok(Self::FiFi),
                "da_DK" => Ok(Self::DaDk),
                "is_IS" => Ok(Self::IsIs),
                "hu_HU" => Ok(Self::HuHu),
                "pl_PL" => Ok(Self::PlPl),
                "lv_LV" => Ok(Self::LvLv),
                "lt_LT" => Ok(Self::LtLt),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListAllMethodsLocale {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListAllMethodsLocale {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListAllMethodsLocale {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ListAllMethodsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "required": [
    ///        "methods"
    ///      ],
    ///      "properties": {
    ///        "methods": {
    ///          "description": "An array of payment method objects. For a
    /// complete\nreference of the payment method object, refer to the [Get
    /// payment method endpoint](get-method)\ndocumentation.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-method-all"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "type": "object",
    ///      "required": [
    ///        "documentation",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "count": {
    ///      "description": "The number of payment method objects in this result
    /// set. Results are **not** paginated.",
    ///      "examples": [
    ///        5
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListAllMethodsResponse {
        ///The number of payment method objects in this result set. Results are
        /// **not** paginated.
        pub count: i64,
        #[serde(rename = "_embedded")]
        pub embedded: ListAllMethodsResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListAllMethodsResponseLinks,
    }

    impl ::std::convert::From<&ListAllMethodsResponse> for ListAllMethodsResponse {
        fn from(value: &ListAllMethodsResponse) -> Self {
            value.clone()
        }
    }

    ///`ListAllMethodsResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "methods"
    ///  ],
    ///  "properties": {
    ///    "methods": {
    ///      "description": "An array of payment method objects. For a
    /// complete\nreference of the payment method object, refer to the [Get
    /// payment method endpoint](get-method)\ndocumentation.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-method-all"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListAllMethodsResponseEmbedded {
        ///An array of payment method objects. For a complete
        ///reference of the payment method object, refer to the [Get payment
        /// method endpoint](get-method) documentation.
        pub methods: ::std::vec::Vec<EntityMethodAll>,
    }

    impl ::std::convert::From<&ListAllMethodsResponseEmbedded> for ListAllMethodsResponseEmbedded {
        fn from(value: &ListAllMethodsResponseEmbedded) -> Self {
            value.clone()
        }
    }

    ///`ListAllMethodsResponseLinks`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "documentation",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListAllMethodsResponseLinks {
        pub documentation: Url,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&ListAllMethodsResponseLinks> for ListAllMethodsResponseLinks {
        fn from(value: &ListAllMethodsResponseLinks) -> Self {
            value.clone()
        }
    }

    ///`ListAllRefundsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "required": [
    ///        "refunds"
    ///      ],
    ///      "properties": {
    ///        "refunds": {
    ///          "description": "An array of refund objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-refund-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListAllRefundsResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListAllRefundsResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListAllRefundsResponse> for ListAllRefundsResponse {
        fn from(value: &ListAllRefundsResponse) -> Self {
            value.clone()
        }
    }

    ///`ListAllRefundsResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "refunds"
    ///  ],
    ///  "properties": {
    ///    "refunds": {
    ///      "description": "An array of refund objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-refund-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListAllRefundsResponseEmbedded {
        ///An array of refund objects.
        pub refunds: ::std::vec::Vec<EntityRefundResponse>,
    }

    impl ::std::convert::From<&ListAllRefundsResponseEmbedded> for ListAllRefundsResponseEmbedded {
        fn from(value: &ListAllRefundsResponseEmbedded) -> Self {
            value.clone()
        }
    }

    ///`ListAllRefundsSort`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "desc"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListAllRefundsSort {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for ListAllRefundsSort {
        fn from(value: &ListAllRefundsSort) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListAllRefundsSort {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for ListAllRefundsSort {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListAllRefundsSort {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListAllRefundsSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListAllRefundsSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ListAllSubscriptionsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "subscriptions": {
    ///          "description": "A list of subscription objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/subscription-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListAllSubscriptionsResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListAllSubscriptionsResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListAllSubscriptionsResponse> for ListAllSubscriptionsResponse {
        fn from(value: &ListAllSubscriptionsResponse) -> Self {
            value.clone()
        }
    }

    ///`ListAllSubscriptionsResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "subscriptions": {
    ///      "description": "A list of subscription objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/subscription-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListAllSubscriptionsResponseEmbedded {
        ///A list of subscription objects.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub subscriptions: ::std::vec::Vec<SubscriptionResponse>,
    }

    impl ::std::convert::From<&ListAllSubscriptionsResponseEmbedded>
        for ListAllSubscriptionsResponseEmbedded
    {
        fn from(value: &ListAllSubscriptionsResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListAllSubscriptionsResponseEmbedded {
        fn default() -> Self {
            Self {
                subscriptions: Default::default(),
            }
        }
    }

    ///`ListBalanceTransactionsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "balance_transactions": {
    ///          "description": "An array of balance transaction objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-balance-transaction"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListBalanceTransactionsResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<ListCount>,
        #[serde(
            rename = "_embedded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub embedded: ::std::option::Option<ListBalanceTransactionsResponseEmbedded>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<ListLinks>,
    }

    impl ::std::convert::From<&ListBalanceTransactionsResponse> for ListBalanceTransactionsResponse {
        fn from(value: &ListBalanceTransactionsResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListBalanceTransactionsResponse {
        fn default() -> Self {
            Self {
                count: Default::default(),
                embedded: Default::default(),
                links: Default::default(),
            }
        }
    }

    ///`ListBalanceTransactionsResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "balance_transactions": {
    ///      "description": "An array of balance transaction objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-balance-transaction"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListBalanceTransactionsResponseEmbedded {
        ///An array of balance transaction objects.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub balance_transactions: ::std::vec::Vec<EntityBalanceTransaction>,
    }

    impl ::std::convert::From<&ListBalanceTransactionsResponseEmbedded>
        for ListBalanceTransactionsResponseEmbedded
    {
        fn from(value: &ListBalanceTransactionsResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListBalanceTransactionsResponseEmbedded {
        fn default() -> Self {
            Self {
                balance_transactions: Default::default(),
            }
        }
    }

    ///`ListBalancesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "balances": {
    ///          "description": "An array of balance objects. For a complete
    /// reference of\nthe balance object, refer to the [Get balance
    /// endpoint](get-balance) documentation.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-balance"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListBalancesResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<ListCount>,
        #[serde(
            rename = "_embedded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub embedded: ::std::option::Option<ListBalancesResponseEmbedded>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<ListLinks>,
    }

    impl ::std::convert::From<&ListBalancesResponse> for ListBalancesResponse {
        fn from(value: &ListBalancesResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListBalancesResponse {
        fn default() -> Self {
            Self {
                count: Default::default(),
                embedded: Default::default(),
                links: Default::default(),
            }
        }
    }

    ///`ListBalancesResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "balances": {
    ///      "description": "An array of balance objects. For a complete
    /// reference of\nthe balance object, refer to the [Get balance
    /// endpoint](get-balance) documentation.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-balance"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListBalancesResponseEmbedded {
        ///An array of balance objects. For a complete reference of
        ///the balance object, refer to the [Get balance endpoint](get-balance)
        /// documentation.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub balances: ::std::vec::Vec<EntityBalance>,
    }

    impl ::std::convert::From<&ListBalancesResponseEmbedded> for ListBalancesResponseEmbedded {
        fn from(value: &ListBalancesResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListBalancesResponseEmbedded {
        fn default() -> Self {
            Self {
                balances: Default::default(),
            }
        }
    }

    ///`ListCapabilitiesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "capabilities": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-capability"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "type": "object",
    ///      "properties": {
    ///        "documentation": {
    ///          "type": "object",
    ///          "properties": {
    ///            "href": {
    ///              "type": "string"
    ///            },
    ///            "type": {
    ///              "type": "string"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "count": {
    ///      "description": "The number of items in this result set.",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListCapabilitiesResponse {
        ///The number of items in this result set.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<i64>,
        #[serde(
            rename = "_embedded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub embedded: ::std::option::Option<ListCapabilitiesResponseEmbedded>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<ListCapabilitiesResponseLinks>,
    }

    impl ::std::convert::From<&ListCapabilitiesResponse> for ListCapabilitiesResponse {
        fn from(value: &ListCapabilitiesResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListCapabilitiesResponse {
        fn default() -> Self {
            Self {
                count: Default::default(),
                embedded: Default::default(),
                links: Default::default(),
            }
        }
    }

    ///`ListCapabilitiesResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "capabilities": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-capability"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListCapabilitiesResponseEmbedded {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub capabilities: ::std::vec::Vec<EntityCapability>,
    }

    impl ::std::convert::From<&ListCapabilitiesResponseEmbedded> for ListCapabilitiesResponseEmbedded {
        fn from(value: &ListCapabilitiesResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListCapabilitiesResponseEmbedded {
        fn default() -> Self {
            Self {
                capabilities: Default::default(),
            }
        }
    }

    ///`ListCapabilitiesResponseLinks`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "documentation": {
    ///      "type": "object",
    ///      "properties": {
    ///        "href": {
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListCapabilitiesResponseLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<ListCapabilitiesResponseLinksDocumentation>,
    }

    impl ::std::convert::From<&ListCapabilitiesResponseLinks> for ListCapabilitiesResponseLinks {
        fn from(value: &ListCapabilitiesResponseLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListCapabilitiesResponseLinks {
        fn default() -> Self {
            Self {
                documentation: Default::default(),
            }
        }
    }

    ///`ListCapabilitiesResponseLinksDocumentation`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "href": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListCapabilitiesResponseLinksDocumentation {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub href: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ListCapabilitiesResponseLinksDocumentation>
        for ListCapabilitiesResponseLinksDocumentation
    {
        fn from(value: &ListCapabilitiesResponseLinksDocumentation) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListCapabilitiesResponseLinksDocumentation {
        fn default() -> Self {
            Self {
                href: Default::default(),
                type_: Default::default(),
            }
        }
    }

    ///`ListCapturesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "required": [
    ///        "captures"
    ///      ],
    ///      "properties": {
    ///        "captures": {
    ///          "description": "An array of capture objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/capture-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListCapturesResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListCapturesResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListCapturesResponse> for ListCapturesResponse {
        fn from(value: &ListCapturesResponse) -> Self {
            value.clone()
        }
    }

    ///`ListCapturesResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "captures"
    ///  ],
    ///  "properties": {
    ///    "captures": {
    ///      "description": "An array of capture objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/capture-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListCapturesResponseEmbedded {
        ///An array of capture objects.
        pub captures: ::std::vec::Vec<CaptureResponse>,
    }

    impl ::std::convert::From<&ListCapturesResponseEmbedded> for ListCapturesResponseEmbedded {
        fn from(value: &ListCapturesResponseEmbedded) -> Self {
            value.clone()
        }
    }

    ///`ListChargebacksResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "chargebacks": {
    ///          "description": "A list of chargeback objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-chargeback"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListChargebacksResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<ListCount>,
        #[serde(
            rename = "_embedded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub embedded: ::std::option::Option<ListChargebacksResponseEmbedded>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<ListLinks>,
    }

    impl ::std::convert::From<&ListChargebacksResponse> for ListChargebacksResponse {
        fn from(value: &ListChargebacksResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListChargebacksResponse {
        fn default() -> Self {
            Self {
                count: Default::default(),
                embedded: Default::default(),
                links: Default::default(),
            }
        }
    }

    ///`ListChargebacksResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "chargebacks": {
    ///      "description": "A list of chargeback objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-chargeback"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListChargebacksResponseEmbedded {
        ///A list of chargeback objects.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub chargebacks: ::std::vec::Vec<EntityChargeback>,
    }

    impl ::std::convert::From<&ListChargebacksResponseEmbedded> for ListChargebacksResponseEmbedded {
        fn from(value: &ListChargebacksResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListChargebacksResponseEmbedded {
        fn default() -> Self {
            Self {
                chargebacks: Default::default(),
            }
        }
    }

    ///`ListClientsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "clients": {
    ///          "description": "An array of client objects. For a complete
    /// reference of the client object, refer to the\n[Get client
    /// endpoint](get-client) documentation.",
    ///          "type": "array",
    ///          "items": {
    ///            "allOf": [
    ///              {
    ///                "$ref": "#/components/schemas/entity-client"
    ///              },
    ///              {
    ///                "type": "object",
    ///                "properties": {
    ///                  "_embedded": {
    ///                    "type": "object",
    ///                    "properties": {
    ///                      "capabilities": {
    ///                        "$ref": "#/components/schemas/entity-capability"
    ///                      },
    ///                      "onboarding": {
    ///                        "$ref":
    /// "#/components/schemas/entity-onboarding-status"
    ///                      },
    ///                      "organization": {
    ///                        "$ref":
    /// "#/components/schemas/entity-organization"
    ///                      }
    ///                    }
    ///                  }
    ///                }
    ///              }
    ///            ]
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListClientsResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<ListCount>,
        #[serde(
            rename = "_embedded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub embedded: ::std::option::Option<ListClientsResponseEmbedded>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<ListLinks>,
    }

    impl ::std::convert::From<&ListClientsResponse> for ListClientsResponse {
        fn from(value: &ListClientsResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListClientsResponse {
        fn default() -> Self {
            Self {
                count: Default::default(),
                embedded: Default::default(),
                links: Default::default(),
            }
        }
    }

    ///`ListClientsResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "clients": {
    ///      "description": "An array of client objects. For a complete
    /// reference of the client object, refer to the\n[Get client
    /// endpoint](get-client) documentation.",
    ///      "type": "array",
    ///      "items": {
    ///        "allOf": [
    ///          {
    ///            "$ref": "#/components/schemas/entity-client"
    ///          },
    ///          {
    ///            "type": "object",
    ///            "properties": {
    ///              "_embedded": {
    ///                "type": "object",
    ///                "properties": {
    ///                  "capabilities": {
    ///                    "$ref": "#/components/schemas/entity-capability"
    ///                  },
    ///                  "onboarding": {
    ///                    "$ref":
    /// "#/components/schemas/entity-onboarding-status"
    ///                  },
    ///                  "organization": {
    ///                    "$ref": "#/components/schemas/entity-organization"
    ///                  }
    ///                }
    ///              }
    ///            }
    ///          }
    ///        ]
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListClientsResponseEmbedded {
        ///An array of client objects. For a complete reference of the client
        /// object, refer to the [Get client endpoint](get-client)
        /// documentation.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub clients: ::std::vec::Vec<ListClientsResponseEmbeddedClientsItem>,
    }

    impl ::std::convert::From<&ListClientsResponseEmbedded> for ListClientsResponseEmbedded {
        fn from(value: &ListClientsResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListClientsResponseEmbedded {
        fn default() -> Self {
            Self {
                clients: Default::default(),
            }
        }
    }

    ///`ListClientsResponseEmbeddedClientsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/entity-client"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "_embedded": {
    ///          "type": "object",
    ///          "properties": {
    ///            "capabilities": {
    ///              "$ref": "#/components/schemas/entity-capability"
    ///            },
    ///            "onboarding": {
    ///              "$ref": "#/components/schemas/entity-onboarding-status"
    ///            },
    ///            "organization": {
    ///              "$ref": "#/components/schemas/entity-organization"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListClientsResponseEmbeddedClientsItem {
        ///The commission object.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub commission: ::std::option::Option<ListClientsResponseEmbeddedClientsItemCommission>,
        #[serde(
            rename = "_embedded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub embedded: ::std::option::Option<ListClientsResponseEmbeddedClientsItemEmbedded>,
        ///The identifier uniquely referring to this client. Example:
        /// `org_12345678`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<ListClientsResponseEmbeddedClientsItemLinks>,
        ///The date and time the client organization was created, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
        ///format.
        #[serde(
            rename = "organizationCreatedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub organization_created_at: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a client object. Will always contain
        /// the string `client` for this resource type.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ListClientsResponseEmbeddedClientsItem>
        for ListClientsResponseEmbeddedClientsItem
    {
        fn from(value: &ListClientsResponseEmbeddedClientsItem) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListClientsResponseEmbeddedClientsItem {
        fn default() -> Self {
            Self {
                commission: Default::default(),
                embedded: Default::default(),
                id: Default::default(),
                links: Default::default(),
                organization_created_at: Default::default(),
                resource: Default::default(),
            }
        }
    }

    ///The commission object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The commission object.",
    ///  "type": "object",
    ///  "properties": {
    ///    "count": {
    ///      "description": "The commission count.",
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListClientsResponseEmbeddedClientsItemCommission {
        ///The commission count.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<i64>,
    }

    impl ::std::convert::From<&ListClientsResponseEmbeddedClientsItemCommission>
        for ListClientsResponseEmbeddedClientsItemCommission
    {
        fn from(value: &ListClientsResponseEmbeddedClientsItemCommission) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListClientsResponseEmbeddedClientsItemCommission {
        fn default() -> Self {
            Self {
                count: Default::default(),
            }
        }
    }

    ///`ListClientsResponseEmbeddedClientsItemEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "capabilities": {
    ///      "$ref": "#/components/schemas/entity-capability"
    ///    },
    ///    "onboarding": {
    ///      "$ref": "#/components/schemas/entity-onboarding-status"
    ///    },
    ///    "organization": {
    ///      "$ref": "#/components/schemas/entity-organization"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListClientsResponseEmbeddedClientsItemEmbedded {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub capabilities: ::std::option::Option<EntityCapability>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub onboarding: ::std::option::Option<EntityOnboardingStatus>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub organization: ::std::option::Option<EntityOrganization>,
    }

    impl ::std::convert::From<&ListClientsResponseEmbeddedClientsItemEmbedded>
        for ListClientsResponseEmbeddedClientsItemEmbedded
    {
        fn from(value: &ListClientsResponseEmbeddedClientsItemEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListClientsResponseEmbeddedClientsItemEmbedded {
        fn default() -> Self {
            Self {
                capabilities: Default::default(),
                onboarding: Default::default(),
                organization: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "onboarding": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "organization": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListClientsResponseEmbeddedClientsItemLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub onboarding: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub organization: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&ListClientsResponseEmbeddedClientsItemLinks>
        for ListClientsResponseEmbeddedClientsItemLinks
    {
        fn from(value: &ListClientsResponseEmbeddedClientsItemLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListClientsResponseEmbeddedClientsItemLinks {
        fn default() -> Self {
            Self {
                documentation: Default::default(),
                onboarding: Default::default(),
                organization: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///`ListConnectBalanceTransfersResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "required": [
    ///        "connect_balance_transfers"
    ///      ],
    ///      "properties": {
    ///        "connect_balance_transfers": {
    ///          "description": "A list of Connect balance transfers.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref":
    /// "#/components/schemas/entity-balance-transfer-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListConnectBalanceTransfersResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListConnectBalanceTransfersResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListConnectBalanceTransfersResponse>
        for ListConnectBalanceTransfersResponse
    {
        fn from(value: &ListConnectBalanceTransfersResponse) -> Self {
            value.clone()
        }
    }

    ///`ListConnectBalanceTransfersResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "connect_balance_transfers"
    ///  ],
    ///  "properties": {
    ///    "connect_balance_transfers": {
    ///      "description": "A list of Connect balance transfers.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-balance-transfer-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListConnectBalanceTransfersResponseEmbedded {
        ///A list of Connect balance transfers.
        pub connect_balance_transfers: ::std::vec::Vec<EntityBalanceTransferResponse>,
    }

    impl ::std::convert::From<&ListConnectBalanceTransfersResponseEmbedded>
        for ListConnectBalanceTransfersResponseEmbedded
    {
        fn from(value: &ListConnectBalanceTransfersResponseEmbedded) -> Self {
            value.clone()
        }
    }

    ///`ListConnectBalanceTransfersSort`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "desc"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListConnectBalanceTransfersSort {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for ListConnectBalanceTransfersSort {
        fn from(value: &ListConnectBalanceTransfersSort) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListConnectBalanceTransfersSort {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for ListConnectBalanceTransfersSort {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListConnectBalanceTransfersSort {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListConnectBalanceTransfersSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListConnectBalanceTransfersSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The number of items in this result set. If more items are available, a
    /// `_links.next` URL will be present in the result as well.
    ///
    ///The maximum number of items per result set is controlled by the `limit`
    /// property provided in the request. The default limit is 50 items.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The number of items in this result set. If more items
    /// are available, a `_links.next` URL will be present in the result\nas
    /// well.\n\nThe maximum number of items per result set is controlled by the
    /// `limit` property provided in the request. The default\nlimit is 50
    /// items.",
    ///  "examples": [
    ///    5
    ///  ],
    ///  "type": "integer",
    ///  "maximum": 250.0,
    ///  "minimum": 1.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct ListCount(pub ::std::num::NonZeroU64);
    impl ::std::ops::Deref for ListCount {
        type Target = ::std::num::NonZeroU64;
        fn deref(&self) -> &::std::num::NonZeroU64 {
            &self.0
        }
    }

    impl ::std::convert::From<ListCount> for ::std::num::NonZeroU64 {
        fn from(value: ListCount) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&ListCount> for ListCount {
        fn from(value: &ListCount) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::num::NonZeroU64> for ListCount {
        fn from(value: ::std::num::NonZeroU64) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for ListCount {
        type Err = <::std::num::NonZeroU64 as ::std::str::FromStr>::Err;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl ::std::convert::TryFrom<&str> for ListCount {
        type Error = <::std::num::NonZeroU64 as ::std::str::FromStr>::Err;
        fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ListCount {
        type Error = <::std::num::NonZeroU64 as ::std::str::FromStr>::Err;
        fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ListCount {
        type Error = <::std::num::NonZeroU64 as ::std::str::FromStr>::Err;
        fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::fmt::Display for ListCount {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`ListCustomerPaymentsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "payments": {
    ///          "description": "An array of payment objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/payment-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListCustomerPaymentsResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListCustomerPaymentsResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListCustomerPaymentsResponse> for ListCustomerPaymentsResponse {
        fn from(value: &ListCustomerPaymentsResponse) -> Self {
            value.clone()
        }
    }

    ///`ListCustomerPaymentsResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "payments": {
    ///      "description": "An array of payment objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/payment-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListCustomerPaymentsResponseEmbedded {
        ///An array of payment objects.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub payments: ::std::vec::Vec<PaymentResponse>,
    }

    impl ::std::convert::From<&ListCustomerPaymentsResponseEmbedded>
        for ListCustomerPaymentsResponseEmbedded
    {
        fn from(value: &ListCustomerPaymentsResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListCustomerPaymentsResponseEmbedded {
        fn default() -> Self {
            Self {
                payments: Default::default(),
            }
        }
    }

    ///`ListCustomerPaymentsSort`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "desc"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListCustomerPaymentsSort {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for ListCustomerPaymentsSort {
        fn from(value: &ListCustomerPaymentsSort) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListCustomerPaymentsSort {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for ListCustomerPaymentsSort {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListCustomerPaymentsSort {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListCustomerPaymentsSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListCustomerPaymentsSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ListCustomersResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "required": [
    ///        "customers"
    ///      ],
    ///      "properties": {
    ///        "customers": {
    ///          "description": "An array of customer objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/customer-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListCustomersResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListCustomersResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListCustomersResponse> for ListCustomersResponse {
        fn from(value: &ListCustomersResponse) -> Self {
            value.clone()
        }
    }

    ///`ListCustomersResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "customers"
    ///  ],
    ///  "properties": {
    ///    "customers": {
    ///      "description": "An array of customer objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/customer-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListCustomersResponseEmbedded {
        ///An array of customer objects.
        pub customers: ::std::vec::Vec<CustomerResponse>,
    }

    impl ::std::convert::From<&ListCustomersResponseEmbedded> for ListCustomersResponseEmbedded {
        fn from(value: &ListCustomersResponseEmbedded) -> Self {
            value.clone()
        }
    }

    ///`ListCustomersSort`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "desc"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListCustomersSort {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for ListCustomersSort {
        fn from(value: &ListCustomersSort) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListCustomersSort {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for ListCustomersSort {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListCustomersSort {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListCustomersSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListCustomersSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ListInvoicesMonth`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "01"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(0[1-9]|1[0-2])$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ListInvoicesMonth(::std::string::String);
    impl ::std::ops::Deref for ListInvoicesMonth {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<ListInvoicesMonth> for ::std::string::String {
        fn from(value: ListInvoicesMonth) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&ListInvoicesMonth> for ListInvoicesMonth {
        fn from(value: &ListInvoicesMonth) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ListInvoicesMonth {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(0[1-9]|1[0-2])$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^(0[1-9]|1[0-2])$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ListInvoicesMonth {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListInvoicesMonth {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListInvoicesMonth {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ListInvoicesMonth {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`ListInvoicesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "invoices": {
    ///          "description": "An array of invoice objects. For a complete
    /// reference of\nthe invoice object, refer to the [Get invoice
    /// endpoint](get-invoice) documentation.",
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListInvoicesResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<ListCount>,
        #[serde(
            rename = "_embedded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub embedded: ::std::option::Option<ListInvoicesResponseEmbedded>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<ListLinks>,
    }

    impl ::std::convert::From<&ListInvoicesResponse> for ListInvoicesResponse {
        fn from(value: &ListInvoicesResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListInvoicesResponse {
        fn default() -> Self {
            Self {
                count: Default::default(),
                embedded: Default::default(),
                links: Default::default(),
            }
        }
    }

    ///`ListInvoicesResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "invoices": {
    ///      "description": "An array of invoice objects. For a complete
    /// reference of\nthe invoice object, refer to the [Get invoice
    /// endpoint](get-invoice) documentation.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListInvoicesResponseEmbedded {
        ///An array of invoice objects. For a complete reference of
        ///the invoice object, refer to the [Get invoice endpoint](get-invoice)
        /// documentation.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub invoices:
            ::std::vec::Vec<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
    }

    impl ::std::convert::From<&ListInvoicesResponseEmbedded> for ListInvoicesResponseEmbedded {
        fn from(value: &ListInvoicesResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListInvoicesResponseEmbedded {
        fn default() -> Self {
            Self {
                invoices: Default::default(),
            }
        }
    }

    ///`ListInvoicesSort`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "desc"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListInvoicesSort {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for ListInvoicesSort {
        fn from(value: &ListInvoicesSort) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListInvoicesSort {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for ListInvoicesSort {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListInvoicesSort {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListInvoicesSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListInvoicesSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Links to help navigate through the lists of items. Every URL object will
    /// contain an `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Links to help navigate through the lists of items.
    /// Every URL object will contain an `href` and a `type` field.",
    ///  "type": "object",
    ///  "required": [
    ///    "documentation",
    ///    "next",
    ///    "previous",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "next": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "previous": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListLinks {
        pub documentation: Url,
        pub next: UrlNullable,
        pub previous: UrlNullable,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&ListLinks> for ListLinks {
        fn from(value: &ListLinks) -> Self {
            value.clone()
        }
    }

    ///`ListMandatesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "required": [
    ///        "mandates"
    ///      ],
    ///      "properties": {
    ///        "mandates": {
    ///          "description": "An array of mandate objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/mandate-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListMandatesResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListMandatesResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListMandatesResponse> for ListMandatesResponse {
        fn from(value: &ListMandatesResponse) -> Self {
            value.clone()
        }
    }

    ///`ListMandatesResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "mandates"
    ///  ],
    ///  "properties": {
    ///    "mandates": {
    ///      "description": "An array of mandate objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/mandate-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListMandatesResponseEmbedded {
        ///An array of mandate objects.
        pub mandates: ::std::vec::Vec<MandateResponse>,
    }

    impl ::std::convert::From<&ListMandatesResponseEmbedded> for ListMandatesResponseEmbedded {
        fn from(value: &ListMandatesResponseEmbedded) -> Self {
            value.clone()
        }
    }

    ///`ListMandatesSort`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "desc"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListMandatesSort {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for ListMandatesSort {
        fn from(value: &ListMandatesSort) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListMandatesSort {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for ListMandatesSort {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListMandatesSort {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListMandatesSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListMandatesSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ListMethodsIncludeWallets`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "applepay"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "applepay"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListMethodsIncludeWallets {
        #[serde(rename = "applepay")]
        Applepay,
    }

    impl ::std::convert::From<&Self> for ListMethodsIncludeWallets {
        fn from(value: &ListMethodsIncludeWallets) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListMethodsIncludeWallets {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Applepay => f.write_str("applepay"),
            }
        }
    }

    impl ::std::str::FromStr for ListMethodsIncludeWallets {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "applepay" => Ok(Self::Applepay),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListMethodsIncludeWallets {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListMethodsIncludeWallets {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListMethodsIncludeWallets {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ListMethodsLocale`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "en_US"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "en_US",
    ///    "en_GB",
    ///    "nl_NL",
    ///    "nl_BE",
    ///    "de_DE",
    ///    "de_AT",
    ///    "de_CH",
    ///    "fr_FR",
    ///    "fr_BE",
    ///    "es_ES",
    ///    "ca_ES",
    ///    "pt_PT",
    ///    "it_IT",
    ///    "nb_NO",
    ///    "sv_SE",
    ///    "fi_FI",
    ///    "da_DK",
    ///    "is_IS",
    ///    "hu_HU",
    ///    "pl_PL",
    ///    "lv_LV",
    ///    "lt_LT"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListMethodsLocale {
        #[serde(rename = "en_US")]
        EnUs,
        #[serde(rename = "en_GB")]
        EnGb,
        #[serde(rename = "nl_NL")]
        NlNl,
        #[serde(rename = "nl_BE")]
        NlBe,
        #[serde(rename = "de_DE")]
        DeDe,
        #[serde(rename = "de_AT")]
        DeAt,
        #[serde(rename = "de_CH")]
        DeCh,
        #[serde(rename = "fr_FR")]
        FrFr,
        #[serde(rename = "fr_BE")]
        FrBe,
        #[serde(rename = "es_ES")]
        EsEs,
        #[serde(rename = "ca_ES")]
        CaEs,
        #[serde(rename = "pt_PT")]
        PtPt,
        #[serde(rename = "it_IT")]
        ItIt,
        #[serde(rename = "nb_NO")]
        NbNo,
        #[serde(rename = "sv_SE")]
        SvSe,
        #[serde(rename = "fi_FI")]
        FiFi,
        #[serde(rename = "da_DK")]
        DaDk,
        #[serde(rename = "is_IS")]
        IsIs,
        #[serde(rename = "hu_HU")]
        HuHu,
        #[serde(rename = "pl_PL")]
        PlPl,
        #[serde(rename = "lv_LV")]
        LvLv,
        #[serde(rename = "lt_LT")]
        LtLt,
    }

    impl ::std::convert::From<&Self> for ListMethodsLocale {
        fn from(value: &ListMethodsLocale) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListMethodsLocale {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EnUs => f.write_str("en_US"),
                Self::EnGb => f.write_str("en_GB"),
                Self::NlNl => f.write_str("nl_NL"),
                Self::NlBe => f.write_str("nl_BE"),
                Self::DeDe => f.write_str("de_DE"),
                Self::DeAt => f.write_str("de_AT"),
                Self::DeCh => f.write_str("de_CH"),
                Self::FrFr => f.write_str("fr_FR"),
                Self::FrBe => f.write_str("fr_BE"),
                Self::EsEs => f.write_str("es_ES"),
                Self::CaEs => f.write_str("ca_ES"),
                Self::PtPt => f.write_str("pt_PT"),
                Self::ItIt => f.write_str("it_IT"),
                Self::NbNo => f.write_str("nb_NO"),
                Self::SvSe => f.write_str("sv_SE"),
                Self::FiFi => f.write_str("fi_FI"),
                Self::DaDk => f.write_str("da_DK"),
                Self::IsIs => f.write_str("is_IS"),
                Self::HuHu => f.write_str("hu_HU"),
                Self::PlPl => f.write_str("pl_PL"),
                Self::LvLv => f.write_str("lv_LV"),
                Self::LtLt => f.write_str("lt_LT"),
            }
        }
    }

    impl ::std::str::FromStr for ListMethodsLocale {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "en_US" => Ok(Self::EnUs),
                "en_GB" => Ok(Self::EnGb),
                "nl_NL" => Ok(Self::NlNl),
                "nl_BE" => Ok(Self::NlBe),
                "de_DE" => Ok(Self::DeDe),
                "de_AT" => Ok(Self::DeAt),
                "de_CH" => Ok(Self::DeCh),
                "fr_FR" => Ok(Self::FrFr),
                "fr_BE" => Ok(Self::FrBe),
                "es_ES" => Ok(Self::EsEs),
                "ca_ES" => Ok(Self::CaEs),
                "pt_PT" => Ok(Self::PtPt),
                "it_IT" => Ok(Self::ItIt),
                "nb_NO" => Ok(Self::NbNo),
                "sv_SE" => Ok(Self::SvSe),
                "fi_FI" => Ok(Self::FiFi),
                "da_DK" => Ok(Self::DaDk),
                "is_IS" => Ok(Self::IsIs),
                "hu_HU" => Ok(Self::HuHu),
                "pl_PL" => Ok(Self::PlPl),
                "lv_LV" => Ok(Self::LvLv),
                "lt_LT" => Ok(Self::LtLt),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListMethodsLocale {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListMethodsLocale {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListMethodsLocale {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ListMethodsResource`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "payments"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "payments",
    ///    "orders"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListMethodsResource {
        #[serde(rename = "payments")]
        Payments,
        #[serde(rename = "orders")]
        Orders,
    }

    impl ::std::convert::From<&Self> for ListMethodsResource {
        fn from(value: &ListMethodsResource) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListMethodsResource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Payments => f.write_str("payments"),
                Self::Orders => f.write_str("orders"),
            }
        }
    }

    impl ::std::str::FromStr for ListMethodsResource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "payments" => Ok(Self::Payments),
                "orders" => Ok(Self::Orders),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListMethodsResource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListMethodsResource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListMethodsResource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ListMethodsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "required": [
    ///        "methods"
    ///      ],
    ///      "properties": {
    ///        "methods": {
    ///          "description": "An array of payment method objects. For a
    /// complete\nreference of the payment method object, refer\nto the [Get
    /// payment method endpoint](get-method)\ndocumentation.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-method"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "type": "object",
    ///      "required": [
    ///        "documentation",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "count": {
    ///      "description": "The number of payment method objects in this result
    /// set.\nResults are **not** paginated.",
    ///      "examples": [
    ///        5
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListMethodsResponse {
        ///The number of payment method objects in this result set.
        ///Results are **not** paginated.
        pub count: i64,
        #[serde(rename = "_embedded")]
        pub embedded: ListMethodsResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListMethodsResponseLinks,
    }

    impl ::std::convert::From<&ListMethodsResponse> for ListMethodsResponse {
        fn from(value: &ListMethodsResponse) -> Self {
            value.clone()
        }
    }

    ///`ListMethodsResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "methods"
    ///  ],
    ///  "properties": {
    ///    "methods": {
    ///      "description": "An array of payment method objects. For a
    /// complete\nreference of the payment method object, refer\nto the [Get
    /// payment method endpoint](get-method)\ndocumentation.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-method"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListMethodsResponseEmbedded {
        ///An array of payment method objects. For a complete
        ///reference of the payment method object, refer
        ///to the [Get payment method endpoint](get-method)
        ///documentation.
        pub methods: ::std::vec::Vec<EntityMethod>,
    }

    impl ::std::convert::From<&ListMethodsResponseEmbedded> for ListMethodsResponseEmbedded {
        fn from(value: &ListMethodsResponseEmbedded) -> Self {
            value.clone()
        }
    }

    ///`ListMethodsResponseLinks`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "documentation",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListMethodsResponseLinks {
        pub documentation: Url,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&ListMethodsResponseLinks> for ListMethodsResponseLinks {
        fn from(value: &ListMethodsResponseLinks) -> Self {
            value.clone()
        }
    }

    ///`ListPaymentLinksResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "payment_links": {
    ///          "description": "An array of payment link objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/payment-link-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListPaymentLinksResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListPaymentLinksResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListPaymentLinksResponse> for ListPaymentLinksResponse {
        fn from(value: &ListPaymentLinksResponse) -> Self {
            value.clone()
        }
    }

    ///`ListPaymentLinksResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "payment_links": {
    ///      "description": "An array of payment link objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/payment-link-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListPaymentLinksResponseEmbedded {
        ///An array of payment link objects.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub payment_links: ::std::vec::Vec<PaymentLinkResponse>,
    }

    impl ::std::convert::From<&ListPaymentLinksResponseEmbedded> for ListPaymentLinksResponseEmbedded {
        fn from(value: &ListPaymentLinksResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListPaymentLinksResponseEmbedded {
        fn default() -> Self {
            Self {
                payment_links: Default::default(),
            }
        }
    }

    ///`ListPaymentsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "payments": {
    ///          "description": "An array of payment objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/payment-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListPaymentsResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListPaymentsResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListPaymentsResponse> for ListPaymentsResponse {
        fn from(value: &ListPaymentsResponse) -> Self {
            value.clone()
        }
    }

    ///`ListPaymentsResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "payments": {
    ///      "description": "An array of payment objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/payment-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListPaymentsResponseEmbedded {
        ///An array of payment objects.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub payments: ::std::vec::Vec<PaymentResponse>,
    }

    impl ::std::convert::From<&ListPaymentsResponseEmbedded> for ListPaymentsResponseEmbedded {
        fn from(value: &ListPaymentsResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListPaymentsResponseEmbedded {
        fn default() -> Self {
            Self {
                payments: Default::default(),
            }
        }
    }

    ///`ListPaymentsSort`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "desc"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListPaymentsSort {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for ListPaymentsSort {
        fn from(value: &ListPaymentsSort) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListPaymentsSort {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for ListPaymentsSort {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListPaymentsSort {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListPaymentsSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListPaymentsSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ListPermissionsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "permissions": {
    ///          "description": "An array of permission objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-permission"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "type": "object",
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListPermissionsResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<ListCount>,
        #[serde(
            rename = "_embedded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub embedded: ::std::option::Option<ListPermissionsResponseEmbedded>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<ListPermissionsResponseLinks>,
    }

    impl ::std::convert::From<&ListPermissionsResponse> for ListPermissionsResponse {
        fn from(value: &ListPermissionsResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListPermissionsResponse {
        fn default() -> Self {
            Self {
                count: Default::default(),
                embedded: Default::default(),
                links: Default::default(),
            }
        }
    }

    ///`ListPermissionsResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "permissions": {
    ///      "description": "An array of permission objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-permission"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListPermissionsResponseEmbedded {
        ///An array of permission objects.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub permissions: ::std::vec::Vec<EntityPermission>,
    }

    impl ::std::convert::From<&ListPermissionsResponseEmbedded> for ListPermissionsResponseEmbedded {
        fn from(value: &ListPermissionsResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListPermissionsResponseEmbedded {
        fn default() -> Self {
            Self {
                permissions: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "type": "object",
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListPermissionsResponseLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&ListPermissionsResponseLinks> for ListPermissionsResponseLinks {
        fn from(value: &ListPermissionsResponseLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListPermissionsResponseLinks {
        fn default() -> Self {
            Self {
                documentation: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///`ListProfilesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "profiles": {
    ///          "description": "An array of profile objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-profile-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListProfilesResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<ListCount>,
        #[serde(
            rename = "_embedded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub embedded: ::std::option::Option<ListProfilesResponseEmbedded>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<ListLinks>,
    }

    impl ::std::convert::From<&ListProfilesResponse> for ListProfilesResponse {
        fn from(value: &ListProfilesResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListProfilesResponse {
        fn default() -> Self {
            Self {
                count: Default::default(),
                embedded: Default::default(),
                links: Default::default(),
            }
        }
    }

    ///`ListProfilesResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "profiles": {
    ///      "description": "An array of profile objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-profile-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListProfilesResponseEmbedded {
        ///An array of profile objects.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub profiles: ::std::vec::Vec<EntityProfileResponse>,
    }

    impl ::std::convert::From<&ListProfilesResponseEmbedded> for ListProfilesResponseEmbedded {
        fn from(value: &ListProfilesResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListProfilesResponseEmbedded {
        fn default() -> Self {
            Self {
                profiles: Default::default(),
            }
        }
    }

    ///`ListRefundsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "required": [
    ///        "refunds"
    ///      ],
    ///      "properties": {
    ///        "refunds": {
    ///          "description": "An array of refund objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-refund-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListRefundsResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListRefundsResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListRefundsResponse> for ListRefundsResponse {
        fn from(value: &ListRefundsResponse) -> Self {
            value.clone()
        }
    }

    ///`ListRefundsResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "refunds"
    ///  ],
    ///  "properties": {
    ///    "refunds": {
    ///      "description": "An array of refund objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-refund-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListRefundsResponseEmbedded {
        ///An array of refund objects.
        pub refunds: ::std::vec::Vec<EntityRefundResponse>,
    }

    impl ::std::convert::From<&ListRefundsResponseEmbedded> for ListRefundsResponseEmbedded {
        fn from(value: &ListRefundsResponseEmbedded) -> Self {
            value.clone()
        }
    }

    ///`ListSalesInvoicesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "sales_invoices": {
    ///          "description": "An array of sales invoice objects. For a
    /// complete reference of the sales invoice object, refer to\nthe [Get sales
    /// invoice endpoint](get-sales-invoice) documentation.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-sales-invoice-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListSalesInvoicesResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<ListCount>,
        #[serde(
            rename = "_embedded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub embedded: ::std::option::Option<ListSalesInvoicesResponseEmbedded>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<ListLinks>,
    }

    impl ::std::convert::From<&ListSalesInvoicesResponse> for ListSalesInvoicesResponse {
        fn from(value: &ListSalesInvoicesResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListSalesInvoicesResponse {
        fn default() -> Self {
            Self {
                count: Default::default(),
                embedded: Default::default(),
                links: Default::default(),
            }
        }
    }

    ///`ListSalesInvoicesResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "sales_invoices": {
    ///      "description": "An array of sales invoice objects. For a complete
    /// reference of the sales invoice object, refer to\nthe [Get sales invoice
    /// endpoint](get-sales-invoice) documentation.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-sales-invoice-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListSalesInvoicesResponseEmbedded {
        ///An array of sales invoice objects. For a complete reference of the
        /// sales invoice object, refer to the [Get sales invoice
        /// endpoint](get-sales-invoice) documentation.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub sales_invoices: ::std::vec::Vec<EntitySalesInvoiceResponse>,
    }

    impl ::std::convert::From<&ListSalesInvoicesResponseEmbedded>
        for ListSalesInvoicesResponseEmbedded
    {
        fn from(value: &ListSalesInvoicesResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListSalesInvoicesResponseEmbedded {
        fn default() -> Self {
            Self {
                sales_invoices: Default::default(),
            }
        }
    }

    ///`ListSettlementCapturesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "required": [
    ///        "captures"
    ///      ],
    ///      "properties": {
    ///        "captures": {
    ///          "description": "An array of capture objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/capture-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListSettlementCapturesResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListSettlementCapturesResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListSettlementCapturesResponse> for ListSettlementCapturesResponse {
        fn from(value: &ListSettlementCapturesResponse) -> Self {
            value.clone()
        }
    }

    ///`ListSettlementCapturesResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "captures"
    ///  ],
    ///  "properties": {
    ///    "captures": {
    ///      "description": "An array of capture objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/capture-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListSettlementCapturesResponseEmbedded {
        ///An array of capture objects.
        pub captures: ::std::vec::Vec<CaptureResponse>,
    }

    impl ::std::convert::From<&ListSettlementCapturesResponseEmbedded>
        for ListSettlementCapturesResponseEmbedded
    {
        fn from(value: &ListSettlementCapturesResponseEmbedded) -> Self {
            value.clone()
        }
    }

    ///`ListSettlementChargebacksResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "chargebacks": {
    ///          "description": "A list of chargeback objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-chargeback"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListSettlementChargebacksResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<ListCount>,
        #[serde(
            rename = "_embedded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub embedded: ::std::option::Option<ListSettlementChargebacksResponseEmbedded>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<ListLinks>,
    }

    impl ::std::convert::From<&ListSettlementChargebacksResponse>
        for ListSettlementChargebacksResponse
    {
        fn from(value: &ListSettlementChargebacksResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListSettlementChargebacksResponse {
        fn default() -> Self {
            Self {
                count: Default::default(),
                embedded: Default::default(),
                links: Default::default(),
            }
        }
    }

    ///`ListSettlementChargebacksResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "chargebacks": {
    ///      "description": "A list of chargeback objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-chargeback"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListSettlementChargebacksResponseEmbedded {
        ///A list of chargeback objects.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub chargebacks: ::std::vec::Vec<EntityChargeback>,
    }

    impl ::std::convert::From<&ListSettlementChargebacksResponseEmbedded>
        for ListSettlementChargebacksResponseEmbedded
    {
        fn from(value: &ListSettlementChargebacksResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListSettlementChargebacksResponseEmbedded {
        fn default() -> Self {
            Self {
                chargebacks: Default::default(),
            }
        }
    }

    ///`ListSettlementPaymentsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "payments": {
    ///          "description": "An array of payment objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/payment-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListSettlementPaymentsResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListSettlementPaymentsResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListSettlementPaymentsResponse> for ListSettlementPaymentsResponse {
        fn from(value: &ListSettlementPaymentsResponse) -> Self {
            value.clone()
        }
    }

    ///`ListSettlementPaymentsResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "payments": {
    ///      "description": "An array of payment objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/payment-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListSettlementPaymentsResponseEmbedded {
        ///An array of payment objects.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub payments: ::std::vec::Vec<PaymentResponse>,
    }

    impl ::std::convert::From<&ListSettlementPaymentsResponseEmbedded>
        for ListSettlementPaymentsResponseEmbedded
    {
        fn from(value: &ListSettlementPaymentsResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListSettlementPaymentsResponseEmbedded {
        fn default() -> Self {
            Self {
                payments: Default::default(),
            }
        }
    }

    ///`ListSettlementPaymentsSort`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "desc"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListSettlementPaymentsSort {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for ListSettlementPaymentsSort {
        fn from(value: &ListSettlementPaymentsSort) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListSettlementPaymentsSort {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for ListSettlementPaymentsSort {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListSettlementPaymentsSort {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListSettlementPaymentsSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListSettlementPaymentsSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ListSettlementRefundsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "required": [
    ///        "refunds"
    ///      ],
    ///      "properties": {
    ///        "refunds": {
    ///          "description": "An array of refund objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-refund-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListSettlementRefundsResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListSettlementRefundsResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListSettlementRefundsResponse> for ListSettlementRefundsResponse {
        fn from(value: &ListSettlementRefundsResponse) -> Self {
            value.clone()
        }
    }

    ///`ListSettlementRefundsResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "refunds"
    ///  ],
    ///  "properties": {
    ///    "refunds": {
    ///      "description": "An array of refund objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-refund-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListSettlementRefundsResponseEmbedded {
        ///An array of refund objects.
        pub refunds: ::std::vec::Vec<EntityRefundResponse>,
    }

    impl ::std::convert::From<&ListSettlementRefundsResponseEmbedded>
        for ListSettlementRefundsResponseEmbedded
    {
        fn from(value: &ListSettlementRefundsResponseEmbedded) -> Self {
            value.clone()
        }
    }

    ///`ListSettlementsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "required": [
    ///        "settlements"
    ///      ],
    ///      "properties": {
    ///        "settlements": {
    ///          "description": "An array of settlement objects. For a complete
    /// reference\nof the settlement object, refer to the [Get settlement
    /// endpoint](get-settlement) documentation.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-settlement"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListSettlementsResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListSettlementsResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListSettlementsResponse> for ListSettlementsResponse {
        fn from(value: &ListSettlementsResponse) -> Self {
            value.clone()
        }
    }

    ///`ListSettlementsResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "settlements"
    ///  ],
    ///  "properties": {
    ///    "settlements": {
    ///      "description": "An array of settlement objects. For a complete
    /// reference\nof the settlement object, refer to the [Get settlement
    /// endpoint](get-settlement) documentation.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-settlement"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListSettlementsResponseEmbedded {
        ///An array of settlement objects. For a complete reference
        ///of the settlement object, refer to the [Get settlement
        /// endpoint](get-settlement) documentation.
        pub settlements: ::std::vec::Vec<EntitySettlement>,
    }

    impl ::std::convert::From<&ListSettlementsResponseEmbedded> for ListSettlementsResponseEmbedded {
        fn from(value: &ListSettlementsResponseEmbedded) -> Self {
            value.clone()
        }
    }

    ///`ListSubscriptionPaymentsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "payments": {
    ///          "description": "An array of payment objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/payment-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListSubscriptionPaymentsResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListSubscriptionPaymentsResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListSubscriptionPaymentsResponse> for ListSubscriptionPaymentsResponse {
        fn from(value: &ListSubscriptionPaymentsResponse) -> Self {
            value.clone()
        }
    }

    ///`ListSubscriptionPaymentsResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "payments": {
    ///      "description": "An array of payment objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/payment-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListSubscriptionPaymentsResponseEmbedded {
        ///An array of payment objects.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub payments: ::std::vec::Vec<PaymentResponse>,
    }

    impl ::std::convert::From<&ListSubscriptionPaymentsResponseEmbedded>
        for ListSubscriptionPaymentsResponseEmbedded
    {
        fn from(value: &ListSubscriptionPaymentsResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListSubscriptionPaymentsResponseEmbedded {
        fn default() -> Self {
            Self {
                payments: Default::default(),
            }
        }
    }

    ///`ListSubscriptionPaymentsSort`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "desc"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListSubscriptionPaymentsSort {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for ListSubscriptionPaymentsSort {
        fn from(value: &ListSubscriptionPaymentsSort) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListSubscriptionPaymentsSort {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for ListSubscriptionPaymentsSort {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListSubscriptionPaymentsSort {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListSubscriptionPaymentsSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListSubscriptionPaymentsSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ListSubscriptionsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "subscriptions": {
    ///          "description": "An array of subscription objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/subscription-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListSubscriptionsResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListSubscriptionsResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListSubscriptionsResponse> for ListSubscriptionsResponse {
        fn from(value: &ListSubscriptionsResponse) -> Self {
            value.clone()
        }
    }

    ///`ListSubscriptionsResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "subscriptions": {
    ///      "description": "An array of subscription objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/subscription-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListSubscriptionsResponseEmbedded {
        ///An array of subscription objects.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub subscriptions: ::std::vec::Vec<SubscriptionResponse>,
    }

    impl ::std::convert::From<&ListSubscriptionsResponseEmbedded>
        for ListSubscriptionsResponseEmbedded
    {
        fn from(value: &ListSubscriptionsResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListSubscriptionsResponseEmbedded {
        fn default() -> Self {
            Self {
                subscriptions: Default::default(),
            }
        }
    }

    ///`ListSubscriptionsSort`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "desc"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListSubscriptionsSort {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for ListSubscriptionsSort {
        fn from(value: &ListSubscriptionsSort) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListSubscriptionsSort {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for ListSubscriptionsSort {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListSubscriptionsSort {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListSubscriptionsSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListSubscriptionsSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ListTerminalsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "terminals": {
    ///          "description": "An array of terminal objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-terminal"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListTerminalsResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListTerminalsResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListTerminalsResponse> for ListTerminalsResponse {
        fn from(value: &ListTerminalsResponse) -> Self {
            value.clone()
        }
    }

    ///`ListTerminalsResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "terminals": {
    ///      "description": "An array of terminal objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-terminal"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListTerminalsResponseEmbedded {
        ///An array of terminal objects.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub terminals: ::std::vec::Vec<EntityTerminal>,
    }

    impl ::std::convert::From<&ListTerminalsResponseEmbedded> for ListTerminalsResponseEmbedded {
        fn from(value: &ListTerminalsResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListTerminalsResponseEmbedded {
        fn default() -> Self {
            Self {
                terminals: Default::default(),
            }
        }
    }

    ///`ListTerminalsSort`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "desc"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListTerminalsSort {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for ListTerminalsSort {
        fn from(value: &ListTerminalsSort) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListTerminalsSort {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for ListTerminalsSort {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListTerminalsSort {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListTerminalsSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListTerminalsSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ListWebhooksResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_embedded",
    ///    "_links",
    ///    "count"
    ///  ],
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "required": [
    ///        "webhooks"
    ///      ],
    ///      "properties": {
    ///        "webhooks": {
    ///          "description": "A list of webhooks.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/entity-webhook"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "$ref": "#/components/schemas/list-links"
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListWebhooksResponse {
        pub count: ListCount,
        #[serde(rename = "_embedded")]
        pub embedded: ListWebhooksResponseEmbedded,
        #[serde(rename = "_links")]
        pub links: ListLinks,
    }

    impl ::std::convert::From<&ListWebhooksResponse> for ListWebhooksResponse {
        fn from(value: &ListWebhooksResponse) -> Self {
            value.clone()
        }
    }

    ///`ListWebhooksResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "webhooks"
    ///  ],
    ///  "properties": {
    ///    "webhooks": {
    ///      "description": "A list of webhooks.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/entity-webhook"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ListWebhooksResponseEmbedded {
        ///A list of webhooks.
        pub webhooks: ::std::vec::Vec<EntityWebhook>,
    }

    impl ::std::convert::From<&ListWebhooksResponseEmbedded> for ListWebhooksResponseEmbedded {
        fn from(value: &ListWebhooksResponseEmbedded) -> Self {
            value.clone()
        }
    }

    ///`ListWebhooksSort`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "desc"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListWebhooksSort {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for ListWebhooksSort {
        fn from(value: &ListWebhooksSort) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListWebhooksSort {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for ListWebhooksSort {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListWebhooksSort {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListWebhooksSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListWebhooksSort {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Allows you to preset the language to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Allows you to preset the language to be used.",
    ///  "examples": [
    ///    "en_US"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "en_US",
    ///    "en_GB",
    ///    "nl_NL",
    ///    "nl_BE",
    ///    "de_DE",
    ///    "de_AT",
    ///    "de_CH",
    ///    "fr_FR",
    ///    "fr_BE",
    ///    "es_ES",
    ///    "ca_ES",
    ///    "pt_PT",
    ///    "it_IT",
    ///    "nb_NO",
    ///    "sv_SE",
    ///    "fi_FI",
    ///    "da_DK",
    ///    "is_IS",
    ///    "hu_HU",
    ///    "pl_PL",
    ///    "lv_LV",
    ///    "lt_LT"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct Locale(pub ::std::option::Option<LocaleInner>);
    impl ::std::ops::Deref for Locale {
        type Target = ::std::option::Option<LocaleInner>;
        fn deref(&self) -> &::std::option::Option<LocaleInner> {
            &self.0
        }
    }

    impl ::std::convert::From<Locale> for ::std::option::Option<LocaleInner> {
        fn from(value: Locale) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&Locale> for Locale {
        fn from(value: &Locale) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<LocaleInner>> for Locale {
        fn from(value: ::std::option::Option<LocaleInner>) -> Self {
            Self(value)
        }
    }

    ///Allows you to preset the language to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Allows you to preset the language to be used.",
    ///  "examples": [
    ///    "en_US"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "en_US",
    ///    "en_GB",
    ///    "nl_NL",
    ///    "nl_BE",
    ///    "de_DE",
    ///    "de_AT",
    ///    "de_CH",
    ///    "fr_FR",
    ///    "fr_BE",
    ///    "es_ES",
    ///    "ca_ES",
    ///    "pt_PT",
    ///    "it_IT",
    ///    "nb_NO",
    ///    "sv_SE",
    ///    "fi_FI",
    ///    "da_DK",
    ///    "is_IS",
    ///    "hu_HU",
    ///    "pl_PL",
    ///    "lv_LV",
    ///    "lt_LT"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LocaleInner {
        #[serde(rename = "en_US")]
        EnUs,
        #[serde(rename = "en_GB")]
        EnGb,
        #[serde(rename = "nl_NL")]
        NlNl,
        #[serde(rename = "nl_BE")]
        NlBe,
        #[serde(rename = "de_DE")]
        DeDe,
        #[serde(rename = "de_AT")]
        DeAt,
        #[serde(rename = "de_CH")]
        DeCh,
        #[serde(rename = "fr_FR")]
        FrFr,
        #[serde(rename = "fr_BE")]
        FrBe,
        #[serde(rename = "es_ES")]
        EsEs,
        #[serde(rename = "ca_ES")]
        CaEs,
        #[serde(rename = "pt_PT")]
        PtPt,
        #[serde(rename = "it_IT")]
        ItIt,
        #[serde(rename = "nb_NO")]
        NbNo,
        #[serde(rename = "sv_SE")]
        SvSe,
        #[serde(rename = "fi_FI")]
        FiFi,
        #[serde(rename = "da_DK")]
        DaDk,
        #[serde(rename = "is_IS")]
        IsIs,
        #[serde(rename = "hu_HU")]
        HuHu,
        #[serde(rename = "pl_PL")]
        PlPl,
        #[serde(rename = "lv_LV")]
        LvLv,
        #[serde(rename = "lt_LT")]
        LtLt,
    }

    impl ::std::convert::From<&Self> for LocaleInner {
        fn from(value: &LocaleInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LocaleInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EnUs => f.write_str("en_US"),
                Self::EnGb => f.write_str("en_GB"),
                Self::NlNl => f.write_str("nl_NL"),
                Self::NlBe => f.write_str("nl_BE"),
                Self::DeDe => f.write_str("de_DE"),
                Self::DeAt => f.write_str("de_AT"),
                Self::DeCh => f.write_str("de_CH"),
                Self::FrFr => f.write_str("fr_FR"),
                Self::FrBe => f.write_str("fr_BE"),
                Self::EsEs => f.write_str("es_ES"),
                Self::CaEs => f.write_str("ca_ES"),
                Self::PtPt => f.write_str("pt_PT"),
                Self::ItIt => f.write_str("it_IT"),
                Self::NbNo => f.write_str("nb_NO"),
                Self::SvSe => f.write_str("sv_SE"),
                Self::FiFi => f.write_str("fi_FI"),
                Self::DaDk => f.write_str("da_DK"),
                Self::IsIs => f.write_str("is_IS"),
                Self::HuHu => f.write_str("hu_HU"),
                Self::PlPl => f.write_str("pl_PL"),
                Self::LvLv => f.write_str("lv_LV"),
                Self::LtLt => f.write_str("lt_LT"),
            }
        }
    }

    impl ::std::str::FromStr for LocaleInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "en_US" => Ok(Self::EnUs),
                "en_GB" => Ok(Self::EnGb),
                "nl_NL" => Ok(Self::NlNl),
                "nl_BE" => Ok(Self::NlBe),
                "de_DE" => Ok(Self::DeDe),
                "de_AT" => Ok(Self::DeAt),
                "de_CH" => Ok(Self::DeCh),
                "fr_FR" => Ok(Self::FrFr),
                "fr_BE" => Ok(Self::FrBe),
                "es_ES" => Ok(Self::EsEs),
                "ca_ES" => Ok(Self::CaEs),
                "pt_PT" => Ok(Self::PtPt),
                "it_IT" => Ok(Self::ItIt),
                "nb_NO" => Ok(Self::NbNo),
                "sv_SE" => Ok(Self::SvSe),
                "fi_FI" => Ok(Self::FiFi),
                "da_DK" => Ok(Self::DaDk),
                "is_IS" => Ok(Self::IsIs),
                "hu_HU" => Ok(Self::HuHu),
                "pl_PL" => Ok(Self::PlPl),
                "lv_LV" => Ok(Self::LvLv),
                "lt_LT" => Ok(Self::LtLt),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LocaleInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LocaleInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LocaleInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Allows you to preset the language to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Allows you to preset the language to be used.",
    ///  "examples": [
    ///    "en_US"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "en_US",
    ///    "en_GB",
    ///    "nl_NL",
    ///    "nl_BE",
    ///    "de_DE",
    ///    "de_AT",
    ///    "de_CH",
    ///    "fr_FR",
    ///    "fr_BE",
    ///    "es_ES",
    ///    "ca_ES",
    ///    "pt_PT",
    ///    "it_IT",
    ///    "nb_NO",
    ///    "sv_SE",
    ///    "fi_FI",
    ///    "da_DK",
    ///    "is_IS",
    ///    "hu_HU",
    ///    "pl_PL",
    ///    "lv_LV",
    ///    "lt_LT"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct LocaleResponse(pub ::std::option::Option<LocaleResponseInner>);
    impl ::std::ops::Deref for LocaleResponse {
        type Target = ::std::option::Option<LocaleResponseInner>;
        fn deref(&self) -> &::std::option::Option<LocaleResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<LocaleResponse> for ::std::option::Option<LocaleResponseInner> {
        fn from(value: LocaleResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LocaleResponse> for LocaleResponse {
        fn from(value: &LocaleResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<LocaleResponseInner>> for LocaleResponse {
        fn from(value: ::std::option::Option<LocaleResponseInner>) -> Self {
            Self(value)
        }
    }

    ///Allows you to preset the language to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Allows you to preset the language to be used.",
    ///  "examples": [
    ///    "en_US"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "en_US",
    ///    "en_GB",
    ///    "nl_NL",
    ///    "nl_BE",
    ///    "de_DE",
    ///    "de_AT",
    ///    "de_CH",
    ///    "fr_FR",
    ///    "fr_BE",
    ///    "es_ES",
    ///    "ca_ES",
    ///    "pt_PT",
    ///    "it_IT",
    ///    "nb_NO",
    ///    "sv_SE",
    ///    "fi_FI",
    ///    "da_DK",
    ///    "is_IS",
    ///    "hu_HU",
    ///    "pl_PL",
    ///    "lv_LV",
    ///    "lt_LT"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LocaleResponseInner {
        #[serde(rename = "en_US")]
        EnUs,
        #[serde(rename = "en_GB")]
        EnGb,
        #[serde(rename = "nl_NL")]
        NlNl,
        #[serde(rename = "nl_BE")]
        NlBe,
        #[serde(rename = "de_DE")]
        DeDe,
        #[serde(rename = "de_AT")]
        DeAt,
        #[serde(rename = "de_CH")]
        DeCh,
        #[serde(rename = "fr_FR")]
        FrFr,
        #[serde(rename = "fr_BE")]
        FrBe,
        #[serde(rename = "es_ES")]
        EsEs,
        #[serde(rename = "ca_ES")]
        CaEs,
        #[serde(rename = "pt_PT")]
        PtPt,
        #[serde(rename = "it_IT")]
        ItIt,
        #[serde(rename = "nb_NO")]
        NbNo,
        #[serde(rename = "sv_SE")]
        SvSe,
        #[serde(rename = "fi_FI")]
        FiFi,
        #[serde(rename = "da_DK")]
        DaDk,
        #[serde(rename = "is_IS")]
        IsIs,
        #[serde(rename = "hu_HU")]
        HuHu,
        #[serde(rename = "pl_PL")]
        PlPl,
        #[serde(rename = "lv_LV")]
        LvLv,
        #[serde(rename = "lt_LT")]
        LtLt,
    }

    impl ::std::convert::From<&Self> for LocaleResponseInner {
        fn from(value: &LocaleResponseInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LocaleResponseInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EnUs => f.write_str("en_US"),
                Self::EnGb => f.write_str("en_GB"),
                Self::NlNl => f.write_str("nl_NL"),
                Self::NlBe => f.write_str("nl_BE"),
                Self::DeDe => f.write_str("de_DE"),
                Self::DeAt => f.write_str("de_AT"),
                Self::DeCh => f.write_str("de_CH"),
                Self::FrFr => f.write_str("fr_FR"),
                Self::FrBe => f.write_str("fr_BE"),
                Self::EsEs => f.write_str("es_ES"),
                Self::CaEs => f.write_str("ca_ES"),
                Self::PtPt => f.write_str("pt_PT"),
                Self::ItIt => f.write_str("it_IT"),
                Self::NbNo => f.write_str("nb_NO"),
                Self::SvSe => f.write_str("sv_SE"),
                Self::FiFi => f.write_str("fi_FI"),
                Self::DaDk => f.write_str("da_DK"),
                Self::IsIs => f.write_str("is_IS"),
                Self::HuHu => f.write_str("hu_HU"),
                Self::PlPl => f.write_str("pl_PL"),
                Self::LvLv => f.write_str("lv_LV"),
                Self::LtLt => f.write_str("lt_LT"),
            }
        }
    }

    impl ::std::str::FromStr for LocaleResponseInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "en_US" => Ok(Self::EnUs),
                "en_GB" => Ok(Self::EnGb),
                "nl_NL" => Ok(Self::NlNl),
                "nl_BE" => Ok(Self::NlBe),
                "de_DE" => Ok(Self::DeDe),
                "de_AT" => Ok(Self::DeAt),
                "de_CH" => Ok(Self::DeCh),
                "fr_FR" => Ok(Self::FrFr),
                "fr_BE" => Ok(Self::FrBe),
                "es_ES" => Ok(Self::EsEs),
                "ca_ES" => Ok(Self::CaEs),
                "pt_PT" => Ok(Self::PtPt),
                "it_IT" => Ok(Self::ItIt),
                "nb_NO" => Ok(Self::NbNo),
                "sv_SE" => Ok(Self::SvSe),
                "fi_FI" => Ok(Self::FiFi),
                "da_DK" => Ok(Self::DaDk),
                "is_IS" => Ok(Self::IsIs),
                "hu_HU" => Ok(Self::HuHu),
                "pl_PL" => Ok(Self::PlPl),
                "lv_LV" => Ok(Self::LvLv),
                "lt_LT" => Ok(Self::LtLt),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LocaleResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LocaleResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LocaleResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The card's label. Available for card mandates, if the card label could
    /// be detected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The card's label. Available for card mandates, if the
    /// card label could be detected.",
    ///  "examples": [
    ///    "Visa"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "American Express",
    ///    "Carta Si",
    ///    "Carte Bleue",
    ///    "Dankort",
    ///    "Diners Club",
    ///    "Discover",
    ///    "JCB",
    ///    "Laser",
    ///    "Maestro",
    ///    "Mastercard",
    ///    "Unionpay",
    ///    "Visa"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct MandateDetailsCardLabel(pub ::std::option::Option<MandateDetailsCardLabelInner>);
    impl ::std::ops::Deref for MandateDetailsCardLabel {
        type Target = ::std::option::Option<MandateDetailsCardLabelInner>;
        fn deref(&self) -> &::std::option::Option<MandateDetailsCardLabelInner> {
            &self.0
        }
    }

    impl ::std::convert::From<MandateDetailsCardLabel>
        for ::std::option::Option<MandateDetailsCardLabelInner>
    {
        fn from(value: MandateDetailsCardLabel) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&MandateDetailsCardLabel> for MandateDetailsCardLabel {
        fn from(value: &MandateDetailsCardLabel) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<MandateDetailsCardLabelInner>>
        for MandateDetailsCardLabel
    {
        fn from(value: ::std::option::Option<MandateDetailsCardLabelInner>) -> Self {
            Self(value)
        }
    }

    ///The card's label. Available for card mandates, if the card label could
    /// be detected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The card's label. Available for card mandates, if the
    /// card label could be detected.",
    ///  "examples": [
    ///    "Visa"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "American Express",
    ///    "Carta Si",
    ///    "Carte Bleue",
    ///    "Dankort",
    ///    "Diners Club",
    ///    "Discover",
    ///    "JCB",
    ///    "Laser",
    ///    "Maestro",
    ///    "Mastercard",
    ///    "Unionpay",
    ///    "Visa"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MandateDetailsCardLabelInner {
        #[serde(rename = "American Express")]
        AmericanExpress,
        #[serde(rename = "Carta Si")]
        CartaSi,
        #[serde(rename = "Carte Bleue")]
        CarteBleue,
        Dankort,
        #[serde(rename = "Diners Club")]
        DinersClub,
        Discover,
        #[serde(rename = "JCB")]
        Jcb,
        Laser,
        Maestro,
        Mastercard,
        Unionpay,
        Visa,
    }

    impl ::std::convert::From<&Self> for MandateDetailsCardLabelInner {
        fn from(value: &MandateDetailsCardLabelInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for MandateDetailsCardLabelInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AmericanExpress => f.write_str("American Express"),
                Self::CartaSi => f.write_str("Carta Si"),
                Self::CarteBleue => f.write_str("Carte Bleue"),
                Self::Dankort => f.write_str("Dankort"),
                Self::DinersClub => f.write_str("Diners Club"),
                Self::Discover => f.write_str("Discover"),
                Self::Jcb => f.write_str("JCB"),
                Self::Laser => f.write_str("Laser"),
                Self::Maestro => f.write_str("Maestro"),
                Self::Mastercard => f.write_str("Mastercard"),
                Self::Unionpay => f.write_str("Unionpay"),
                Self::Visa => f.write_str("Visa"),
            }
        }
    }

    impl ::std::str::FromStr for MandateDetailsCardLabelInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "American Express" => Ok(Self::AmericanExpress),
                "Carta Si" => Ok(Self::CartaSi),
                "Carte Bleue" => Ok(Self::CarteBleue),
                "Dankort" => Ok(Self::Dankort),
                "Diners Club" => Ok(Self::DinersClub),
                "Discover" => Ok(Self::Discover),
                "JCB" => Ok(Self::Jcb),
                "Laser" => Ok(Self::Laser),
                "Maestro" => Ok(Self::Maestro),
                "Mastercard" => Ok(Self::Mastercard),
                "Unionpay" => Ok(Self::Unionpay),
                "Visa" => Ok(Self::Visa),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for MandateDetailsCardLabelInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for MandateDetailsCardLabelInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for MandateDetailsCardLabelInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The card's label. Available for card mandates, if the card label could
    /// be detected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The card's label. Available for card mandates, if the
    /// card label could be detected.",
    ///  "examples": [
    ///    "Visa"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "American Express",
    ///    "Carta Si",
    ///    "Carte Bleue",
    ///    "Dankort",
    ///    "Diners Club",
    ///    "Discover",
    ///    "JCB",
    ///    "Laser",
    ///    "Maestro",
    ///    "Mastercard",
    ///    "Unionpay",
    ///    "Visa"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct MandateDetailsCardLabelResponse(
        pub ::std::option::Option<MandateDetailsCardLabelResponseInner>,
    );
    impl ::std::ops::Deref for MandateDetailsCardLabelResponse {
        type Target = ::std::option::Option<MandateDetailsCardLabelResponseInner>;
        fn deref(&self) -> &::std::option::Option<MandateDetailsCardLabelResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<MandateDetailsCardLabelResponse>
        for ::std::option::Option<MandateDetailsCardLabelResponseInner>
    {
        fn from(value: MandateDetailsCardLabelResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&MandateDetailsCardLabelResponse> for MandateDetailsCardLabelResponse {
        fn from(value: &MandateDetailsCardLabelResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<MandateDetailsCardLabelResponseInner>>
        for MandateDetailsCardLabelResponse
    {
        fn from(value: ::std::option::Option<MandateDetailsCardLabelResponseInner>) -> Self {
            Self(value)
        }
    }

    ///The card's label. Available for card mandates, if the card label could
    /// be detected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The card's label. Available for card mandates, if the
    /// card label could be detected.",
    ///  "examples": [
    ///    "Visa"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "American Express",
    ///    "Carta Si",
    ///    "Carte Bleue",
    ///    "Dankort",
    ///    "Diners Club",
    ///    "Discover",
    ///    "JCB",
    ///    "Laser",
    ///    "Maestro",
    ///    "Mastercard",
    ///    "Unionpay",
    ///    "Visa"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MandateDetailsCardLabelResponseInner {
        #[serde(rename = "American Express")]
        AmericanExpress,
        #[serde(rename = "Carta Si")]
        CartaSi,
        #[serde(rename = "Carte Bleue")]
        CarteBleue,
        Dankort,
        #[serde(rename = "Diners Club")]
        DinersClub,
        Discover,
        #[serde(rename = "JCB")]
        Jcb,
        Laser,
        Maestro,
        Mastercard,
        Unionpay,
        Visa,
    }

    impl ::std::convert::From<&Self> for MandateDetailsCardLabelResponseInner {
        fn from(value: &MandateDetailsCardLabelResponseInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for MandateDetailsCardLabelResponseInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AmericanExpress => f.write_str("American Express"),
                Self::CartaSi => f.write_str("Carta Si"),
                Self::CarteBleue => f.write_str("Carte Bleue"),
                Self::Dankort => f.write_str("Dankort"),
                Self::DinersClub => f.write_str("Diners Club"),
                Self::Discover => f.write_str("Discover"),
                Self::Jcb => f.write_str("JCB"),
                Self::Laser => f.write_str("Laser"),
                Self::Maestro => f.write_str("Maestro"),
                Self::Mastercard => f.write_str("Mastercard"),
                Self::Unionpay => f.write_str("Unionpay"),
                Self::Visa => f.write_str("Visa"),
            }
        }
    }

    impl ::std::str::FromStr for MandateDetailsCardLabelResponseInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "American Express" => Ok(Self::AmericanExpress),
                "Carta Si" => Ok(Self::CartaSi),
                "Carte Bleue" => Ok(Self::CarteBleue),
                "Dankort" => Ok(Self::Dankort),
                "Diners Club" => Ok(Self::DinersClub),
                "Discover" => Ok(Self::Discover),
                "JCB" => Ok(Self::Jcb),
                "Laser" => Ok(Self::Laser),
                "Maestro" => Ok(Self::Maestro),
                "Mastercard" => Ok(Self::Mastercard),
                "Unionpay" => Ok(Self::Unionpay),
                "Visa" => Ok(Self::Visa),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for MandateDetailsCardLabelResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for MandateDetailsCardLabelResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for MandateDetailsCardLabelResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Payment method of the mandate.
    ///
    ///SEPA Direct Debit and PayPal mandates can be created directly.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payment method of the mandate.\n\nSEPA Direct Debit and
    /// PayPal mandates can be created directly.",
    ///  "examples": [
    ///    "directdebit"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "creditcard",
    ///    "directdebit",
    ///    "paypal"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MandateMethod {
        #[serde(rename = "creditcard")]
        Creditcard,
        #[serde(rename = "directdebit")]
        Directdebit,
        #[serde(rename = "paypal")]
        Paypal,
    }

    impl ::std::convert::From<&Self> for MandateMethod {
        fn from(value: &MandateMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for MandateMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Creditcard => f.write_str("creditcard"),
                Self::Directdebit => f.write_str("directdebit"),
                Self::Paypal => f.write_str("paypal"),
            }
        }
    }

    impl ::std::str::FromStr for MandateMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "creditcard" => Ok(Self::Creditcard),
                "directdebit" => Ok(Self::Directdebit),
                "paypal" => Ok(Self::Paypal),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for MandateMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for MandateMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for MandateMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Payment method of the mandate.
    ///
    ///SEPA Direct Debit and PayPal mandates can be created directly.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payment method of the mandate.\n\nSEPA Direct Debit and
    /// PayPal mandates can be created directly.",
    ///  "examples": [
    ///    "directdebit"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "creditcard",
    ///    "directdebit",
    ///    "paypal"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MandateMethodResponse {
        #[serde(rename = "creditcard")]
        Creditcard,
        #[serde(rename = "directdebit")]
        Directdebit,
        #[serde(rename = "paypal")]
        Paypal,
    }

    impl ::std::convert::From<&Self> for MandateMethodResponse {
        fn from(value: &MandateMethodResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for MandateMethodResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Creditcard => f.write_str("creditcard"),
                Self::Directdebit => f.write_str("directdebit"),
                Self::Paypal => f.write_str("paypal"),
            }
        }
    }

    impl ::std::str::FromStr for MandateMethodResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "creditcard" => Ok(Self::Creditcard),
                "directdebit" => Ok(Self::Directdebit),
                "paypal" => Ok(Self::Paypal),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for MandateMethodResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for MandateMethodResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for MandateMethodResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`MandateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/entity-mandate"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct MandateRequest(pub EntityMandate);
    impl ::std::ops::Deref for MandateRequest {
        type Target = EntityMandate;
        fn deref(&self) -> &EntityMandate {
            &self.0
        }
    }

    impl ::std::convert::From<MandateRequest> for EntityMandate {
        fn from(value: MandateRequest) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&MandateRequest> for MandateRequest {
        fn from(value: &MandateRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<EntityMandate> for MandateRequest {
        fn from(value: EntityMandate) -> Self {
            Self(value)
        }
    }

    ///`MandateResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/entity-mandate-response"
    ///    }
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct MandateResponse(pub EntityMandateResponse);
    impl ::std::ops::Deref for MandateResponse {
        type Target = EntityMandateResponse;
        fn deref(&self) -> &EntityMandateResponse {
            &self.0
        }
    }

    impl ::std::convert::From<MandateResponse> for EntityMandateResponse {
        fn from(value: MandateResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&MandateResponse> for MandateResponse {
        fn from(value: &MandateResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<EntityMandateResponse> for MandateResponse {
        fn from(value: EntityMandateResponse) -> Self {
            Self(value)
        }
    }

    ///The status of the mandate. A status can be `pending` for mandates when
    /// the first payment is not yet finalized, or when we did not received
    /// the IBAN yet from the first payment.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status of the mandate. A status can be `pending`
    /// for mandates when the first payment is not yet finalized, or\nwhen we
    /// did not received the IBAN yet from the first payment.",
    ///  "examples": [
    ///    "valid"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "valid",
    ///    "pending",
    ///    "invalid"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MandateStatus {
        #[serde(rename = "valid")]
        Valid,
        #[serde(rename = "pending")]
        Pending,
        #[serde(rename = "invalid")]
        Invalid,
    }

    impl ::std::convert::From<&Self> for MandateStatus {
        fn from(value: &MandateStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for MandateStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Valid => f.write_str("valid"),
                Self::Pending => f.write_str("pending"),
                Self::Invalid => f.write_str("invalid"),
            }
        }
    }

    impl ::std::str::FromStr for MandateStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "valid" => Ok(Self::Valid),
                "pending" => Ok(Self::Pending),
                "invalid" => Ok(Self::Invalid),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for MandateStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for MandateStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for MandateStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`MandateToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "mdt_5B8cwPMGnU"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct MandateToken(pub ::std::string::String);
    impl ::std::ops::Deref for MandateToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<MandateToken> for ::std::string::String {
        fn from(value: MandateToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&MandateToken> for MandateToken {
        fn from(value: &MandateToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for MandateToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for MandateToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for MandateToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///Provide any data you like, for example a string or a JSON object. We
    /// will save the data alongside the entity. Whenever you fetch the
    /// entity with our API, we will also include the metadata. You can use up
    /// to approximately 1kB.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Provide any data you like, for example a string or a
    /// JSON object. We will save the data alongside the entity. Whenever\nyou
    /// fetch the entity with our API, we will also include the metadata. You
    /// can use up to approximately 1kB.",
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "additionalProperties": true
    ///    },
    ///    {
    ///      "type": "array",
    ///      "items": {
    ///        "type": [
    ///          "string",
    ///          "null"
    ///        ]
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum Metadata {
        Variant0(::std::string::String),
        Variant1(::serde_json::Map<::std::string::String, ::serde_json::Value>),
        Variant2(::std::vec::Vec<::std::option::Option<::std::string::String>>),
    }

    impl ::std::convert::From<&Self> for Metadata {
        fn from(value: &Metadata) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::serde_json::Map<::std::string::String, ::serde_json::Value>>
        for Metadata
    {
        fn from(value: ::serde_json::Map<::std::string::String, ::serde_json::Value>) -> Self {
            Self::Variant1(value)
        }
    }

    impl ::std::convert::From<::std::vec::Vec<::std::option::Option<::std::string::String>>>
        for Metadata
    {
        fn from(value: ::std::vec::Vec<::std::option::Option<::std::string::String>>) -> Self {
            Self::Variant2(value)
        }
    }

    ///Normally, a payment method screen is shown. However, when using this
    /// parameter, you can choose a specific payment method and your
    /// customer will skip the selection screen and is sent directly to the
    /// chosen payment method. The parameter enables you to fully integrate
    /// the payment method selection into your website.
    ///
    ///You can also specify the methods in an array. By doing so we will still
    /// show the payment method selection screen but will only show the
    /// methods specified in the array. For example, you can use this
    /// functionality to only show payment methods from a specific country
    /// to your customer `['bancontact', 'belfius']`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Normally, a payment method screen is shown. However,
    /// when using this parameter, you can choose a specific payment\nmethod and
    /// your customer will skip the selection screen and is sent directly to the
    /// chosen payment method. The\nparameter enables you to fully integrate the
    /// payment method selection into your website.\n\nYou can also specify the
    /// methods in an array. By doing so we will still show the payment method
    /// selection screen\nbut will only show the methods specified in the array.
    /// For example, you can use this functionality to only show\npayment
    /// methods from a specific country to your customer `['bancontact',
    /// 'belfius']`.",
    ///  "examples": [
    ///    "ideal"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "alma",
    ///    "applepay",
    ///    "bacs",
    ///    "bancomatpay",
    ///    "bancontact",
    ///    "banktransfer",
    ///    "belfius",
    ///    "billie",
    ///    "bizum",
    ///    "blik",
    ///    "creditcard",
    ///    "directdebit",
    ///    "eps",
    ///    "giftcard",
    ///    "ideal",
    ///    "in3",
    ///    "kbc",
    ///    "klarna",
    ///    "klarnapaylater",
    ///    "klarnapaynow",
    ///    "klarnasliceit",
    ///    "mbway",
    ///    "mobilepay",
    ///    "multibanco",
    ///    "mybank",
    ///    "paybybank",
    ///    "payconiq",
    ///    "paypal",
    ///    "paysafecard",
    ///    "pointofsale",
    ///    "przelewy24",
    ///    "riverty",
    ///    "satispay",
    ///    "swish",
    ///    "trustly",
    ///    "twint",
    ///    "vipps",
    ///    "voucher"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct Method(pub ::std::option::Option<MethodInner>);
    impl ::std::ops::Deref for Method {
        type Target = ::std::option::Option<MethodInner>;
        fn deref(&self) -> &::std::option::Option<MethodInner> {
            &self.0
        }
    }

    impl ::std::convert::From<Method> for ::std::option::Option<MethodInner> {
        fn from(value: Method) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&Method> for Method {
        fn from(value: &Method) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<MethodInner>> for Method {
        fn from(value: ::std::option::Option<MethodInner>) -> Self {
            Self(value)
        }
    }

    ///Normally, a payment method screen is shown. However, when using this
    /// parameter, you can choose a specific payment method and your
    /// customer will skip the selection screen and is sent directly to the
    /// chosen payment method. The parameter enables you to fully integrate
    /// the payment method selection into your website.
    ///
    ///You can also specify the methods in an array. By doing so we will still
    /// show the payment method selection screen but will only show the
    /// methods specified in the array. For example, you can use this
    /// functionality to only show payment methods from a specific country
    /// to your customer `['bancontact', 'belfius']`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Normally, a payment method screen is shown. However,
    /// when using this parameter, you can choose a specific payment\nmethod and
    /// your customer will skip the selection screen and is sent directly to the
    /// chosen payment method. The\nparameter enables you to fully integrate the
    /// payment method selection into your website.\n\nYou can also specify the
    /// methods in an array. By doing so we will still show the payment method
    /// selection screen\nbut will only show the methods specified in the array.
    /// For example, you can use this functionality to only show\npayment
    /// methods from a specific country to your customer `['bancontact',
    /// 'belfius']`.",
    ///  "examples": [
    ///    "ideal"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "alma",
    ///    "applepay",
    ///    "bacs",
    ///    "bancomatpay",
    ///    "bancontact",
    ///    "banktransfer",
    ///    "belfius",
    ///    "billie",
    ///    "bizum",
    ///    "blik",
    ///    "creditcard",
    ///    "directdebit",
    ///    "eps",
    ///    "giftcard",
    ///    "ideal",
    ///    "in3",
    ///    "kbc",
    ///    "klarna",
    ///    "klarnapaylater",
    ///    "klarnapaynow",
    ///    "klarnasliceit",
    ///    "mbway",
    ///    "mobilepay",
    ///    "multibanco",
    ///    "mybank",
    ///    "paybybank",
    ///    "payconiq",
    ///    "paypal",
    ///    "paysafecard",
    ///    "pointofsale",
    ///    "przelewy24",
    ///    "riverty",
    ///    "satispay",
    ///    "swish",
    ///    "trustly",
    ///    "twint",
    ///    "vipps",
    ///    "voucher"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MethodInner {
        #[serde(rename = "alma")]
        Alma,
        #[serde(rename = "applepay")]
        Applepay,
        #[serde(rename = "bacs")]
        Bacs,
        #[serde(rename = "bancomatpay")]
        Bancomatpay,
        #[serde(rename = "bancontact")]
        Bancontact,
        #[serde(rename = "banktransfer")]
        Banktransfer,
        #[serde(rename = "belfius")]
        Belfius,
        #[serde(rename = "billie")]
        Billie,
        #[serde(rename = "bizum")]
        Bizum,
        #[serde(rename = "blik")]
        Blik,
        #[serde(rename = "creditcard")]
        Creditcard,
        #[serde(rename = "directdebit")]
        Directdebit,
        #[serde(rename = "eps")]
        Eps,
        #[serde(rename = "giftcard")]
        Giftcard,
        #[serde(rename = "ideal")]
        Ideal,
        #[serde(rename = "in3")]
        In3,
        #[serde(rename = "kbc")]
        Kbc,
        #[serde(rename = "klarna")]
        Klarna,
        #[serde(rename = "klarnapaylater")]
        Klarnapaylater,
        #[serde(rename = "klarnapaynow")]
        Klarnapaynow,
        #[serde(rename = "klarnasliceit")]
        Klarnasliceit,
        #[serde(rename = "mbway")]
        Mbway,
        #[serde(rename = "mobilepay")]
        Mobilepay,
        #[serde(rename = "multibanco")]
        Multibanco,
        #[serde(rename = "mybank")]
        Mybank,
        #[serde(rename = "paybybank")]
        Paybybank,
        #[serde(rename = "payconiq")]
        Payconiq,
        #[serde(rename = "paypal")]
        Paypal,
        #[serde(rename = "paysafecard")]
        Paysafecard,
        #[serde(rename = "pointofsale")]
        Pointofsale,
        #[serde(rename = "przelewy24")]
        Przelewy24,
        #[serde(rename = "riverty")]
        Riverty,
        #[serde(rename = "satispay")]
        Satispay,
        #[serde(rename = "swish")]
        Swish,
        #[serde(rename = "trustly")]
        Trustly,
        #[serde(rename = "twint")]
        Twint,
        #[serde(rename = "vipps")]
        Vipps,
        #[serde(rename = "voucher")]
        Voucher,
    }

    impl ::std::convert::From<&Self> for MethodInner {
        fn from(value: &MethodInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for MethodInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Alma => f.write_str("alma"),
                Self::Applepay => f.write_str("applepay"),
                Self::Bacs => f.write_str("bacs"),
                Self::Bancomatpay => f.write_str("bancomatpay"),
                Self::Bancontact => f.write_str("bancontact"),
                Self::Banktransfer => f.write_str("banktransfer"),
                Self::Belfius => f.write_str("belfius"),
                Self::Billie => f.write_str("billie"),
                Self::Bizum => f.write_str("bizum"),
                Self::Blik => f.write_str("blik"),
                Self::Creditcard => f.write_str("creditcard"),
                Self::Directdebit => f.write_str("directdebit"),
                Self::Eps => f.write_str("eps"),
                Self::Giftcard => f.write_str("giftcard"),
                Self::Ideal => f.write_str("ideal"),
                Self::In3 => f.write_str("in3"),
                Self::Kbc => f.write_str("kbc"),
                Self::Klarna => f.write_str("klarna"),
                Self::Klarnapaylater => f.write_str("klarnapaylater"),
                Self::Klarnapaynow => f.write_str("klarnapaynow"),
                Self::Klarnasliceit => f.write_str("klarnasliceit"),
                Self::Mbway => f.write_str("mbway"),
                Self::Mobilepay => f.write_str("mobilepay"),
                Self::Multibanco => f.write_str("multibanco"),
                Self::Mybank => f.write_str("mybank"),
                Self::Paybybank => f.write_str("paybybank"),
                Self::Payconiq => f.write_str("payconiq"),
                Self::Paypal => f.write_str("paypal"),
                Self::Paysafecard => f.write_str("paysafecard"),
                Self::Pointofsale => f.write_str("pointofsale"),
                Self::Przelewy24 => f.write_str("przelewy24"),
                Self::Riverty => f.write_str("riverty"),
                Self::Satispay => f.write_str("satispay"),
                Self::Swish => f.write_str("swish"),
                Self::Trustly => f.write_str("trustly"),
                Self::Twint => f.write_str("twint"),
                Self::Vipps => f.write_str("vipps"),
                Self::Voucher => f.write_str("voucher"),
            }
        }
    }

    impl ::std::str::FromStr for MethodInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "alma" => Ok(Self::Alma),
                "applepay" => Ok(Self::Applepay),
                "bacs" => Ok(Self::Bacs),
                "bancomatpay" => Ok(Self::Bancomatpay),
                "bancontact" => Ok(Self::Bancontact),
                "banktransfer" => Ok(Self::Banktransfer),
                "belfius" => Ok(Self::Belfius),
                "billie" => Ok(Self::Billie),
                "bizum" => Ok(Self::Bizum),
                "blik" => Ok(Self::Blik),
                "creditcard" => Ok(Self::Creditcard),
                "directdebit" => Ok(Self::Directdebit),
                "eps" => Ok(Self::Eps),
                "giftcard" => Ok(Self::Giftcard),
                "ideal" => Ok(Self::Ideal),
                "in3" => Ok(Self::In3),
                "kbc" => Ok(Self::Kbc),
                "klarna" => Ok(Self::Klarna),
                "klarnapaylater" => Ok(Self::Klarnapaylater),
                "klarnapaynow" => Ok(Self::Klarnapaynow),
                "klarnasliceit" => Ok(Self::Klarnasliceit),
                "mbway" => Ok(Self::Mbway),
                "mobilepay" => Ok(Self::Mobilepay),
                "multibanco" => Ok(Self::Multibanco),
                "mybank" => Ok(Self::Mybank),
                "paybybank" => Ok(Self::Paybybank),
                "payconiq" => Ok(Self::Payconiq),
                "paypal" => Ok(Self::Paypal),
                "paysafecard" => Ok(Self::Paysafecard),
                "pointofsale" => Ok(Self::Pointofsale),
                "przelewy24" => Ok(Self::Przelewy24),
                "riverty" => Ok(Self::Riverty),
                "satispay" => Ok(Self::Satispay),
                "swish" => Ok(Self::Swish),
                "trustly" => Ok(Self::Trustly),
                "twint" => Ok(Self::Twint),
                "vipps" => Ok(Self::Vipps),
                "voucher" => Ok(Self::Voucher),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for MethodInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for MethodInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for MethodInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The status of the issuer.
    ///If the status is `pending-issuer`, an additional action from your side
    /// may be required with the issuer.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status of the issuer.\nIf the status is
    /// `pending-issuer`, an additional action from your side may be required
    /// with the issuer.",
    ///  "examples": [
    ///    "activated"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "activated",
    ///    "pending-issuer"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MethodIssuerStatus {
        #[serde(rename = "activated")]
        Activated,
        #[serde(rename = "pending-issuer")]
        PendingIssuer,
    }

    impl ::std::convert::From<&Self> for MethodIssuerStatus {
        fn from(value: &MethodIssuerStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for MethodIssuerStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Activated => f.write_str("activated"),
                Self::PendingIssuer => f.write_str("pending-issuer"),
            }
        }
    }

    impl ::std::str::FromStr for MethodIssuerStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "activated" => Ok(Self::Activated),
                "pending-issuer" => Ok(Self::PendingIssuer),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for MethodIssuerStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for MethodIssuerStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for MethodIssuerStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Normally, a payment method screen is shown. However, when using this
    /// parameter, you can choose a specific payment method and your
    /// customer will skip the selection screen and is sent directly to the
    /// chosen payment method. The parameter enables you to fully integrate
    /// the payment method selection into your website.
    ///
    ///You can also specify the methods in an array. By doing so we will still
    /// show the payment method selection screen but will only show the
    /// methods specified in the array. For example, you can use this
    /// functionality to only show payment methods from a specific country
    /// to your customer `['bancontact', 'belfius']`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Normally, a payment method screen is shown. However,
    /// when using this parameter, you can choose a specific payment\nmethod and
    /// your customer will skip the selection screen and is sent directly to the
    /// chosen payment method. The\nparameter enables you to fully integrate the
    /// payment method selection into your website.\n\nYou can also specify the
    /// methods in an array. By doing so we will still show the payment method
    /// selection screen\nbut will only show the methods specified in the array.
    /// For example, you can use this functionality to only show\npayment
    /// methods from a specific country to your customer `['bancontact',
    /// 'belfius']`.",
    ///  "examples": [
    ///    "ideal"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "alma",
    ///    "applepay",
    ///    "bacs",
    ///    "bancomatpay",
    ///    "bancontact",
    ///    "banktransfer",
    ///    "belfius",
    ///    "billie",
    ///    "bizum",
    ///    "blik",
    ///    "creditcard",
    ///    "directdebit",
    ///    "eps",
    ///    "giftcard",
    ///    "ideal",
    ///    "in3",
    ///    "kbc",
    ///    "klarna",
    ///    "klarnapaylater",
    ///    "klarnapaynow",
    ///    "klarnasliceit",
    ///    "mbway",
    ///    "mobilepay",
    ///    "multibanco",
    ///    "mybank",
    ///    "paybybank",
    ///    "payconiq",
    ///    "paypal",
    ///    "paysafecard",
    ///    "pointofsale",
    ///    "przelewy24",
    ///    "riverty",
    ///    "satispay",
    ///    "swish",
    ///    "trustly",
    ///    "twint",
    ///    "vipps",
    ///    "voucher"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct MethodResponse(pub ::std::option::Option<MethodResponseInner>);
    impl ::std::ops::Deref for MethodResponse {
        type Target = ::std::option::Option<MethodResponseInner>;
        fn deref(&self) -> &::std::option::Option<MethodResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<MethodResponse> for ::std::option::Option<MethodResponseInner> {
        fn from(value: MethodResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&MethodResponse> for MethodResponse {
        fn from(value: &MethodResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<MethodResponseInner>> for MethodResponse {
        fn from(value: ::std::option::Option<MethodResponseInner>) -> Self {
            Self(value)
        }
    }

    ///Normally, a payment method screen is shown. However, when using this
    /// parameter, you can choose a specific payment method and your
    /// customer will skip the selection screen and is sent directly to the
    /// chosen payment method. The parameter enables you to fully integrate
    /// the payment method selection into your website.
    ///
    ///You can also specify the methods in an array. By doing so we will still
    /// show the payment method selection screen but will only show the
    /// methods specified in the array. For example, you can use this
    /// functionality to only show payment methods from a specific country
    /// to your customer `['bancontact', 'belfius']`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Normally, a payment method screen is shown. However,
    /// when using this parameter, you can choose a specific payment\nmethod and
    /// your customer will skip the selection screen and is sent directly to the
    /// chosen payment method. The\nparameter enables you to fully integrate the
    /// payment method selection into your website.\n\nYou can also specify the
    /// methods in an array. By doing so we will still show the payment method
    /// selection screen\nbut will only show the methods specified in the array.
    /// For example, you can use this functionality to only show\npayment
    /// methods from a specific country to your customer `['bancontact',
    /// 'belfius']`.",
    ///  "examples": [
    ///    "ideal"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "alma",
    ///    "applepay",
    ///    "bacs",
    ///    "bancomatpay",
    ///    "bancontact",
    ///    "banktransfer",
    ///    "belfius",
    ///    "billie",
    ///    "bizum",
    ///    "blik",
    ///    "creditcard",
    ///    "directdebit",
    ///    "eps",
    ///    "giftcard",
    ///    "ideal",
    ///    "in3",
    ///    "kbc",
    ///    "klarna",
    ///    "klarnapaylater",
    ///    "klarnapaynow",
    ///    "klarnasliceit",
    ///    "mbway",
    ///    "mobilepay",
    ///    "multibanco",
    ///    "mybank",
    ///    "paybybank",
    ///    "payconiq",
    ///    "paypal",
    ///    "paysafecard",
    ///    "pointofsale",
    ///    "przelewy24",
    ///    "riverty",
    ///    "satispay",
    ///    "swish",
    ///    "trustly",
    ///    "twint",
    ///    "vipps",
    ///    "voucher"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MethodResponseInner {
        #[serde(rename = "alma")]
        Alma,
        #[serde(rename = "applepay")]
        Applepay,
        #[serde(rename = "bacs")]
        Bacs,
        #[serde(rename = "bancomatpay")]
        Bancomatpay,
        #[serde(rename = "bancontact")]
        Bancontact,
        #[serde(rename = "banktransfer")]
        Banktransfer,
        #[serde(rename = "belfius")]
        Belfius,
        #[serde(rename = "billie")]
        Billie,
        #[serde(rename = "bizum")]
        Bizum,
        #[serde(rename = "blik")]
        Blik,
        #[serde(rename = "creditcard")]
        Creditcard,
        #[serde(rename = "directdebit")]
        Directdebit,
        #[serde(rename = "eps")]
        Eps,
        #[serde(rename = "giftcard")]
        Giftcard,
        #[serde(rename = "ideal")]
        Ideal,
        #[serde(rename = "in3")]
        In3,
        #[serde(rename = "kbc")]
        Kbc,
        #[serde(rename = "klarna")]
        Klarna,
        #[serde(rename = "klarnapaylater")]
        Klarnapaylater,
        #[serde(rename = "klarnapaynow")]
        Klarnapaynow,
        #[serde(rename = "klarnasliceit")]
        Klarnasliceit,
        #[serde(rename = "mbway")]
        Mbway,
        #[serde(rename = "mobilepay")]
        Mobilepay,
        #[serde(rename = "multibanco")]
        Multibanco,
        #[serde(rename = "mybank")]
        Mybank,
        #[serde(rename = "paybybank")]
        Paybybank,
        #[serde(rename = "payconiq")]
        Payconiq,
        #[serde(rename = "paypal")]
        Paypal,
        #[serde(rename = "paysafecard")]
        Paysafecard,
        #[serde(rename = "pointofsale")]
        Pointofsale,
        #[serde(rename = "przelewy24")]
        Przelewy24,
        #[serde(rename = "riverty")]
        Riverty,
        #[serde(rename = "satispay")]
        Satispay,
        #[serde(rename = "swish")]
        Swish,
        #[serde(rename = "trustly")]
        Trustly,
        #[serde(rename = "twint")]
        Twint,
        #[serde(rename = "vipps")]
        Vipps,
        #[serde(rename = "voucher")]
        Voucher,
    }

    impl ::std::convert::From<&Self> for MethodResponseInner {
        fn from(value: &MethodResponseInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for MethodResponseInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Alma => f.write_str("alma"),
                Self::Applepay => f.write_str("applepay"),
                Self::Bacs => f.write_str("bacs"),
                Self::Bancomatpay => f.write_str("bancomatpay"),
                Self::Bancontact => f.write_str("bancontact"),
                Self::Banktransfer => f.write_str("banktransfer"),
                Self::Belfius => f.write_str("belfius"),
                Self::Billie => f.write_str("billie"),
                Self::Bizum => f.write_str("bizum"),
                Self::Blik => f.write_str("blik"),
                Self::Creditcard => f.write_str("creditcard"),
                Self::Directdebit => f.write_str("directdebit"),
                Self::Eps => f.write_str("eps"),
                Self::Giftcard => f.write_str("giftcard"),
                Self::Ideal => f.write_str("ideal"),
                Self::In3 => f.write_str("in3"),
                Self::Kbc => f.write_str("kbc"),
                Self::Klarna => f.write_str("klarna"),
                Self::Klarnapaylater => f.write_str("klarnapaylater"),
                Self::Klarnapaynow => f.write_str("klarnapaynow"),
                Self::Klarnasliceit => f.write_str("klarnasliceit"),
                Self::Mbway => f.write_str("mbway"),
                Self::Mobilepay => f.write_str("mobilepay"),
                Self::Multibanco => f.write_str("multibanco"),
                Self::Mybank => f.write_str("mybank"),
                Self::Paybybank => f.write_str("paybybank"),
                Self::Payconiq => f.write_str("payconiq"),
                Self::Paypal => f.write_str("paypal"),
                Self::Paysafecard => f.write_str("paysafecard"),
                Self::Pointofsale => f.write_str("pointofsale"),
                Self::Przelewy24 => f.write_str("przelewy24"),
                Self::Riverty => f.write_str("riverty"),
                Self::Satispay => f.write_str("satispay"),
                Self::Swish => f.write_str("swish"),
                Self::Trustly => f.write_str("trustly"),
                Self::Twint => f.write_str("twint"),
                Self::Vipps => f.write_str("vipps"),
                Self::Voucher => f.write_str("voucher"),
            }
        }
    }

    impl ::std::str::FromStr for MethodResponseInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "alma" => Ok(Self::Alma),
                "applepay" => Ok(Self::Applepay),
                "bacs" => Ok(Self::Bacs),
                "bancomatpay" => Ok(Self::Bancomatpay),
                "bancontact" => Ok(Self::Bancontact),
                "banktransfer" => Ok(Self::Banktransfer),
                "belfius" => Ok(Self::Belfius),
                "billie" => Ok(Self::Billie),
                "bizum" => Ok(Self::Bizum),
                "blik" => Ok(Self::Blik),
                "creditcard" => Ok(Self::Creditcard),
                "directdebit" => Ok(Self::Directdebit),
                "eps" => Ok(Self::Eps),
                "giftcard" => Ok(Self::Giftcard),
                "ideal" => Ok(Self::Ideal),
                "in3" => Ok(Self::In3),
                "kbc" => Ok(Self::Kbc),
                "klarna" => Ok(Self::Klarna),
                "klarnapaylater" => Ok(Self::Klarnapaylater),
                "klarnapaynow" => Ok(Self::Klarnapaynow),
                "klarnasliceit" => Ok(Self::Klarnasliceit),
                "mbway" => Ok(Self::Mbway),
                "mobilepay" => Ok(Self::Mobilepay),
                "multibanco" => Ok(Self::Multibanco),
                "mybank" => Ok(Self::Mybank),
                "paybybank" => Ok(Self::Paybybank),
                "payconiq" => Ok(Self::Payconiq),
                "paypal" => Ok(Self::Paypal),
                "paysafecard" => Ok(Self::Paysafecard),
                "pointofsale" => Ok(Self::Pointofsale),
                "przelewy24" => Ok(Self::Przelewy24),
                "riverty" => Ok(Self::Riverty),
                "satispay" => Ok(Self::Satispay),
                "swish" => Ok(Self::Swish),
                "trustly" => Ok(Self::Trustly),
                "twint" => Ok(Self::Twint),
                "vipps" => Ok(Self::Vipps),
                "voucher" => Ok(Self::Voucher),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for MethodResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for MethodResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for MethodResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The payment method's activation status for this profile.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The payment method's activation status for this
    /// profile.",
    ///  "examples": [
    ///    "activated"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "activated",
    ///    "pending-boarding",
    ///    "pending-review",
    ///    "pending-external",
    ///    "rejected"
    ///  ],
    ///  "x-enumDescriptions": {
    ///    "activated": "The payment method is activated and ready for use.",
    ///    "pending-boarding": "Mollie is waiting for you to finish onboarding in the Merchant Dashboard before the payment method can be activated.",
    ///    "pending-external": "Activation of this payment method relies on you
    /// taking action with an external party, for example signing up with PayPal
    /// or a giftcard issuer.",
    ///    "pending-review": "Mollie needs to review your request for this
    /// payment method before it can be activated.",
    ///    "rejected": "Your request for this payment method was rejected.
    /// Whenever Mollie rejects such a request, you will always be informed via
    /// email."
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MethodStatus {
        #[serde(rename = "activated")]
        Activated,
        #[serde(rename = "pending-boarding")]
        PendingBoarding,
        #[serde(rename = "pending-review")]
        PendingReview,
        #[serde(rename = "pending-external")]
        PendingExternal,
        #[serde(rename = "rejected")]
        Rejected,
    }

    impl ::std::convert::From<&Self> for MethodStatus {
        fn from(value: &MethodStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for MethodStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Activated => f.write_str("activated"),
                Self::PendingBoarding => f.write_str("pending-boarding"),
                Self::PendingReview => f.write_str("pending-review"),
                Self::PendingExternal => f.write_str("pending-external"),
                Self::Rejected => f.write_str("rejected"),
            }
        }
    }

    impl ::std::str::FromStr for MethodStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "activated" => Ok(Self::Activated),
                "pending-boarding" => Ok(Self::PendingBoarding),
                "pending-review" => Ok(Self::PendingReview),
                "pending-external" => Ok(Self::PendingExternal),
                "rejected" => Ok(Self::Rejected),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for MethodStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for MethodStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for MethodStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Whether this entity was created in live mode or in test mode.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Whether this entity was created in live mode or in test
    /// mode.",
    ///  "readOnly": true,
    ///  "examples": [
    ///    "live"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "live",
    ///    "test"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum Mode {
        #[serde(rename = "live")]
        Live,
        #[serde(rename = "test")]
        Test,
    }

    impl ::std::convert::From<&Self> for Mode {
        fn from(value: &Mode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for Mode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Live => f.write_str("live"),
                Self::Test => f.write_str("test"),
            }
        }
    }

    impl ::std::str::FromStr for Mode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "live" => Ok(Self::Live),
                "test" => Ok(Self::Test),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for Mode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for Mode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for Mode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The current status of the organization's onboarding process.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The current status of the organization's onboarding
    /// process.",
    ///  "type": "string",
    ///  "enum": [
    ///    "needs-data",
    ///    "in-review",
    ///    "completed"
    ///  ],
    ///  "x-enumDescriptions": {
    ///    "completed": "The onboarding is completed",
    ///    "in-review": "The merchant provided all information, awaiting review
    /// from Mollie",
    ///    "needs-data": "The merchant needs to provide additional information"
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OnboardingStatus {
        #[serde(rename = "needs-data")]
        NeedsData,
        #[serde(rename = "in-review")]
        InReview,
        #[serde(rename = "completed")]
        Completed,
    }

    impl ::std::convert::From<&Self> for OnboardingStatus {
        fn from(value: &OnboardingStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OnboardingStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NeedsData => f.write_str("needs-data"),
                Self::InReview => f.write_str("in-review"),
                Self::Completed => f.write_str("completed"),
            }
        }
    }

    impl ::std::str::FromStr for OnboardingStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "needs-data" => Ok(Self::NeedsData),
                "in-review" => Ok(Self::InReview),
                "completed" => Ok(Self::Completed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for OnboardingStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for OnboardingStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for OnboardingStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`OrderToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "ord_5B8cwPMGnU"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct OrderToken(pub ::std::string::String);
    impl ::std::ops::Deref for OrderToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<OrderToken> for ::std::string::String {
        fn from(value: OrderToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&OrderToken> for OrderToken {
        fn from(value: &OrderToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for OrderToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for OrderToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for OrderToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`OrganizationToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "org_1234567"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct OrganizationToken(pub ::std::string::String);
    impl ::std::ops::Deref for OrganizationToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<OrganizationToken> for ::std::string::String {
        fn from(value: OrganizationToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&OrganizationToken> for OrganizationToken {
        fn from(value: &OrganizationToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for OrganizationToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for OrganizationToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for OrganizationToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///Mollie applies Dutch VAT for merchants based in The Netherlands, British
    /// VAT for merchants based in The United Kingdom, and shifted VAT for
    /// merchants in the European Union.
    ///
    ///The field is not present for merchants residing in other countries.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Mollie applies Dutch VAT for merchants based in The
    /// Netherlands, British VAT for merchants based in The United\nKingdom, and
    /// shifted VAT for merchants in the European Union.\n\nThe field is not
    /// present for merchants residing in other countries.",
    ///  "examples": [
    ///    "dutch"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "dutch",
    ///    "british",
    ///    "shifted"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct OrganizationVatRegulation(pub ::std::option::Option<OrganizationVatRegulationInner>);
    impl ::std::ops::Deref for OrganizationVatRegulation {
        type Target = ::std::option::Option<OrganizationVatRegulationInner>;
        fn deref(&self) -> &::std::option::Option<OrganizationVatRegulationInner> {
            &self.0
        }
    }

    impl ::std::convert::From<OrganizationVatRegulation>
        for ::std::option::Option<OrganizationVatRegulationInner>
    {
        fn from(value: OrganizationVatRegulation) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&OrganizationVatRegulation> for OrganizationVatRegulation {
        fn from(value: &OrganizationVatRegulation) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<OrganizationVatRegulationInner>>
        for OrganizationVatRegulation
    {
        fn from(value: ::std::option::Option<OrganizationVatRegulationInner>) -> Self {
            Self(value)
        }
    }

    ///Mollie applies Dutch VAT for merchants based in The Netherlands, British
    /// VAT for merchants based in The United Kingdom, and shifted VAT for
    /// merchants in the European Union.
    ///
    ///The field is not present for merchants residing in other countries.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Mollie applies Dutch VAT for merchants based in The
    /// Netherlands, British VAT for merchants based in The United\nKingdom, and
    /// shifted VAT for merchants in the European Union.\n\nThe field is not
    /// present for merchants residing in other countries.",
    ///  "examples": [
    ///    "dutch"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "dutch",
    ///    "british",
    ///    "shifted"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OrganizationVatRegulationInner {
        #[serde(rename = "dutch")]
        Dutch,
        #[serde(rename = "british")]
        British,
        #[serde(rename = "shifted")]
        Shifted,
    }

    impl ::std::convert::From<&Self> for OrganizationVatRegulationInner {
        fn from(value: &OrganizationVatRegulationInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OrganizationVatRegulationInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Dutch => f.write_str("dutch"),
                Self::British => f.write_str("british"),
                Self::Shifted => f.write_str("shifted"),
            }
        }
    }

    impl ::std::str::FromStr for OrganizationVatRegulationInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "dutch" => Ok(Self::Dutch),
                "british" => Ok(Self::British),
                "shifted" => Ok(Self::Shifted),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for OrganizationVatRegulationInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for OrganizationVatRegulationInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for OrganizationVatRegulationInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PaymentAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "city": {
    ///      "description": "A city name.\n\nRequired for payment methods
    /// `billie`, `in3`, `klarna` and `riverty`.",
    ///      "examples": [
    ///        "Amsterdam"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "country": {
    ///      "description": "A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.\n\nRequired for payment methods `billie`, `in3`, `klarna` and `riverty`.",
    ///      "examples": [
    ///        "NL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "email": {
    ///      "description": "A valid e-mail address.\n\nIf you provide the email
    /// address for a `banktransfer` payment, we will automatically send the
    /// instructions\nemail upon payment creation. The language of the email
    /// will follow the locale parameter of the payment.\n\nRequired for payment
    /// methods `billie`, `in3`, `klarna` and `riverty`.",
    ///      "examples": [
    ///        "piet@example.org"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "familyName": {
    ///      "description": "The given family name (surname) of the person
    /// should be at least two characters and cannot contain
    /// only\nnumbers.\n\nRequired for payment methods `billie`, `in3`, `klarna`
    /// and `riverty`.",
    ///      "examples": [
    ///        "Mondriaan"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "givenName": {
    ///      "description": "The given name (first name) of the person should be
    /// at least two characters and cannot contain only\nnumbers.\n\nRequired
    /// for payment methods `billie`, `in3`, `klarna` and `riverty`.",
    ///      "examples": [
    ///        "Piet"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "organizationName": {
    ///      "description": "The name of the organization, in case the addressee
    /// is an organization.",
    ///      "examples": [
    ///        "Mollie B.V."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "phone": {
    ///      "description": "If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.",
    ///      "examples": [
    ///        31208202070
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "postalCode": {
    ///      "description": "A postal code. This field may be required if the
    /// provided country has a postal code system.\n\nRequired for payment
    /// methods `billie`, `in3`, `klarna` and `riverty`.",
    ///      "examples": [
    ///        "1234AB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "region": {
    ///      "description": "The top-level administrative subdivision of the
    /// country. For example: Noord-Holland.",
    ///      "examples": [
    ///        "Noord-Holland"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "streetAdditional": {
    ///      "description": "Any additional addressing details, for example an
    /// apartment number.",
    ///      "examples": [
    ///        "Apt. 1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "streetAndNumber": {
    ///      "description": "A street and street number.\n\nRequired for payment
    /// methods `billie`, `in3`, `klarna` and `riverty`.",
    ///      "examples": [
    ///        "Keizersgracht 126"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "title": {
    ///      "description": "The title of the person, for example *Mr.* or
    /// *Mrs.*.",
    ///      "examples": [
    ///        "Mr."
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentAddress {
        ///A city name.
        ///
        ///Required for payment methods `billie`, `in3`, `klarna` and
        /// `riverty`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub city: ::std::option::Option<::std::string::String>,
        ///A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
        ///
        ///Required for payment methods `billie`, `in3`, `klarna` and
        /// `riverty`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub country: ::std::option::Option<::std::string::String>,
        ///A valid e-mail address.
        ///
        ///If you provide the email address for a `banktransfer` payment, we
        /// will automatically send the instructions email upon payment
        /// creation. The language of the email will follow the locale parameter
        /// of the payment.
        ///
        ///Required for payment methods `billie`, `in3`, `klarna` and
        /// `riverty`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        ///The given family name (surname) of the person should be at least two
        /// characters and cannot contain only numbers.
        ///
        ///Required for payment methods `billie`, `in3`, `klarna` and
        /// `riverty`.
        #[serde(
            rename = "familyName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub family_name: ::std::option::Option<::std::string::String>,
        ///The given name (first name) of the person should be at least two
        /// characters and cannot contain only numbers.
        ///
        ///Required for payment methods `billie`, `in3`, `klarna` and
        /// `riverty`.
        #[serde(
            rename = "givenName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub given_name: ::std::option::Option<::std::string::String>,
        ///The name of the organization, in case the addressee is an
        /// organization.
        #[serde(
            rename = "organizationName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub organization_name: ::std::option::Option<::std::string::String>,
        ///If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub phone: ::std::option::Option<::std::string::String>,
        ///A postal code. This field may be required if the provided country
        /// has a postal code system.
        ///
        ///Required for payment methods `billie`, `in3`, `klarna` and
        /// `riverty`.
        #[serde(
            rename = "postalCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub postal_code: ::std::option::Option<::std::string::String>,
        ///The top-level administrative subdivision of the country. For
        /// example: Noord-Holland.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub region: ::std::option::Option<::std::string::String>,
        ///Any additional addressing details, for example an apartment number.
        #[serde(
            rename = "streetAdditional",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub street_additional: ::std::option::Option<::std::string::String>,
        ///A street and street number.
        ///
        ///Required for payment methods `billie`, `in3`, `klarna` and
        /// `riverty`.
        #[serde(
            rename = "streetAndNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub street_and_number: ::std::option::Option<::std::string::String>,
        ///The title of the person, for example *Mr.* or *Mrs.*.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub title: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PaymentAddress> for PaymentAddress {
        fn from(value: &PaymentAddress) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PaymentAddress {
        fn default() -> Self {
            Self {
                city: Default::default(),
                country: Default::default(),
                email: Default::default(),
                family_name: Default::default(),
                given_name: Default::default(),
                organization_name: Default::default(),
                phone: Default::default(),
                postal_code: Default::default(),
                region: Default::default(),
                street_additional: Default::default(),
                street_and_number: Default::default(),
                title: Default::default(),
            }
        }
    }

    ///The card's target audience, if known.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The card's target audience, if known.",
    ///  "examples": [
    ///    "consumer"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "consumer",
    ///    "business"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsCardAudition(
        pub ::std::option::Option<PaymentDetailsCardAuditionInner>,
    );
    impl ::std::ops::Deref for PaymentDetailsCardAudition {
        type Target = ::std::option::Option<PaymentDetailsCardAuditionInner>;
        fn deref(&self) -> &::std::option::Option<PaymentDetailsCardAuditionInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsCardAudition>
        for ::std::option::Option<PaymentDetailsCardAuditionInner>
    {
        fn from(value: PaymentDetailsCardAudition) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsCardAudition> for PaymentDetailsCardAudition {
        fn from(value: &PaymentDetailsCardAudition) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentDetailsCardAuditionInner>>
        for PaymentDetailsCardAudition
    {
        fn from(value: ::std::option::Option<PaymentDetailsCardAuditionInner>) -> Self {
            Self(value)
        }
    }

    ///The card's target audience, if known.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The card's target audience, if known.",
    ///  "examples": [
    ///    "consumer"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "consumer",
    ///    "business"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsCardAuditionInner {
        #[serde(rename = "consumer")]
        Consumer,
        #[serde(rename = "business")]
        Business,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsCardAuditionInner {
        fn from(value: &PaymentDetailsCardAuditionInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsCardAuditionInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Consumer => f.write_str("consumer"),
                Self::Business => f.write_str("business"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsCardAuditionInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "consumer" => Ok(Self::Consumer),
                "business" => Ok(Self::Business),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsCardAuditionInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentDetailsCardAuditionInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentDetailsCardAuditionInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The card's target audience, if known.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The card's target audience, if known.",
    ///  "examples": [
    ///    "consumer"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "consumer",
    ///    "business"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsCardAuditionResponse(
        pub ::std::option::Option<PaymentDetailsCardAuditionResponseInner>,
    );
    impl ::std::ops::Deref for PaymentDetailsCardAuditionResponse {
        type Target = ::std::option::Option<PaymentDetailsCardAuditionResponseInner>;
        fn deref(&self) -> &::std::option::Option<PaymentDetailsCardAuditionResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsCardAuditionResponse>
        for ::std::option::Option<PaymentDetailsCardAuditionResponseInner>
    {
        fn from(value: PaymentDetailsCardAuditionResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsCardAuditionResponse>
        for PaymentDetailsCardAuditionResponse
    {
        fn from(value: &PaymentDetailsCardAuditionResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentDetailsCardAuditionResponseInner>>
        for PaymentDetailsCardAuditionResponse
    {
        fn from(value: ::std::option::Option<PaymentDetailsCardAuditionResponseInner>) -> Self {
            Self(value)
        }
    }

    ///The card's target audience, if known.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The card's target audience, if known.",
    ///  "examples": [
    ///    "consumer"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "consumer",
    ///    "business"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsCardAuditionResponseInner {
        #[serde(rename = "consumer")]
        Consumer,
        #[serde(rename = "business")]
        Business,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsCardAuditionResponseInner {
        fn from(value: &PaymentDetailsCardAuditionResponseInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsCardAuditionResponseInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Consumer => f.write_str("consumer"),
                Self::Business => f.write_str("business"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsCardAuditionResponseInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "consumer" => Ok(Self::Consumer),
                "business" => Ok(Self::Business),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsCardAuditionResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentDetailsCardAuditionResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentDetailsCardAuditionResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The card type.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The card type.",
    ///  "examples": [
    ///    "credit"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "debit",
    ///    "credit",
    ///    "prepaid",
    ///    "deferred-debit"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsCardFunding(pub ::std::option::Option<PaymentDetailsCardFundingInner>);
    impl ::std::ops::Deref for PaymentDetailsCardFunding {
        type Target = ::std::option::Option<PaymentDetailsCardFundingInner>;
        fn deref(&self) -> &::std::option::Option<PaymentDetailsCardFundingInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsCardFunding>
        for ::std::option::Option<PaymentDetailsCardFundingInner>
    {
        fn from(value: PaymentDetailsCardFunding) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsCardFunding> for PaymentDetailsCardFunding {
        fn from(value: &PaymentDetailsCardFunding) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentDetailsCardFundingInner>>
        for PaymentDetailsCardFunding
    {
        fn from(value: ::std::option::Option<PaymentDetailsCardFundingInner>) -> Self {
            Self(value)
        }
    }

    ///The card type.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The card type.",
    ///  "examples": [
    ///    "credit"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "debit",
    ///    "credit",
    ///    "prepaid",
    ///    "deferred-debit"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsCardFundingInner {
        #[serde(rename = "debit")]
        Debit,
        #[serde(rename = "credit")]
        Credit,
        #[serde(rename = "prepaid")]
        Prepaid,
        #[serde(rename = "deferred-debit")]
        DeferredDebit,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsCardFundingInner {
        fn from(value: &PaymentDetailsCardFundingInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsCardFundingInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Debit => f.write_str("debit"),
                Self::Credit => f.write_str("credit"),
                Self::Prepaid => f.write_str("prepaid"),
                Self::DeferredDebit => f.write_str("deferred-debit"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsCardFundingInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "debit" => Ok(Self::Debit),
                "credit" => Ok(Self::Credit),
                "prepaid" => Ok(Self::Prepaid),
                "deferred-debit" => Ok(Self::DeferredDebit),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsCardFundingInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentDetailsCardFundingInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentDetailsCardFundingInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The card type.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The card type.",
    ///  "examples": [
    ///    "credit"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "debit",
    ///    "credit",
    ///    "prepaid",
    ///    "deferred-debit"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsCardFundingResponse(
        pub ::std::option::Option<PaymentDetailsCardFundingResponseInner>,
    );
    impl ::std::ops::Deref for PaymentDetailsCardFundingResponse {
        type Target = ::std::option::Option<PaymentDetailsCardFundingResponseInner>;
        fn deref(&self) -> &::std::option::Option<PaymentDetailsCardFundingResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsCardFundingResponse>
        for ::std::option::Option<PaymentDetailsCardFundingResponseInner>
    {
        fn from(value: PaymentDetailsCardFundingResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsCardFundingResponse>
        for PaymentDetailsCardFundingResponse
    {
        fn from(value: &PaymentDetailsCardFundingResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentDetailsCardFundingResponseInner>>
        for PaymentDetailsCardFundingResponse
    {
        fn from(value: ::std::option::Option<PaymentDetailsCardFundingResponseInner>) -> Self {
            Self(value)
        }
    }

    ///The card type.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The card type.",
    ///  "examples": [
    ///    "credit"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "debit",
    ///    "credit",
    ///    "prepaid",
    ///    "deferred-debit"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsCardFundingResponseInner {
        #[serde(rename = "debit")]
        Debit,
        #[serde(rename = "credit")]
        Credit,
        #[serde(rename = "prepaid")]
        Prepaid,
        #[serde(rename = "deferred-debit")]
        DeferredDebit,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsCardFundingResponseInner {
        fn from(value: &PaymentDetailsCardFundingResponseInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsCardFundingResponseInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Debit => f.write_str("debit"),
                Self::Credit => f.write_str("credit"),
                Self::Prepaid => f.write_str("prepaid"),
                Self::DeferredDebit => f.write_str("deferred-debit"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsCardFundingResponseInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "debit" => Ok(Self::Debit),
                "credit" => Ok(Self::Credit),
                "prepaid" => Ok(Self::Prepaid),
                "deferred-debit" => Ok(Self::DeferredDebit),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsCardFundingResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentDetailsCardFundingResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentDetailsCardFundingResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The card's label, if known.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The card's label, if known.",
    ///  "examples": [
    ///    "Mastercard"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "American Express",
    ///    "Carta Si",
    ///    "Carte Bleue",
    ///    "Dankort",
    ///    "Diners Club",
    ///    "Discover",
    ///    "JCB",
    ///    "Laser",
    ///    "Maestro",
    ///    "Mastercard",
    ///    "Unionpay",
    ///    "Visa",
    ///    "Vpay"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsCardLabel(pub ::std::option::Option<PaymentDetailsCardLabelInner>);
    impl ::std::ops::Deref for PaymentDetailsCardLabel {
        type Target = ::std::option::Option<PaymentDetailsCardLabelInner>;
        fn deref(&self) -> &::std::option::Option<PaymentDetailsCardLabelInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsCardLabel>
        for ::std::option::Option<PaymentDetailsCardLabelInner>
    {
        fn from(value: PaymentDetailsCardLabel) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsCardLabel> for PaymentDetailsCardLabel {
        fn from(value: &PaymentDetailsCardLabel) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentDetailsCardLabelInner>>
        for PaymentDetailsCardLabel
    {
        fn from(value: ::std::option::Option<PaymentDetailsCardLabelInner>) -> Self {
            Self(value)
        }
    }

    ///The card's label, if known.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The card's label, if known.",
    ///  "examples": [
    ///    "Mastercard"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "American Express",
    ///    "Carta Si",
    ///    "Carte Bleue",
    ///    "Dankort",
    ///    "Diners Club",
    ///    "Discover",
    ///    "JCB",
    ///    "Laser",
    ///    "Maestro",
    ///    "Mastercard",
    ///    "Unionpay",
    ///    "Visa",
    ///    "Vpay"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsCardLabelInner {
        #[serde(rename = "American Express")]
        AmericanExpress,
        #[serde(rename = "Carta Si")]
        CartaSi,
        #[serde(rename = "Carte Bleue")]
        CarteBleue,
        Dankort,
        #[serde(rename = "Diners Club")]
        DinersClub,
        Discover,
        #[serde(rename = "JCB")]
        Jcb,
        Laser,
        Maestro,
        Mastercard,
        Unionpay,
        Visa,
        Vpay,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsCardLabelInner {
        fn from(value: &PaymentDetailsCardLabelInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsCardLabelInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AmericanExpress => f.write_str("American Express"),
                Self::CartaSi => f.write_str("Carta Si"),
                Self::CarteBleue => f.write_str("Carte Bleue"),
                Self::Dankort => f.write_str("Dankort"),
                Self::DinersClub => f.write_str("Diners Club"),
                Self::Discover => f.write_str("Discover"),
                Self::Jcb => f.write_str("JCB"),
                Self::Laser => f.write_str("Laser"),
                Self::Maestro => f.write_str("Maestro"),
                Self::Mastercard => f.write_str("Mastercard"),
                Self::Unionpay => f.write_str("Unionpay"),
                Self::Visa => f.write_str("Visa"),
                Self::Vpay => f.write_str("Vpay"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsCardLabelInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "American Express" => Ok(Self::AmericanExpress),
                "Carta Si" => Ok(Self::CartaSi),
                "Carte Bleue" => Ok(Self::CarteBleue),
                "Dankort" => Ok(Self::Dankort),
                "Diners Club" => Ok(Self::DinersClub),
                "Discover" => Ok(Self::Discover),
                "JCB" => Ok(Self::Jcb),
                "Laser" => Ok(Self::Laser),
                "Maestro" => Ok(Self::Maestro),
                "Mastercard" => Ok(Self::Mastercard),
                "Unionpay" => Ok(Self::Unionpay),
                "Visa" => Ok(Self::Visa),
                "Vpay" => Ok(Self::Vpay),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsCardLabelInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentDetailsCardLabelInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentDetailsCardLabelInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The card's label, if known.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The card's label, if known.",
    ///  "examples": [
    ///    "Mastercard"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "American Express",
    ///    "Carta Si",
    ///    "Carte Bleue",
    ///    "Dankort",
    ///    "Diners Club",
    ///    "Discover",
    ///    "JCB",
    ///    "Laser",
    ///    "Maestro",
    ///    "Mastercard",
    ///    "Unionpay",
    ///    "Visa",
    ///    "Vpay"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsCardLabelResponse(
        pub ::std::option::Option<PaymentDetailsCardLabelResponseInner>,
    );
    impl ::std::ops::Deref for PaymentDetailsCardLabelResponse {
        type Target = ::std::option::Option<PaymentDetailsCardLabelResponseInner>;
        fn deref(&self) -> &::std::option::Option<PaymentDetailsCardLabelResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsCardLabelResponse>
        for ::std::option::Option<PaymentDetailsCardLabelResponseInner>
    {
        fn from(value: PaymentDetailsCardLabelResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsCardLabelResponse> for PaymentDetailsCardLabelResponse {
        fn from(value: &PaymentDetailsCardLabelResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentDetailsCardLabelResponseInner>>
        for PaymentDetailsCardLabelResponse
    {
        fn from(value: ::std::option::Option<PaymentDetailsCardLabelResponseInner>) -> Self {
            Self(value)
        }
    }

    ///The card's label, if known.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The card's label, if known.",
    ///  "examples": [
    ///    "Mastercard"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "American Express",
    ///    "Carta Si",
    ///    "Carte Bleue",
    ///    "Dankort",
    ///    "Diners Club",
    ///    "Discover",
    ///    "JCB",
    ///    "Laser",
    ///    "Maestro",
    ///    "Mastercard",
    ///    "Unionpay",
    ///    "Visa",
    ///    "Vpay"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsCardLabelResponseInner {
        #[serde(rename = "American Express")]
        AmericanExpress,
        #[serde(rename = "Carta Si")]
        CartaSi,
        #[serde(rename = "Carte Bleue")]
        CarteBleue,
        Dankort,
        #[serde(rename = "Diners Club")]
        DinersClub,
        Discover,
        #[serde(rename = "JCB")]
        Jcb,
        Laser,
        Maestro,
        Mastercard,
        Unionpay,
        Visa,
        Vpay,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsCardLabelResponseInner {
        fn from(value: &PaymentDetailsCardLabelResponseInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsCardLabelResponseInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AmericanExpress => f.write_str("American Express"),
                Self::CartaSi => f.write_str("Carta Si"),
                Self::CarteBleue => f.write_str("Carte Bleue"),
                Self::Dankort => f.write_str("Dankort"),
                Self::DinersClub => f.write_str("Diners Club"),
                Self::Discover => f.write_str("Discover"),
                Self::Jcb => f.write_str("JCB"),
                Self::Laser => f.write_str("Laser"),
                Self::Maestro => f.write_str("Maestro"),
                Self::Mastercard => f.write_str("Mastercard"),
                Self::Unionpay => f.write_str("Unionpay"),
                Self::Visa => f.write_str("Visa"),
                Self::Vpay => f.write_str("Vpay"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsCardLabelResponseInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "American Express" => Ok(Self::AmericanExpress),
                "Carta Si" => Ok(Self::CartaSi),
                "Carte Bleue" => Ok(Self::CarteBleue),
                "Dankort" => Ok(Self::Dankort),
                "Diners Club" => Ok(Self::DinersClub),
                "Discover" => Ok(Self::Discover),
                "JCB" => Ok(Self::Jcb),
                "Laser" => Ok(Self::Laser),
                "Maestro" => Ok(Self::Maestro),
                "Mastercard" => Ok(Self::Mastercard),
                "Unionpay" => Ok(Self::Unionpay),
                "Visa" => Ok(Self::Visa),
                "Vpay" => Ok(Self::Vpay),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsCardLabelResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentDetailsCardLabelResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentDetailsCardLabelResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The level of security applied during card processing.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The level of security applied during card processing.",
    ///  "examples": [
    ///    "normal"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "normal",
    ///    "3dsecure"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsCardSecurity(
        pub ::std::option::Option<PaymentDetailsCardSecurityInner>,
    );
    impl ::std::ops::Deref for PaymentDetailsCardSecurity {
        type Target = ::std::option::Option<PaymentDetailsCardSecurityInner>;
        fn deref(&self) -> &::std::option::Option<PaymentDetailsCardSecurityInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsCardSecurity>
        for ::std::option::Option<PaymentDetailsCardSecurityInner>
    {
        fn from(value: PaymentDetailsCardSecurity) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsCardSecurity> for PaymentDetailsCardSecurity {
        fn from(value: &PaymentDetailsCardSecurity) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentDetailsCardSecurityInner>>
        for PaymentDetailsCardSecurity
    {
        fn from(value: ::std::option::Option<PaymentDetailsCardSecurityInner>) -> Self {
            Self(value)
        }
    }

    ///The level of security applied during card processing.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The level of security applied during card processing.",
    ///  "examples": [
    ///    "normal"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "normal",
    ///    "3dsecure"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsCardSecurityInner {
        #[serde(rename = "normal")]
        Normal,
        #[serde(rename = "3dsecure")]
        X3dsecure,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsCardSecurityInner {
        fn from(value: &PaymentDetailsCardSecurityInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsCardSecurityInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Normal => f.write_str("normal"),
                Self::X3dsecure => f.write_str("3dsecure"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsCardSecurityInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "normal" => Ok(Self::Normal),
                "3dsecure" => Ok(Self::X3dsecure),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsCardSecurityInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentDetailsCardSecurityInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentDetailsCardSecurityInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The level of security applied during card processing.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The level of security applied during card processing.",
    ///  "examples": [
    ///    "normal"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "normal",
    ///    "3dsecure"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsCardSecurityResponse(
        pub ::std::option::Option<PaymentDetailsCardSecurityResponseInner>,
    );
    impl ::std::ops::Deref for PaymentDetailsCardSecurityResponse {
        type Target = ::std::option::Option<PaymentDetailsCardSecurityResponseInner>;
        fn deref(&self) -> &::std::option::Option<PaymentDetailsCardSecurityResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsCardSecurityResponse>
        for ::std::option::Option<PaymentDetailsCardSecurityResponseInner>
    {
        fn from(value: PaymentDetailsCardSecurityResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsCardSecurityResponse>
        for PaymentDetailsCardSecurityResponse
    {
        fn from(value: &PaymentDetailsCardSecurityResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentDetailsCardSecurityResponseInner>>
        for PaymentDetailsCardSecurityResponse
    {
        fn from(value: ::std::option::Option<PaymentDetailsCardSecurityResponseInner>) -> Self {
            Self(value)
        }
    }

    ///The level of security applied during card processing.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The level of security applied during card processing.",
    ///  "examples": [
    ///    "normal"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "normal",
    ///    "3dsecure"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsCardSecurityResponseInner {
        #[serde(rename = "normal")]
        Normal,
        #[serde(rename = "3dsecure")]
        X3dsecure,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsCardSecurityResponseInner {
        fn from(value: &PaymentDetailsCardSecurityResponseInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsCardSecurityResponseInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Normal => f.write_str("normal"),
                Self::X3dsecure => f.write_str("3dsecure"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsCardSecurityResponseInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "normal" => Ok(Self::Normal),
                "3dsecure" => Ok(Self::X3dsecure),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsCardSecurityResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentDetailsCardSecurityResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentDetailsCardSecurityResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A failure code to help understand why the payment failed.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A failure code to help understand why the payment
    /// failed.",
    ///  "examples": [
    ///    "card_declined"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "authentication_abandoned",
    ///    "authentication_failed",
    ///    "authentication_required",
    ///    "authentication_unavailable_acs",
    ///    "card_declined",
    ///    "card_expired",
    ///    "inactive_card",
    ///    "insufficient_funds",
    ///    "invalid_cvv",
    ///    "invalid_card_holder_name",
    ///    "invalid_card_number",
    ///    "invalid_card_type",
    ///    "possible_fraud",
    ///    "refused_by_issuer",
    ///    "unknown_reason"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsFailureReason(
        pub ::std::option::Option<PaymentDetailsFailureReasonInner>,
    );
    impl ::std::ops::Deref for PaymentDetailsFailureReason {
        type Target = ::std::option::Option<PaymentDetailsFailureReasonInner>;
        fn deref(&self) -> &::std::option::Option<PaymentDetailsFailureReasonInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsFailureReason>
        for ::std::option::Option<PaymentDetailsFailureReasonInner>
    {
        fn from(value: PaymentDetailsFailureReason) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsFailureReason> for PaymentDetailsFailureReason {
        fn from(value: &PaymentDetailsFailureReason) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentDetailsFailureReasonInner>>
        for PaymentDetailsFailureReason
    {
        fn from(value: ::std::option::Option<PaymentDetailsFailureReasonInner>) -> Self {
            Self(value)
        }
    }

    ///A failure code to help understand why the payment failed.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A failure code to help understand why the payment
    /// failed.",
    ///  "examples": [
    ///    "card_declined"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "authentication_abandoned",
    ///    "authentication_failed",
    ///    "authentication_required",
    ///    "authentication_unavailable_acs",
    ///    "card_declined",
    ///    "card_expired",
    ///    "inactive_card",
    ///    "insufficient_funds",
    ///    "invalid_cvv",
    ///    "invalid_card_holder_name",
    ///    "invalid_card_number",
    ///    "invalid_card_type",
    ///    "possible_fraud",
    ///    "refused_by_issuer",
    ///    "unknown_reason"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsFailureReasonInner {
        #[serde(rename = "authentication_abandoned")]
        AuthenticationAbandoned,
        #[serde(rename = "authentication_failed")]
        AuthenticationFailed,
        #[serde(rename = "authentication_required")]
        AuthenticationRequired,
        #[serde(rename = "authentication_unavailable_acs")]
        AuthenticationUnavailableAcs,
        #[serde(rename = "card_declined")]
        CardDeclined,
        #[serde(rename = "card_expired")]
        CardExpired,
        #[serde(rename = "inactive_card")]
        InactiveCard,
        #[serde(rename = "insufficient_funds")]
        InsufficientFunds,
        #[serde(rename = "invalid_cvv")]
        InvalidCvv,
        #[serde(rename = "invalid_card_holder_name")]
        InvalidCardHolderName,
        #[serde(rename = "invalid_card_number")]
        InvalidCardNumber,
        #[serde(rename = "invalid_card_type")]
        InvalidCardType,
        #[serde(rename = "possible_fraud")]
        PossibleFraud,
        #[serde(rename = "refused_by_issuer")]
        RefusedByIssuer,
        #[serde(rename = "unknown_reason")]
        UnknownReason,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsFailureReasonInner {
        fn from(value: &PaymentDetailsFailureReasonInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsFailureReasonInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AuthenticationAbandoned => f.write_str("authentication_abandoned"),
                Self::AuthenticationFailed => f.write_str("authentication_failed"),
                Self::AuthenticationRequired => f.write_str("authentication_required"),
                Self::AuthenticationUnavailableAcs => f.write_str("authentication_unavailable_acs"),
                Self::CardDeclined => f.write_str("card_declined"),
                Self::CardExpired => f.write_str("card_expired"),
                Self::InactiveCard => f.write_str("inactive_card"),
                Self::InsufficientFunds => f.write_str("insufficient_funds"),
                Self::InvalidCvv => f.write_str("invalid_cvv"),
                Self::InvalidCardHolderName => f.write_str("invalid_card_holder_name"),
                Self::InvalidCardNumber => f.write_str("invalid_card_number"),
                Self::InvalidCardType => f.write_str("invalid_card_type"),
                Self::PossibleFraud => f.write_str("possible_fraud"),
                Self::RefusedByIssuer => f.write_str("refused_by_issuer"),
                Self::UnknownReason => f.write_str("unknown_reason"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsFailureReasonInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "authentication_abandoned" => Ok(Self::AuthenticationAbandoned),
                "authentication_failed" => Ok(Self::AuthenticationFailed),
                "authentication_required" => Ok(Self::AuthenticationRequired),
                "authentication_unavailable_acs" => Ok(Self::AuthenticationUnavailableAcs),
                "card_declined" => Ok(Self::CardDeclined),
                "card_expired" => Ok(Self::CardExpired),
                "inactive_card" => Ok(Self::InactiveCard),
                "insufficient_funds" => Ok(Self::InsufficientFunds),
                "invalid_cvv" => Ok(Self::InvalidCvv),
                "invalid_card_holder_name" => Ok(Self::InvalidCardHolderName),
                "invalid_card_number" => Ok(Self::InvalidCardNumber),
                "invalid_card_type" => Ok(Self::InvalidCardType),
                "possible_fraud" => Ok(Self::PossibleFraud),
                "refused_by_issuer" => Ok(Self::RefusedByIssuer),
                "unknown_reason" => Ok(Self::UnknownReason),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsFailureReasonInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentDetailsFailureReasonInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentDetailsFailureReasonInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A failure code to help understand why the payment failed.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A failure code to help understand why the payment
    /// failed.",
    ///  "examples": [
    ///    "card_declined"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "authentication_abandoned",
    ///    "authentication_failed",
    ///    "authentication_required",
    ///    "authentication_unavailable_acs",
    ///    "card_declined",
    ///    "card_expired",
    ///    "inactive_card",
    ///    "insufficient_funds",
    ///    "invalid_cvv",
    ///    "invalid_card_holder_name",
    ///    "invalid_card_number",
    ///    "invalid_card_type",
    ///    "possible_fraud",
    ///    "refused_by_issuer",
    ///    "unknown_reason"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsFailureReasonResponse(
        pub ::std::option::Option<PaymentDetailsFailureReasonResponseInner>,
    );
    impl ::std::ops::Deref for PaymentDetailsFailureReasonResponse {
        type Target = ::std::option::Option<PaymentDetailsFailureReasonResponseInner>;
        fn deref(&self) -> &::std::option::Option<PaymentDetailsFailureReasonResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsFailureReasonResponse>
        for ::std::option::Option<PaymentDetailsFailureReasonResponseInner>
    {
        fn from(value: PaymentDetailsFailureReasonResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsFailureReasonResponse>
        for PaymentDetailsFailureReasonResponse
    {
        fn from(value: &PaymentDetailsFailureReasonResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentDetailsFailureReasonResponseInner>>
        for PaymentDetailsFailureReasonResponse
    {
        fn from(value: ::std::option::Option<PaymentDetailsFailureReasonResponseInner>) -> Self {
            Self(value)
        }
    }

    ///A failure code to help understand why the payment failed.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A failure code to help understand why the payment
    /// failed.",
    ///  "examples": [
    ///    "card_declined"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "authentication_abandoned",
    ///    "authentication_failed",
    ///    "authentication_required",
    ///    "authentication_unavailable_acs",
    ///    "card_declined",
    ///    "card_expired",
    ///    "inactive_card",
    ///    "insufficient_funds",
    ///    "invalid_cvv",
    ///    "invalid_card_holder_name",
    ///    "invalid_card_number",
    ///    "invalid_card_type",
    ///    "possible_fraud",
    ///    "refused_by_issuer",
    ///    "unknown_reason"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsFailureReasonResponseInner {
        #[serde(rename = "authentication_abandoned")]
        AuthenticationAbandoned,
        #[serde(rename = "authentication_failed")]
        AuthenticationFailed,
        #[serde(rename = "authentication_required")]
        AuthenticationRequired,
        #[serde(rename = "authentication_unavailable_acs")]
        AuthenticationUnavailableAcs,
        #[serde(rename = "card_declined")]
        CardDeclined,
        #[serde(rename = "card_expired")]
        CardExpired,
        #[serde(rename = "inactive_card")]
        InactiveCard,
        #[serde(rename = "insufficient_funds")]
        InsufficientFunds,
        #[serde(rename = "invalid_cvv")]
        InvalidCvv,
        #[serde(rename = "invalid_card_holder_name")]
        InvalidCardHolderName,
        #[serde(rename = "invalid_card_number")]
        InvalidCardNumber,
        #[serde(rename = "invalid_card_type")]
        InvalidCardType,
        #[serde(rename = "possible_fraud")]
        PossibleFraud,
        #[serde(rename = "refused_by_issuer")]
        RefusedByIssuer,
        #[serde(rename = "unknown_reason")]
        UnknownReason,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsFailureReasonResponseInner {
        fn from(value: &PaymentDetailsFailureReasonResponseInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsFailureReasonResponseInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AuthenticationAbandoned => f.write_str("authentication_abandoned"),
                Self::AuthenticationFailed => f.write_str("authentication_failed"),
                Self::AuthenticationRequired => f.write_str("authentication_required"),
                Self::AuthenticationUnavailableAcs => f.write_str("authentication_unavailable_acs"),
                Self::CardDeclined => f.write_str("card_declined"),
                Self::CardExpired => f.write_str("card_expired"),
                Self::InactiveCard => f.write_str("inactive_card"),
                Self::InsufficientFunds => f.write_str("insufficient_funds"),
                Self::InvalidCvv => f.write_str("invalid_cvv"),
                Self::InvalidCardHolderName => f.write_str("invalid_card_holder_name"),
                Self::InvalidCardNumber => f.write_str("invalid_card_number"),
                Self::InvalidCardType => f.write_str("invalid_card_type"),
                Self::PossibleFraud => f.write_str("possible_fraud"),
                Self::RefusedByIssuer => f.write_str("refused_by_issuer"),
                Self::UnknownReason => f.write_str("unknown_reason"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsFailureReasonResponseInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "authentication_abandoned" => Ok(Self::AuthenticationAbandoned),
                "authentication_failed" => Ok(Self::AuthenticationFailed),
                "authentication_required" => Ok(Self::AuthenticationRequired),
                "authentication_unavailable_acs" => Ok(Self::AuthenticationUnavailableAcs),
                "card_declined" => Ok(Self::CardDeclined),
                "card_expired" => Ok(Self::CardExpired),
                "inactive_card" => Ok(Self::InactiveCard),
                "insufficient_funds" => Ok(Self::InsufficientFunds),
                "invalid_cvv" => Ok(Self::InvalidCvv),
                "invalid_card_holder_name" => Ok(Self::InvalidCardHolderName),
                "invalid_card_number" => Ok(Self::InvalidCardNumber),
                "invalid_card_type" => Ok(Self::InvalidCardType),
                "possible_fraud" => Ok(Self::PossibleFraud),
                "refused_by_issuer" => Ok(Self::RefusedByIssuer),
                "unknown_reason" => Ok(Self::UnknownReason),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsFailureReasonResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentDetailsFailureReasonResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentDetailsFailureReasonResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The applicable card fee region.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The applicable card fee region.",
    ///  "examples": [
    ///    "maestro"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "american-express",
    ///    "amex-intra-eea",
    ///    "carte-bancaire",
    ///    "intra-eu",
    ///    "intra-eu-corporate",
    ///    "domestic",
    ///    "maestro",
    ///    "other",
    ///    "inter",
    ///    "intra_eea"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsFeeRegion(pub ::std::option::Option<PaymentDetailsFeeRegionInner>);
    impl ::std::ops::Deref for PaymentDetailsFeeRegion {
        type Target = ::std::option::Option<PaymentDetailsFeeRegionInner>;
        fn deref(&self) -> &::std::option::Option<PaymentDetailsFeeRegionInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsFeeRegion>
        for ::std::option::Option<PaymentDetailsFeeRegionInner>
    {
        fn from(value: PaymentDetailsFeeRegion) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsFeeRegion> for PaymentDetailsFeeRegion {
        fn from(value: &PaymentDetailsFeeRegion) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentDetailsFeeRegionInner>>
        for PaymentDetailsFeeRegion
    {
        fn from(value: ::std::option::Option<PaymentDetailsFeeRegionInner>) -> Self {
            Self(value)
        }
    }

    ///The applicable card fee region.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The applicable card fee region.",
    ///  "examples": [
    ///    "maestro"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "american-express",
    ///    "amex-intra-eea",
    ///    "carte-bancaire",
    ///    "intra-eu",
    ///    "intra-eu-corporate",
    ///    "domestic",
    ///    "maestro",
    ///    "other",
    ///    "inter",
    ///    "intra_eea"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsFeeRegionInner {
        #[serde(rename = "american-express")]
        AmericanExpress,
        #[serde(rename = "amex-intra-eea")]
        AmexIntraEea,
        #[serde(rename = "carte-bancaire")]
        CarteBancaire,
        #[serde(rename = "intra-eu")]
        IntraEu,
        #[serde(rename = "intra-eu-corporate")]
        IntraEuCorporate,
        #[serde(rename = "domestic")]
        Domestic,
        #[serde(rename = "maestro")]
        Maestro,
        #[serde(rename = "other")]
        Other,
        #[serde(rename = "inter")]
        Inter,
        #[serde(rename = "intra_eea")]
        IntraEea,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsFeeRegionInner {
        fn from(value: &PaymentDetailsFeeRegionInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsFeeRegionInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AmericanExpress => f.write_str("american-express"),
                Self::AmexIntraEea => f.write_str("amex-intra-eea"),
                Self::CarteBancaire => f.write_str("carte-bancaire"),
                Self::IntraEu => f.write_str("intra-eu"),
                Self::IntraEuCorporate => f.write_str("intra-eu-corporate"),
                Self::Domestic => f.write_str("domestic"),
                Self::Maestro => f.write_str("maestro"),
                Self::Other => f.write_str("other"),
                Self::Inter => f.write_str("inter"),
                Self::IntraEea => f.write_str("intra_eea"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsFeeRegionInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "american-express" => Ok(Self::AmericanExpress),
                "amex-intra-eea" => Ok(Self::AmexIntraEea),
                "carte-bancaire" => Ok(Self::CarteBancaire),
                "intra-eu" => Ok(Self::IntraEu),
                "intra-eu-corporate" => Ok(Self::IntraEuCorporate),
                "domestic" => Ok(Self::Domestic),
                "maestro" => Ok(Self::Maestro),
                "other" => Ok(Self::Other),
                "inter" => Ok(Self::Inter),
                "intra_eea" => Ok(Self::IntraEea),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsFeeRegionInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentDetailsFeeRegionInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentDetailsFeeRegionInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The applicable card fee region.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The applicable card fee region.",
    ///  "examples": [
    ///    "maestro"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "american-express",
    ///    "amex-intra-eea",
    ///    "carte-bancaire",
    ///    "intra-eu",
    ///    "intra-eu-corporate",
    ///    "domestic",
    ///    "maestro",
    ///    "other",
    ///    "inter",
    ///    "intra_eea"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsFeeRegionResponse(
        pub ::std::option::Option<PaymentDetailsFeeRegionResponseInner>,
    );
    impl ::std::ops::Deref for PaymentDetailsFeeRegionResponse {
        type Target = ::std::option::Option<PaymentDetailsFeeRegionResponseInner>;
        fn deref(&self) -> &::std::option::Option<PaymentDetailsFeeRegionResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsFeeRegionResponse>
        for ::std::option::Option<PaymentDetailsFeeRegionResponseInner>
    {
        fn from(value: PaymentDetailsFeeRegionResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsFeeRegionResponse> for PaymentDetailsFeeRegionResponse {
        fn from(value: &PaymentDetailsFeeRegionResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentDetailsFeeRegionResponseInner>>
        for PaymentDetailsFeeRegionResponse
    {
        fn from(value: ::std::option::Option<PaymentDetailsFeeRegionResponseInner>) -> Self {
            Self(value)
        }
    }

    ///The applicable card fee region.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The applicable card fee region.",
    ///  "examples": [
    ///    "maestro"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "american-express",
    ///    "amex-intra-eea",
    ///    "carte-bancaire",
    ///    "intra-eu",
    ///    "intra-eu-corporate",
    ///    "domestic",
    ///    "maestro",
    ///    "other",
    ///    "inter",
    ///    "intra_eea"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsFeeRegionResponseInner {
        #[serde(rename = "american-express")]
        AmericanExpress,
        #[serde(rename = "amex-intra-eea")]
        AmexIntraEea,
        #[serde(rename = "carte-bancaire")]
        CarteBancaire,
        #[serde(rename = "intra-eu")]
        IntraEu,
        #[serde(rename = "intra-eu-corporate")]
        IntraEuCorporate,
        #[serde(rename = "domestic")]
        Domestic,
        #[serde(rename = "maestro")]
        Maestro,
        #[serde(rename = "other")]
        Other,
        #[serde(rename = "inter")]
        Inter,
        #[serde(rename = "intra_eea")]
        IntraEea,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsFeeRegionResponseInner {
        fn from(value: &PaymentDetailsFeeRegionResponseInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsFeeRegionResponseInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AmericanExpress => f.write_str("american-express"),
                Self::AmexIntraEea => f.write_str("amex-intra-eea"),
                Self::CarteBancaire => f.write_str("carte-bancaire"),
                Self::IntraEu => f.write_str("intra-eu"),
                Self::IntraEuCorporate => f.write_str("intra-eu-corporate"),
                Self::Domestic => f.write_str("domestic"),
                Self::Maestro => f.write_str("maestro"),
                Self::Other => f.write_str("other"),
                Self::Inter => f.write_str("inter"),
                Self::IntraEea => f.write_str("intra_eea"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsFeeRegionResponseInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "american-express" => Ok(Self::AmericanExpress),
                "amex-intra-eea" => Ok(Self::AmexIntraEea),
                "carte-bancaire" => Ok(Self::CarteBancaire),
                "intra-eu" => Ok(Self::IntraEu),
                "intra-eu-corporate" => Ok(Self::IntraEuCorporate),
                "domestic" => Ok(Self::Domestic),
                "maestro" => Ok(Self::Maestro),
                "other" => Ok(Self::Other),
                "inter" => Ok(Self::Inter),
                "intra_eea" => Ok(Self::IntraEea),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsFeeRegionResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentDetailsFeeRegionResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentDetailsFeeRegionResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The method by which the card was read by the terminal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The method by which the card was read by the
    /// terminal.",
    ///  "examples": [
    ///    "contactless"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "chip",
    ///    "magnetic-stripe",
    ///    "near-field-communication",
    ///    "contactless",
    ///    "moto"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsReceiptCardReadMethod(
        pub ::std::option::Option<PaymentDetailsReceiptCardReadMethodInner>,
    );
    impl ::std::ops::Deref for PaymentDetailsReceiptCardReadMethod {
        type Target = ::std::option::Option<PaymentDetailsReceiptCardReadMethodInner>;
        fn deref(&self) -> &::std::option::Option<PaymentDetailsReceiptCardReadMethodInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsReceiptCardReadMethod>
        for ::std::option::Option<PaymentDetailsReceiptCardReadMethodInner>
    {
        fn from(value: PaymentDetailsReceiptCardReadMethod) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsReceiptCardReadMethod>
        for PaymentDetailsReceiptCardReadMethod
    {
        fn from(value: &PaymentDetailsReceiptCardReadMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentDetailsReceiptCardReadMethodInner>>
        for PaymentDetailsReceiptCardReadMethod
    {
        fn from(value: ::std::option::Option<PaymentDetailsReceiptCardReadMethodInner>) -> Self {
            Self(value)
        }
    }

    ///The method by which the card was read by the terminal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The method by which the card was read by the
    /// terminal.",
    ///  "examples": [
    ///    "contactless"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "chip",
    ///    "magnetic-stripe",
    ///    "near-field-communication",
    ///    "contactless",
    ///    "moto"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsReceiptCardReadMethodInner {
        #[serde(rename = "chip")]
        Chip,
        #[serde(rename = "magnetic-stripe")]
        MagneticStripe,
        #[serde(rename = "near-field-communication")]
        NearFieldCommunication,
        #[serde(rename = "contactless")]
        Contactless,
        #[serde(rename = "moto")]
        Moto,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsReceiptCardReadMethodInner {
        fn from(value: &PaymentDetailsReceiptCardReadMethodInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsReceiptCardReadMethodInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Chip => f.write_str("chip"),
                Self::MagneticStripe => f.write_str("magnetic-stripe"),
                Self::NearFieldCommunication => f.write_str("near-field-communication"),
                Self::Contactless => f.write_str("contactless"),
                Self::Moto => f.write_str("moto"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsReceiptCardReadMethodInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "chip" => Ok(Self::Chip),
                "magnetic-stripe" => Ok(Self::MagneticStripe),
                "near-field-communication" => Ok(Self::NearFieldCommunication),
                "contactless" => Ok(Self::Contactless),
                "moto" => Ok(Self::Moto),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsReceiptCardReadMethodInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentDetailsReceiptCardReadMethodInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentDetailsReceiptCardReadMethodInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The method by which the card was read by the terminal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The method by which the card was read by the
    /// terminal.",
    ///  "examples": [
    ///    "contactless"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "chip",
    ///    "magnetic-stripe",
    ///    "near-field-communication",
    ///    "contactless",
    ///    "moto"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsReceiptCardReadMethodResponse(
        pub ::std::option::Option<PaymentDetailsReceiptCardReadMethodResponseInner>,
    );
    impl ::std::ops::Deref for PaymentDetailsReceiptCardReadMethodResponse {
        type Target = ::std::option::Option<PaymentDetailsReceiptCardReadMethodResponseInner>;
        fn deref(
            &self,
        ) -> &::std::option::Option<PaymentDetailsReceiptCardReadMethodResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsReceiptCardReadMethodResponse>
        for ::std::option::Option<PaymentDetailsReceiptCardReadMethodResponseInner>
    {
        fn from(value: PaymentDetailsReceiptCardReadMethodResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsReceiptCardReadMethodResponse>
        for PaymentDetailsReceiptCardReadMethodResponse
    {
        fn from(value: &PaymentDetailsReceiptCardReadMethodResponse) -> Self {
            value.clone()
        }
    }

    impl
        ::std::convert::From<
            ::std::option::Option<PaymentDetailsReceiptCardReadMethodResponseInner>,
        > for PaymentDetailsReceiptCardReadMethodResponse
    {
        fn from(
            value: ::std::option::Option<PaymentDetailsReceiptCardReadMethodResponseInner>,
        ) -> Self {
            Self(value)
        }
    }

    ///The method by which the card was read by the terminal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The method by which the card was read by the
    /// terminal.",
    ///  "examples": [
    ///    "contactless"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "chip",
    ///    "magnetic-stripe",
    ///    "near-field-communication",
    ///    "contactless",
    ///    "moto"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsReceiptCardReadMethodResponseInner {
        #[serde(rename = "chip")]
        Chip,
        #[serde(rename = "magnetic-stripe")]
        MagneticStripe,
        #[serde(rename = "near-field-communication")]
        NearFieldCommunication,
        #[serde(rename = "contactless")]
        Contactless,
        #[serde(rename = "moto")]
        Moto,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsReceiptCardReadMethodResponseInner {
        fn from(value: &PaymentDetailsReceiptCardReadMethodResponseInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsReceiptCardReadMethodResponseInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Chip => f.write_str("chip"),
                Self::MagneticStripe => f.write_str("magnetic-stripe"),
                Self::NearFieldCommunication => f.write_str("near-field-communication"),
                Self::Contactless => f.write_str("contactless"),
                Self::Moto => f.write_str("moto"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsReceiptCardReadMethodResponseInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "chip" => Ok(Self::Chip),
                "magnetic-stripe" => Ok(Self::MagneticStripe),
                "near-field-communication" => Ok(Self::NearFieldCommunication),
                "contactless" => Ok(Self::Contactless),
                "moto" => Ok(Self::Moto),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsReceiptCardReadMethodResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for PaymentDetailsReceiptCardReadMethodResponseInner
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for PaymentDetailsReceiptCardReadMethodResponseInner
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The method used to verify the cardholder's identity.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The method used to verify the cardholder's identity.",
    ///  "examples": [
    ///    "no-cvm-required"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "no-cvm-required",
    ///    "online-pin",
    ///    "offline-pin",
    ///    "consumer-device",
    ///    "signature",
    ///    "signature-and-online-pin",
    ///    "online-pin-and-signature",
    ///    "none",
    ///    "failed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsReceiptCardVerificationMethod(
        pub ::std::option::Option<PaymentDetailsReceiptCardVerificationMethodInner>,
    );
    impl ::std::ops::Deref for PaymentDetailsReceiptCardVerificationMethod {
        type Target = ::std::option::Option<PaymentDetailsReceiptCardVerificationMethodInner>;
        fn deref(
            &self,
        ) -> &::std::option::Option<PaymentDetailsReceiptCardVerificationMethodInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsReceiptCardVerificationMethod>
        for ::std::option::Option<PaymentDetailsReceiptCardVerificationMethodInner>
    {
        fn from(value: PaymentDetailsReceiptCardVerificationMethod) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsReceiptCardVerificationMethod>
        for PaymentDetailsReceiptCardVerificationMethod
    {
        fn from(value: &PaymentDetailsReceiptCardVerificationMethod) -> Self {
            value.clone()
        }
    }

    impl
        ::std::convert::From<
            ::std::option::Option<PaymentDetailsReceiptCardVerificationMethodInner>,
        > for PaymentDetailsReceiptCardVerificationMethod
    {
        fn from(
            value: ::std::option::Option<PaymentDetailsReceiptCardVerificationMethodInner>,
        ) -> Self {
            Self(value)
        }
    }

    ///The method used to verify the cardholder's identity.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The method used to verify the cardholder's identity.",
    ///  "examples": [
    ///    "no-cvm-required"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "no-cvm-required",
    ///    "online-pin",
    ///    "offline-pin",
    ///    "consumer-device",
    ///    "signature",
    ///    "signature-and-online-pin",
    ///    "online-pin-and-signature",
    ///    "none",
    ///    "failed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsReceiptCardVerificationMethodInner {
        #[serde(rename = "no-cvm-required")]
        NoCvmRequired,
        #[serde(rename = "online-pin")]
        OnlinePin,
        #[serde(rename = "offline-pin")]
        OfflinePin,
        #[serde(rename = "consumer-device")]
        ConsumerDevice,
        #[serde(rename = "signature")]
        Signature,
        #[serde(rename = "signature-and-online-pin")]
        SignatureAndOnlinePin,
        #[serde(rename = "online-pin-and-signature")]
        OnlinePinAndSignature,
        #[serde(rename = "none")]
        None,
        #[serde(rename = "failed")]
        Failed,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsReceiptCardVerificationMethodInner {
        fn from(value: &PaymentDetailsReceiptCardVerificationMethodInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsReceiptCardVerificationMethodInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NoCvmRequired => f.write_str("no-cvm-required"),
                Self::OnlinePin => f.write_str("online-pin"),
                Self::OfflinePin => f.write_str("offline-pin"),
                Self::ConsumerDevice => f.write_str("consumer-device"),
                Self::Signature => f.write_str("signature"),
                Self::SignatureAndOnlinePin => f.write_str("signature-and-online-pin"),
                Self::OnlinePinAndSignature => f.write_str("online-pin-and-signature"),
                Self::None => f.write_str("none"),
                Self::Failed => f.write_str("failed"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsReceiptCardVerificationMethodInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "no-cvm-required" => Ok(Self::NoCvmRequired),
                "online-pin" => Ok(Self::OnlinePin),
                "offline-pin" => Ok(Self::OfflinePin),
                "consumer-device" => Ok(Self::ConsumerDevice),
                "signature" => Ok(Self::Signature),
                "signature-and-online-pin" => Ok(Self::SignatureAndOnlinePin),
                "online-pin-and-signature" => Ok(Self::OnlinePinAndSignature),
                "none" => Ok(Self::None),
                "failed" => Ok(Self::Failed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsReceiptCardVerificationMethodInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for PaymentDetailsReceiptCardVerificationMethodInner
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for PaymentDetailsReceiptCardVerificationMethodInner
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The method used to verify the cardholder's identity.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The method used to verify the cardholder's identity.",
    ///  "examples": [
    ///    "no-cvm-required"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "no-cvm-required",
    ///    "online-pin",
    ///    "offline-pin",
    ///    "consumer-device",
    ///    "signature",
    ///    "signature-and-online-pin",
    ///    "online-pin-and-signature",
    ///    "none",
    ///    "failed"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsReceiptCardVerificationMethodResponse(
        pub ::std::option::Option<PaymentDetailsReceiptCardVerificationMethodResponseInner>,
    );
    impl ::std::ops::Deref for PaymentDetailsReceiptCardVerificationMethodResponse {
        type Target =
            ::std::option::Option<PaymentDetailsReceiptCardVerificationMethodResponseInner>;
        fn deref(
            &self,
        ) -> &::std::option::Option<PaymentDetailsReceiptCardVerificationMethodResponseInner>
        {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsReceiptCardVerificationMethodResponse>
        for ::std::option::Option<PaymentDetailsReceiptCardVerificationMethodResponseInner>
    {
        fn from(value: PaymentDetailsReceiptCardVerificationMethodResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsReceiptCardVerificationMethodResponse>
        for PaymentDetailsReceiptCardVerificationMethodResponse
    {
        fn from(value: &PaymentDetailsReceiptCardVerificationMethodResponse) -> Self {
            value.clone()
        }
    }

    impl
        ::std::convert::From<
            ::std::option::Option<PaymentDetailsReceiptCardVerificationMethodResponseInner>,
        > for PaymentDetailsReceiptCardVerificationMethodResponse
    {
        fn from(
            value: ::std::option::Option<PaymentDetailsReceiptCardVerificationMethodResponseInner>,
        ) -> Self {
            Self(value)
        }
    }

    ///The method used to verify the cardholder's identity.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The method used to verify the cardholder's identity.",
    ///  "examples": [
    ///    "no-cvm-required"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "no-cvm-required",
    ///    "online-pin",
    ///    "offline-pin",
    ///    "consumer-device",
    ///    "signature",
    ///    "signature-and-online-pin",
    ///    "online-pin-and-signature",
    ///    "none",
    ///    "failed"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsReceiptCardVerificationMethodResponseInner {
        #[serde(rename = "no-cvm-required")]
        NoCvmRequired,
        #[serde(rename = "online-pin")]
        OnlinePin,
        #[serde(rename = "offline-pin")]
        OfflinePin,
        #[serde(rename = "consumer-device")]
        ConsumerDevice,
        #[serde(rename = "signature")]
        Signature,
        #[serde(rename = "signature-and-online-pin")]
        SignatureAndOnlinePin,
        #[serde(rename = "online-pin-and-signature")]
        OnlinePinAndSignature,
        #[serde(rename = "none")]
        None,
        #[serde(rename = "failed")]
        Failed,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsReceiptCardVerificationMethodResponseInner {
        fn from(value: &PaymentDetailsReceiptCardVerificationMethodResponseInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsReceiptCardVerificationMethodResponseInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NoCvmRequired => f.write_str("no-cvm-required"),
                Self::OnlinePin => f.write_str("online-pin"),
                Self::OfflinePin => f.write_str("offline-pin"),
                Self::ConsumerDevice => f.write_str("consumer-device"),
                Self::Signature => f.write_str("signature"),
                Self::SignatureAndOnlinePin => f.write_str("signature-and-online-pin"),
                Self::OnlinePinAndSignature => f.write_str("online-pin-and-signature"),
                Self::None => f.write_str("none"),
                Self::Failed => f.write_str("failed"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsReceiptCardVerificationMethodResponseInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "no-cvm-required" => Ok(Self::NoCvmRequired),
                "online-pin" => Ok(Self::OnlinePin),
                "offline-pin" => Ok(Self::OfflinePin),
                "consumer-device" => Ok(Self::ConsumerDevice),
                "signature" => Ok(Self::Signature),
                "signature-and-online-pin" => Ok(Self::SignatureAndOnlinePin),
                "online-pin-and-signature" => Ok(Self::OnlinePinAndSignature),
                "none" => Ok(Self::None),
                "failed" => Ok(Self::Failed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsReceiptCardVerificationMethodResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for PaymentDetailsReceiptCardVerificationMethodResponseInner
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for PaymentDetailsReceiptCardVerificationMethodResponseInner
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates to what extent the payment is eligible for PayPal's Seller
    /// Protection. Only available for PayPal payments, and if the
    /// information is made available by PayPal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates to what extent the payment is eligible for
    /// PayPal's Seller Protection. Only available for PayPal\npayments, and if
    /// the information is made available by PayPal.",
    ///  "examples": [
    ///    "Eligible"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "Eligible",
    ///    "Ineligible",
    ///    "Partially Eligible - INR Only",
    ///    "Partially Eligible - Unauth Only",
    ///    "Partially Eligible",
    ///    "None",
    ///    "Active",
    ///    "Fraud Control - Unauth Premium Eligible"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsSellerProtection(
        pub ::std::option::Option<PaymentDetailsSellerProtectionInner>,
    );
    impl ::std::ops::Deref for PaymentDetailsSellerProtection {
        type Target = ::std::option::Option<PaymentDetailsSellerProtectionInner>;
        fn deref(&self) -> &::std::option::Option<PaymentDetailsSellerProtectionInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsSellerProtection>
        for ::std::option::Option<PaymentDetailsSellerProtectionInner>
    {
        fn from(value: PaymentDetailsSellerProtection) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsSellerProtection> for PaymentDetailsSellerProtection {
        fn from(value: &PaymentDetailsSellerProtection) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentDetailsSellerProtectionInner>>
        for PaymentDetailsSellerProtection
    {
        fn from(value: ::std::option::Option<PaymentDetailsSellerProtectionInner>) -> Self {
            Self(value)
        }
    }

    ///Indicates to what extent the payment is eligible for PayPal's Seller
    /// Protection. Only available for PayPal payments, and if the
    /// information is made available by PayPal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates to what extent the payment is eligible for
    /// PayPal's Seller Protection. Only available for PayPal\npayments, and if
    /// the information is made available by PayPal.",
    ///  "examples": [
    ///    "Eligible"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "Eligible",
    ///    "Ineligible",
    ///    "Partially Eligible - INR Only",
    ///    "Partially Eligible - Unauth Only",
    ///    "Partially Eligible",
    ///    "None",
    ///    "Active",
    ///    "Fraud Control - Unauth Premium Eligible"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsSellerProtectionInner {
        Eligible,
        Ineligible,
        #[serde(rename = "Partially Eligible - INR Only")]
        PartiallyEligibleInrOnly,
        #[serde(rename = "Partially Eligible - Unauth Only")]
        PartiallyEligibleUnauthOnly,
        #[serde(rename = "Partially Eligible")]
        PartiallyEligible,
        None,
        Active,
        #[serde(rename = "Fraud Control - Unauth Premium Eligible")]
        FraudControlUnauthPremiumEligible,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsSellerProtectionInner {
        fn from(value: &PaymentDetailsSellerProtectionInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsSellerProtectionInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Eligible => f.write_str("Eligible"),
                Self::Ineligible => f.write_str("Ineligible"),
                Self::PartiallyEligibleInrOnly => f.write_str("Partially Eligible - INR Only"),
                Self::PartiallyEligibleUnauthOnly => {
                    f.write_str("Partially Eligible - Unauth Only")
                }
                Self::PartiallyEligible => f.write_str("Partially Eligible"),
                Self::None => f.write_str("None"),
                Self::Active => f.write_str("Active"),
                Self::FraudControlUnauthPremiumEligible => {
                    f.write_str("Fraud Control - Unauth Premium Eligible")
                }
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsSellerProtectionInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "Eligible" => Ok(Self::Eligible),
                "Ineligible" => Ok(Self::Ineligible),
                "Partially Eligible - INR Only" => Ok(Self::PartiallyEligibleInrOnly),
                "Partially Eligible - Unauth Only" => Ok(Self::PartiallyEligibleUnauthOnly),
                "Partially Eligible" => Ok(Self::PartiallyEligible),
                "None" => Ok(Self::None),
                "Active" => Ok(Self::Active),
                "Fraud Control - Unauth Premium Eligible" => {
                    Ok(Self::FraudControlUnauthPremiumEligible)
                }
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsSellerProtectionInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentDetailsSellerProtectionInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentDetailsSellerProtectionInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates to what extent the payment is eligible for PayPal's Seller
    /// Protection. Only available for PayPal payments, and if the
    /// information is made available by PayPal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates to what extent the payment is eligible for
    /// PayPal's Seller Protection. Only available for PayPal\npayments, and if
    /// the information is made available by PayPal.",
    ///  "examples": [
    ///    "Eligible"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "Eligible",
    ///    "Ineligible",
    ///    "Partially Eligible - INR Only",
    ///    "Partially Eligible - Unauth Only",
    ///    "Partially Eligible",
    ///    "None",
    ///    "Active",
    ///    "Fraud Control - Unauth Premium Eligible"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsSellerProtectionResponse(
        pub ::std::option::Option<PaymentDetailsSellerProtectionResponseInner>,
    );
    impl ::std::ops::Deref for PaymentDetailsSellerProtectionResponse {
        type Target = ::std::option::Option<PaymentDetailsSellerProtectionResponseInner>;
        fn deref(&self) -> &::std::option::Option<PaymentDetailsSellerProtectionResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsSellerProtectionResponse>
        for ::std::option::Option<PaymentDetailsSellerProtectionResponseInner>
    {
        fn from(value: PaymentDetailsSellerProtectionResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsSellerProtectionResponse>
        for PaymentDetailsSellerProtectionResponse
    {
        fn from(value: &PaymentDetailsSellerProtectionResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentDetailsSellerProtectionResponseInner>>
        for PaymentDetailsSellerProtectionResponse
    {
        fn from(value: ::std::option::Option<PaymentDetailsSellerProtectionResponseInner>) -> Self {
            Self(value)
        }
    }

    ///Indicates to what extent the payment is eligible for PayPal's Seller
    /// Protection. Only available for PayPal payments, and if the
    /// information is made available by PayPal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates to what extent the payment is eligible for
    /// PayPal's Seller Protection. Only available for PayPal\npayments, and if
    /// the information is made available by PayPal.",
    ///  "examples": [
    ///    "Eligible"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "Eligible",
    ///    "Ineligible",
    ///    "Partially Eligible - INR Only",
    ///    "Partially Eligible - Unauth Only",
    ///    "Partially Eligible",
    ///    "None",
    ///    "Active",
    ///    "Fraud Control - Unauth Premium Eligible"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsSellerProtectionResponseInner {
        Eligible,
        Ineligible,
        #[serde(rename = "Partially Eligible - INR Only")]
        PartiallyEligibleInrOnly,
        #[serde(rename = "Partially Eligible - Unauth Only")]
        PartiallyEligibleUnauthOnly,
        #[serde(rename = "Partially Eligible")]
        PartiallyEligible,
        None,
        Active,
        #[serde(rename = "Fraud Control - Unauth Premium Eligible")]
        FraudControlUnauthPremiumEligible,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsSellerProtectionResponseInner {
        fn from(value: &PaymentDetailsSellerProtectionResponseInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsSellerProtectionResponseInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Eligible => f.write_str("Eligible"),
                Self::Ineligible => f.write_str("Ineligible"),
                Self::PartiallyEligibleInrOnly => f.write_str("Partially Eligible - INR Only"),
                Self::PartiallyEligibleUnauthOnly => {
                    f.write_str("Partially Eligible - Unauth Only")
                }
                Self::PartiallyEligible => f.write_str("Partially Eligible"),
                Self::None => f.write_str("None"),
                Self::Active => f.write_str("Active"),
                Self::FraudControlUnauthPremiumEligible => {
                    f.write_str("Fraud Control - Unauth Premium Eligible")
                }
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsSellerProtectionResponseInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "Eligible" => Ok(Self::Eligible),
                "Ineligible" => Ok(Self::Ineligible),
                "Partially Eligible - INR Only" => Ok(Self::PartiallyEligibleInrOnly),
                "Partially Eligible - Unauth Only" => Ok(Self::PartiallyEligibleUnauthOnly),
                "Partially Eligible" => Ok(Self::PartiallyEligible),
                "None" => Ok(Self::None),
                "Active" => Ok(Self::Active),
                "Fraud Control - Unauth Premium Eligible" => {
                    Ok(Self::FraudControlUnauthPremiumEligible)
                }
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsSellerProtectionResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for PaymentDetailsSellerProtectionResponseInner
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for PaymentDetailsSellerProtectionResponseInner
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The wallet used when creating the payment.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The wallet used when creating the payment.",
    ///  "examples": [
    ///    "applepay"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "applepay"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsWallet(pub ::std::option::Option<PaymentDetailsWalletInner>);
    impl ::std::ops::Deref for PaymentDetailsWallet {
        type Target = ::std::option::Option<PaymentDetailsWalletInner>;
        fn deref(&self) -> &::std::option::Option<PaymentDetailsWalletInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsWallet>
        for ::std::option::Option<PaymentDetailsWalletInner>
    {
        fn from(value: PaymentDetailsWallet) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsWallet> for PaymentDetailsWallet {
        fn from(value: &PaymentDetailsWallet) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentDetailsWalletInner>>
        for PaymentDetailsWallet
    {
        fn from(value: ::std::option::Option<PaymentDetailsWalletInner>) -> Self {
            Self(value)
        }
    }

    ///The wallet used when creating the payment.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The wallet used when creating the payment.",
    ///  "examples": [
    ///    "applepay"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "applepay"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsWalletInner {
        #[serde(rename = "applepay")]
        Applepay,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsWalletInner {
        fn from(value: &PaymentDetailsWalletInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsWalletInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Applepay => f.write_str("applepay"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsWalletInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "applepay" => Ok(Self::Applepay),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsWalletInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentDetailsWalletInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentDetailsWalletInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The wallet used when creating the payment.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The wallet used when creating the payment.",
    ///  "examples": [
    ///    "applepay"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "applepay"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentDetailsWalletResponse(
        pub ::std::option::Option<PaymentDetailsWalletResponseInner>,
    );
    impl ::std::ops::Deref for PaymentDetailsWalletResponse {
        type Target = ::std::option::Option<PaymentDetailsWalletResponseInner>;
        fn deref(&self) -> &::std::option::Option<PaymentDetailsWalletResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentDetailsWalletResponse>
        for ::std::option::Option<PaymentDetailsWalletResponseInner>
    {
        fn from(value: PaymentDetailsWalletResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentDetailsWalletResponse> for PaymentDetailsWalletResponse {
        fn from(value: &PaymentDetailsWalletResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentDetailsWalletResponseInner>>
        for PaymentDetailsWalletResponse
    {
        fn from(value: ::std::option::Option<PaymentDetailsWalletResponseInner>) -> Self {
            Self(value)
        }
    }

    ///The wallet used when creating the payment.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The wallet used when creating the payment.",
    ///  "examples": [
    ///    "applepay"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "applepay"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentDetailsWalletResponseInner {
        #[serde(rename = "applepay")]
        Applepay,
    }

    impl ::std::convert::From<&Self> for PaymentDetailsWalletResponseInner {
        fn from(value: &PaymentDetailsWalletResponseInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentDetailsWalletResponseInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Applepay => f.write_str("applepay"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentDetailsWalletResponseInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "applepay" => Ok(Self::Applepay),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentDetailsWalletResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentDetailsWalletResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentDetailsWalletResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PaymentLineItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "quantity",
    ///    "totalAmount",
    ///    "unitPrice"
    ///  ],
    ///  "properties": {
    ///    "categories": {
    ///      "description": "An array with the voucher categories, in case of a line eligible for a voucher. See the\n[Integrating Vouchers](https://docs.mollie.com/docs/integrating-vouchers/) guide for more information.",
    ///      "examples": [
    ///        [
    ///          "meal",
    ///          "eco"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/line-categories"
    ///      }
    ///    },
    ///    "description": {
    ///      "description": "A description of the line item. For example *LEGO
    /// 4440 Forest Police Station*.",
    ///      "examples": [
    ///        "LEGO 4440 Forest Police Station"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "discountAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "imageUrl": {
    ///      "description": "A link pointing to an image of the product sold.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "productUrl": {
    ///      "description": "A link pointing to the product page in your web
    /// shop of the product sold.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "quantity": {
    ///      "description": "The number of items.",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "minimum": 1.0
    ///    },
    ///    "quantityUnit": {
    ///      "description": "The unit for the quantity. For example *pcs*, *kg*,
    /// or *cm*.",
    ///      "examples": [
    ///        "pcs"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "sku": {
    ///      "description": "The SKU, EAN, ISBN or UPC of the product sold.",
    ///      "examples": [
    ///        "9780241661628"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 64
    ///    },
    ///    "totalAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/payment-line-type"
    ///    },
    ///    "unitPrice": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "vatAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "vatRate": {
    ///      "description": "The VAT rate applied to the line, for example
    /// `21.00` for 21%. The vatRate should be passed as a string and\nnot as a
    /// float, to ensure the correct number of decimals are passed.",
    ///      "examples": [
    ///        "21.00"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentLineItem {
        ///An array with the voucher categories, in case of a line eligible for
        /// a voucher. See the [Integrating Vouchers](https://docs.mollie.com/docs/integrating-vouchers/) guide for more information.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub categories: ::std::vec::Vec<LineCategories>,
        ///A description of the line item. For example *LEGO 4440 Forest Police
        /// Station*.
        pub description: ::std::string::String,
        #[serde(
            rename = "discountAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub discount_amount: ::std::option::Option<Amount>,
        ///A link pointing to an image of the product sold.
        #[serde(
            rename = "imageUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub image_url: ::std::option::Option<::std::string::String>,
        ///A link pointing to the product page in your web shop of the product
        /// sold.
        #[serde(
            rename = "productUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub product_url: ::std::option::Option<::std::string::String>,
        ///The number of items.
        pub quantity: ::std::num::NonZeroU64,
        ///The unit for the quantity. For example *pcs*, *kg*, or *cm*.
        #[serde(
            rename = "quantityUnit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub quantity_unit: ::std::option::Option<::std::string::String>,
        ///The SKU, EAN, ISBN or UPC of the product sold.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sku: ::std::option::Option<PaymentLineItemSku>,
        #[serde(rename = "totalAmount")]
        pub total_amount: Amount,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<PaymentLineType>,
        #[serde(rename = "unitPrice")]
        pub unit_price: Amount,
        #[serde(
            rename = "vatAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_amount: ::std::option::Option<Amount>,
        ///The VAT rate applied to the line, for example `21.00` for 21%. The
        /// vatRate should be passed as a string and not as a float, to
        /// ensure the correct number of decimals are passed.
        #[serde(
            rename = "vatRate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_rate: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PaymentLineItem> for PaymentLineItem {
        fn from(value: &PaymentLineItem) -> Self {
            value.clone()
        }
    }

    ///`PaymentLineItemResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "quantity",
    ///    "totalAmount",
    ///    "unitPrice"
    ///  ],
    ///  "properties": {
    ///    "categories": {
    ///      "description": "An array with the voucher categories, in case of a line eligible for a voucher. See the\n[Integrating Vouchers](https://docs.mollie.com/docs/integrating-vouchers/) guide for more information.",
    ///      "examples": [
    ///        [
    ///          "meal",
    ///          "eco"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/line-categories-response"
    ///      }
    ///    },
    ///    "description": {
    ///      "description": "A description of the line item. For example *LEGO
    /// 4440 Forest Police Station*.",
    ///      "examples": [
    ///        "LEGO 4440 Forest Police Station"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "discountAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "imageUrl": {
    ///      "description": "A link pointing to an image of the product sold.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "productUrl": {
    ///      "description": "A link pointing to the product page in your web
    /// shop of the product sold.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "quantity": {
    ///      "description": "The number of items.",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "minimum": 1.0
    ///    },
    ///    "quantityUnit": {
    ///      "description": "The unit for the quantity. For example *pcs*, *kg*,
    /// or *cm*.",
    ///      "examples": [
    ///        "pcs"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "sku": {
    ///      "description": "The SKU, EAN, ISBN or UPC of the product sold.",
    ///      "examples": [
    ///        "9780241661628"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 64
    ///    },
    ///    "totalAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/payment-line-type-response"
    ///    },
    ///    "unitPrice": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "vatAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "vatRate": {
    ///      "description": "The VAT rate applied to the line, for example
    /// `21.00` for 21%. The vatRate should be passed as a string and\nnot as a
    /// float, to ensure the correct number of decimals are passed.",
    ///      "examples": [
    ///        "21.00"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentLineItemResponse {
        ///An array with the voucher categories, in case of a line eligible for
        /// a voucher. See the [Integrating Vouchers](https://docs.mollie.com/docs/integrating-vouchers/) guide for more information.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub categories: ::std::vec::Vec<LineCategoriesResponse>,
        ///A description of the line item. For example *LEGO 4440 Forest Police
        /// Station*.
        pub description: ::std::string::String,
        #[serde(
            rename = "discountAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub discount_amount: ::std::option::Option<Amount>,
        ///A link pointing to an image of the product sold.
        #[serde(
            rename = "imageUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub image_url: ::std::option::Option<::std::string::String>,
        ///A link pointing to the product page in your web shop of the product
        /// sold.
        #[serde(
            rename = "productUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub product_url: ::std::option::Option<::std::string::String>,
        ///The number of items.
        pub quantity: ::std::num::NonZeroU64,
        ///The unit for the quantity. For example *pcs*, *kg*, or *cm*.
        #[serde(
            rename = "quantityUnit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub quantity_unit: ::std::option::Option<::std::string::String>,
        ///The SKU, EAN, ISBN or UPC of the product sold.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sku: ::std::option::Option<PaymentLineItemResponseSku>,
        #[serde(rename = "totalAmount")]
        pub total_amount: Amount,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<PaymentLineTypeResponse>,
        #[serde(rename = "unitPrice")]
        pub unit_price: Amount,
        #[serde(
            rename = "vatAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_amount: ::std::option::Option<Amount>,
        ///The VAT rate applied to the line, for example `21.00` for 21%. The
        /// vatRate should be passed as a string and not as a float, to
        /// ensure the correct number of decimals are passed.
        #[serde(
            rename = "vatRate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_rate: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PaymentLineItemResponse> for PaymentLineItemResponse {
        fn from(value: &PaymentLineItemResponse) -> Self {
            value.clone()
        }
    }

    ///The SKU, EAN, ISBN or UPC of the product sold.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The SKU, EAN, ISBN or UPC of the product sold.",
    ///  "examples": [
    ///    "9780241661628"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 64
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PaymentLineItemResponseSku(::std::string::String);
    impl ::std::ops::Deref for PaymentLineItemResponseSku {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentLineItemResponseSku> for ::std::string::String {
        fn from(value: PaymentLineItemResponseSku) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentLineItemResponseSku> for PaymentLineItemResponseSku {
        fn from(value: &PaymentLineItemResponseSku) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PaymentLineItemResponseSku {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 64usize {
                return Err("longer than 64 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentLineItemResponseSku {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentLineItemResponseSku {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentLineItemResponseSku {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PaymentLineItemResponseSku {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The SKU, EAN, ISBN or UPC of the product sold.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The SKU, EAN, ISBN or UPC of the product sold.",
    ///  "examples": [
    ///    "9780241661628"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 64
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PaymentLineItemSku(::std::string::String);
    impl ::std::ops::Deref for PaymentLineItemSku {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentLineItemSku> for ::std::string::String {
        fn from(value: PaymentLineItemSku) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentLineItemSku> for PaymentLineItemSku {
        fn from(value: &PaymentLineItemSku) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PaymentLineItemSku {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 64usize {
                return Err("longer than 64 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentLineItemSku {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentLineItemSku {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentLineItemSku {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PaymentLineItemSku {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The type of product purchased. For example, a physical or a digital
    /// product.
    ///
    ///The `tip` payment line type is not available when creating a payment.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of product purchased. For example, a physical
    /// or a digital product.\n\nThe `tip` payment line type is not available
    /// when creating a payment.",
    ///  "examples": [
    ///    "physical"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "physical",
    ///    "digital",
    ///    "shipping_fee",
    ///    "discount",
    ///    "store_credit",
    ///    "gift_card",
    ///    "surcharge",
    ///    "tip"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentLineType {
        #[serde(rename = "physical")]
        Physical,
        #[serde(rename = "digital")]
        Digital,
        #[serde(rename = "shipping_fee")]
        ShippingFee,
        #[serde(rename = "discount")]
        Discount,
        #[serde(rename = "store_credit")]
        StoreCredit,
        #[serde(rename = "gift_card")]
        GiftCard,
        #[serde(rename = "surcharge")]
        Surcharge,
        #[serde(rename = "tip")]
        Tip,
    }

    impl ::std::convert::From<&Self> for PaymentLineType {
        fn from(value: &PaymentLineType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentLineType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Physical => f.write_str("physical"),
                Self::Digital => f.write_str("digital"),
                Self::ShippingFee => f.write_str("shipping_fee"),
                Self::Discount => f.write_str("discount"),
                Self::StoreCredit => f.write_str("store_credit"),
                Self::GiftCard => f.write_str("gift_card"),
                Self::Surcharge => f.write_str("surcharge"),
                Self::Tip => f.write_str("tip"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentLineType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "physical" => Ok(Self::Physical),
                "digital" => Ok(Self::Digital),
                "shipping_fee" => Ok(Self::ShippingFee),
                "discount" => Ok(Self::Discount),
                "store_credit" => Ok(Self::StoreCredit),
                "gift_card" => Ok(Self::GiftCard),
                "surcharge" => Ok(Self::Surcharge),
                "tip" => Ok(Self::Tip),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentLineType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentLineType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentLineType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The type of product purchased. For example, a physical or a digital
    /// product.
    ///
    ///The `tip` payment line type is not available when creating a payment.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of product purchased. For example, a physical
    /// or a digital product.\n\nThe `tip` payment line type is not available
    /// when creating a payment.",
    ///  "examples": [
    ///    "physical"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "physical",
    ///    "digital",
    ///    "shipping_fee",
    ///    "discount",
    ///    "store_credit",
    ///    "gift_card",
    ///    "surcharge",
    ///    "tip"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentLineTypeResponse {
        #[serde(rename = "physical")]
        Physical,
        #[serde(rename = "digital")]
        Digital,
        #[serde(rename = "shipping_fee")]
        ShippingFee,
        #[serde(rename = "discount")]
        Discount,
        #[serde(rename = "store_credit")]
        StoreCredit,
        #[serde(rename = "gift_card")]
        GiftCard,
        #[serde(rename = "surcharge")]
        Surcharge,
        #[serde(rename = "tip")]
        Tip,
    }

    impl ::std::convert::From<&Self> for PaymentLineTypeResponse {
        fn from(value: &PaymentLineTypeResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentLineTypeResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Physical => f.write_str("physical"),
                Self::Digital => f.write_str("digital"),
                Self::ShippingFee => f.write_str("shipping_fee"),
                Self::Discount => f.write_str("discount"),
                Self::StoreCredit => f.write_str("store_credit"),
                Self::GiftCard => f.write_str("gift_card"),
                Self::Surcharge => f.write_str("surcharge"),
                Self::Tip => f.write_str("tip"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentLineTypeResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "physical" => Ok(Self::Physical),
                "digital" => Ok(Self::Digital),
                "shipping_fee" => Ok(Self::ShippingFee),
                "discount" => Ok(Self::Discount),
                "store_credit" => Ok(Self::StoreCredit),
                "gift_card" => Ok(Self::GiftCard),
                "surcharge" => Ok(Self::Surcharge),
                "tip" => Ok(Self::Tip),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentLineTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentLineTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentLineTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///An array of payment methods that are allowed to be used for this payment
    /// link. When this parameter is not provided or is an empty array, all
    /// enabled payment methods will be available.
    ///
    ///Enum: 'applepay', 'bancomatpay', 'bancontact', 'banktransfer',
    /// 'belfius', 'blik', 'creditcard', 'eps', 'giftcard', 'ideal', 'kbc',
    /// 'mybank', 'paybybank', 'paypal', 'paysafecard', 'pointofsale',
    /// 'przelewy24', 'satispay', 'trustly', 'twint', 'in3', 'riverty',
    /// 'klarna', 'billie'.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An array of payment methods that are allowed to be used for this payment link. When this parameter is\nnot provided or is an empty array, all enabled payment methods will be available.\n\nEnum: 'applepay', 'bancomatpay', 'bancontact', 'banktransfer', 'belfius', 'blik', 'creditcard', 'eps', 'giftcard',\n'ideal', 'kbc', 'mybank', 'paybybank', 'paypal', 'paysafecard', 'pointofsale', 'przelewy24', 'satispay', 'trustly', 'twint',\n'in3', 'riverty', 'klarna', 'billie'.",
    ///  "type": [
    ///    "array",
    ///    "null"
    ///  ],
    ///  "items": {
    ///    "examples": [
    ///      "ideal"
    ///    ],
    ///    "type": "string"
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentLinkMethods(
        pub ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    );
    impl ::std::ops::Deref for PaymentLinkMethods {
        type Target = ::std::option::Option<::std::vec::Vec<::std::string::String>>;
        fn deref(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentLinkMethods>
        for ::std::option::Option<::std::vec::Vec<::std::string::String>>
    {
        fn from(value: PaymentLinkMethods) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentLinkMethods> for PaymentLinkMethods {
        fn from(value: &PaymentLinkMethods) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<::std::vec::Vec<::std::string::String>>>
        for PaymentLinkMethods
    {
        fn from(value: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
            Self(value)
        }
    }

    ///`PaymentLinkResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/entity-payment-link"
    ///    }
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentLinkResponse(pub EntityPaymentLink);
    impl ::std::ops::Deref for PaymentLinkResponse {
        type Target = EntityPaymentLink;
        fn deref(&self) -> &EntityPaymentLink {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentLinkResponse> for EntityPaymentLink {
        fn from(value: PaymentLinkResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentLinkResponse> for PaymentLinkResponse {
        fn from(value: &PaymentLinkResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<EntityPaymentLink> for PaymentLinkResponse {
        fn from(value: EntityPaymentLink) -> Self {
            Self(value)
        }
    }

    ///`PaymentLinkSequenceType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "oneoff"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "oneoff",
    ///    "first"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentLinkSequenceType {
        #[serde(rename = "oneoff")]
        Oneoff,
        #[serde(rename = "first")]
        First,
    }

    impl ::std::convert::From<&Self> for PaymentLinkSequenceType {
        fn from(value: &PaymentLinkSequenceType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentLinkSequenceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Oneoff => f.write_str("oneoff"),
                Self::First => f.write_str("first"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentLinkSequenceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "oneoff" => Ok(Self::Oneoff),
                "first" => Ok(Self::First),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentLinkSequenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentLinkSequenceType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentLinkSequenceType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PaymentLinkSequenceTypeResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "oneoff"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "oneoff",
    ///    "first"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentLinkSequenceTypeResponse {
        #[serde(rename = "oneoff")]
        Oneoff,
        #[serde(rename = "first")]
        First,
    }

    impl ::std::convert::From<&Self> for PaymentLinkSequenceTypeResponse {
        fn from(value: &PaymentLinkSequenceTypeResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentLinkSequenceTypeResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Oneoff => f.write_str("oneoff"),
                Self::First => f.write_str("first"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentLinkSequenceTypeResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "oneoff" => Ok(Self::Oneoff),
                "first" => Ok(Self::First),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentLinkSequenceTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentLinkSequenceTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentLinkSequenceTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PaymentLinkToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "pl_d9fQur83kFdhH8hIhaZfq"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct PaymentLinkToken(pub ::std::string::String);
    impl ::std::ops::Deref for PaymentLinkToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentLinkToken> for ::std::string::String {
        fn from(value: PaymentLinkToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentLinkToken> for PaymentLinkToken {
        fn from(value: &PaymentLinkToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for PaymentLinkToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for PaymentLinkToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for PaymentLinkToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`PaymentListRoutesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_embedded": {
    ///      "type": "object",
    ///      "properties": {
    ///        "routes": {
    ///          "description": "An array of route objects.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/route-get-response"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "_links": {
    ///      "description": "Links to help navigate through the lists of items.
    /// Every URL object will contain an `href` and a `type` field.",
    ///      "type": "object",
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "count": {
    ///      "$ref": "#/components/schemas/list-count"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentListRoutesResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<ListCount>,
        #[serde(
            rename = "_embedded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub embedded: ::std::option::Option<PaymentListRoutesResponseEmbedded>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<PaymentListRoutesResponseLinks>,
    }

    impl ::std::convert::From<&PaymentListRoutesResponse> for PaymentListRoutesResponse {
        fn from(value: &PaymentListRoutesResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PaymentListRoutesResponse {
        fn default() -> Self {
            Self {
                count: Default::default(),
                embedded: Default::default(),
                links: Default::default(),
            }
        }
    }

    ///`PaymentListRoutesResponseEmbedded`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "routes": {
    ///      "description": "An array of route objects.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/route-get-response"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentListRoutesResponseEmbedded {
        ///An array of route objects.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub routes: ::std::vec::Vec<RouteGetResponse>,
    }

    impl ::std::convert::From<&PaymentListRoutesResponseEmbedded>
        for PaymentListRoutesResponseEmbedded
    {
        fn from(value: &PaymentListRoutesResponseEmbedded) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PaymentListRoutesResponseEmbedded {
        fn default() -> Self {
            Self {
                routes: Default::default(),
            }
        }
    }

    ///Links to help navigate through the lists of items. Every URL object will
    /// contain an `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Links to help navigate through the lists of items.
    /// Every URL object will contain an `href` and a `type` field.",
    ///  "type": "object",
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentListRoutesResponseLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&PaymentListRoutesResponseLinks> for PaymentListRoutesResponseLinks {
        fn from(value: &PaymentListRoutesResponseLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PaymentListRoutesResponseLinks {
        fn default() -> Self {
            Self {
                documentation: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///The payment method, if applicable
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The payment method, if applicable",
    ///  "examples": [
    ///    "creditcard"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "alma",
    ///    "bacs",
    ///    "applepay",
    ///    "bancomatpay",
    ///    "bancontact",
    ///    "banktransfer",
    ///    "belfius",
    ///    "billie",
    ///    "bizum",
    ///    "bitcoin",
    ///    "blik",
    ///    "creditcard",
    ///    "directdebit",
    ///    "eps",
    ///    "giftcard",
    ///    "giropay",
    ///    "googlepay",
    ///    "ideal",
    ///    "in3",
    ///    "inghomepay",
    ///    "kbc",
    ///    "klarnapaylater",
    ///    "klarnapaynow",
    ///    "klarnasliceit",
    ///    "klarna",
    ///    "mbway",
    ///    "mobilepay",
    ///    "multibanco",
    ///    "mybank",
    ///    "paybybank",
    ///    "payconiq",
    ///    "paypal",
    ///    "paysafecard",
    ///    "przelewy24",
    ///    "riverty",
    ///    "satispay",
    ///    "podiumcadeaukaart",
    ///    "pointofsale",
    ///    "sofort",
    ///    "swish",
    ///    "trustly",
    ///    "twint",
    ///    "vipps",
    ///    "voucher"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentMethod(pub ::std::option::Option<PaymentMethodInner>);
    impl ::std::ops::Deref for PaymentMethod {
        type Target = ::std::option::Option<PaymentMethodInner>;
        fn deref(&self) -> &::std::option::Option<PaymentMethodInner> {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentMethod> for ::std::option::Option<PaymentMethodInner> {
        fn from(value: PaymentMethod) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentMethod> for PaymentMethod {
        fn from(value: &PaymentMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<PaymentMethodInner>> for PaymentMethod {
        fn from(value: ::std::option::Option<PaymentMethodInner>) -> Self {
            Self(value)
        }
    }

    ///The payment method, if applicable
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The payment method, if applicable",
    ///  "examples": [
    ///    "creditcard"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "alma",
    ///    "bacs",
    ///    "applepay",
    ///    "bancomatpay",
    ///    "bancontact",
    ///    "banktransfer",
    ///    "belfius",
    ///    "billie",
    ///    "bizum",
    ///    "bitcoin",
    ///    "blik",
    ///    "creditcard",
    ///    "directdebit",
    ///    "eps",
    ///    "giftcard",
    ///    "giropay",
    ///    "googlepay",
    ///    "ideal",
    ///    "in3",
    ///    "inghomepay",
    ///    "kbc",
    ///    "klarnapaylater",
    ///    "klarnapaynow",
    ///    "klarnasliceit",
    ///    "klarna",
    ///    "mbway",
    ///    "mobilepay",
    ///    "multibanco",
    ///    "mybank",
    ///    "paybybank",
    ///    "payconiq",
    ///    "paypal",
    ///    "paysafecard",
    ///    "przelewy24",
    ///    "riverty",
    ///    "satispay",
    ///    "podiumcadeaukaart",
    ///    "pointofsale",
    ///    "sofort",
    ///    "swish",
    ///    "trustly",
    ///    "twint",
    ///    "vipps",
    ///    "voucher"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentMethodInner {
        #[serde(rename = "alma")]
        Alma,
        #[serde(rename = "bacs")]
        Bacs,
        #[serde(rename = "applepay")]
        Applepay,
        #[serde(rename = "bancomatpay")]
        Bancomatpay,
        #[serde(rename = "bancontact")]
        Bancontact,
        #[serde(rename = "banktransfer")]
        Banktransfer,
        #[serde(rename = "belfius")]
        Belfius,
        #[serde(rename = "billie")]
        Billie,
        #[serde(rename = "bizum")]
        Bizum,
        #[serde(rename = "bitcoin")]
        Bitcoin,
        #[serde(rename = "blik")]
        Blik,
        #[serde(rename = "creditcard")]
        Creditcard,
        #[serde(rename = "directdebit")]
        Directdebit,
        #[serde(rename = "eps")]
        Eps,
        #[serde(rename = "giftcard")]
        Giftcard,
        #[serde(rename = "giropay")]
        Giropay,
        #[serde(rename = "googlepay")]
        Googlepay,
        #[serde(rename = "ideal")]
        Ideal,
        #[serde(rename = "in3")]
        In3,
        #[serde(rename = "inghomepay")]
        Inghomepay,
        #[serde(rename = "kbc")]
        Kbc,
        #[serde(rename = "klarnapaylater")]
        Klarnapaylater,
        #[serde(rename = "klarnapaynow")]
        Klarnapaynow,
        #[serde(rename = "klarnasliceit")]
        Klarnasliceit,
        #[serde(rename = "klarna")]
        Klarna,
        #[serde(rename = "mbway")]
        Mbway,
        #[serde(rename = "mobilepay")]
        Mobilepay,
        #[serde(rename = "multibanco")]
        Multibanco,
        #[serde(rename = "mybank")]
        Mybank,
        #[serde(rename = "paybybank")]
        Paybybank,
        #[serde(rename = "payconiq")]
        Payconiq,
        #[serde(rename = "paypal")]
        Paypal,
        #[serde(rename = "paysafecard")]
        Paysafecard,
        #[serde(rename = "przelewy24")]
        Przelewy24,
        #[serde(rename = "riverty")]
        Riverty,
        #[serde(rename = "satispay")]
        Satispay,
        #[serde(rename = "podiumcadeaukaart")]
        Podiumcadeaukaart,
        #[serde(rename = "pointofsale")]
        Pointofsale,
        #[serde(rename = "sofort")]
        Sofort,
        #[serde(rename = "swish")]
        Swish,
        #[serde(rename = "trustly")]
        Trustly,
        #[serde(rename = "twint")]
        Twint,
        #[serde(rename = "vipps")]
        Vipps,
        #[serde(rename = "voucher")]
        Voucher,
    }

    impl ::std::convert::From<&Self> for PaymentMethodInner {
        fn from(value: &PaymentMethodInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentMethodInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Alma => f.write_str("alma"),
                Self::Bacs => f.write_str("bacs"),
                Self::Applepay => f.write_str("applepay"),
                Self::Bancomatpay => f.write_str("bancomatpay"),
                Self::Bancontact => f.write_str("bancontact"),
                Self::Banktransfer => f.write_str("banktransfer"),
                Self::Belfius => f.write_str("belfius"),
                Self::Billie => f.write_str("billie"),
                Self::Bizum => f.write_str("bizum"),
                Self::Bitcoin => f.write_str("bitcoin"),
                Self::Blik => f.write_str("blik"),
                Self::Creditcard => f.write_str("creditcard"),
                Self::Directdebit => f.write_str("directdebit"),
                Self::Eps => f.write_str("eps"),
                Self::Giftcard => f.write_str("giftcard"),
                Self::Giropay => f.write_str("giropay"),
                Self::Googlepay => f.write_str("googlepay"),
                Self::Ideal => f.write_str("ideal"),
                Self::In3 => f.write_str("in3"),
                Self::Inghomepay => f.write_str("inghomepay"),
                Self::Kbc => f.write_str("kbc"),
                Self::Klarnapaylater => f.write_str("klarnapaylater"),
                Self::Klarnapaynow => f.write_str("klarnapaynow"),
                Self::Klarnasliceit => f.write_str("klarnasliceit"),
                Self::Klarna => f.write_str("klarna"),
                Self::Mbway => f.write_str("mbway"),
                Self::Mobilepay => f.write_str("mobilepay"),
                Self::Multibanco => f.write_str("multibanco"),
                Self::Mybank => f.write_str("mybank"),
                Self::Paybybank => f.write_str("paybybank"),
                Self::Payconiq => f.write_str("payconiq"),
                Self::Paypal => f.write_str("paypal"),
                Self::Paysafecard => f.write_str("paysafecard"),
                Self::Przelewy24 => f.write_str("przelewy24"),
                Self::Riverty => f.write_str("riverty"),
                Self::Satispay => f.write_str("satispay"),
                Self::Podiumcadeaukaart => f.write_str("podiumcadeaukaart"),
                Self::Pointofsale => f.write_str("pointofsale"),
                Self::Sofort => f.write_str("sofort"),
                Self::Swish => f.write_str("swish"),
                Self::Trustly => f.write_str("trustly"),
                Self::Twint => f.write_str("twint"),
                Self::Vipps => f.write_str("vipps"),
                Self::Voucher => f.write_str("voucher"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentMethodInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "alma" => Ok(Self::Alma),
                "bacs" => Ok(Self::Bacs),
                "applepay" => Ok(Self::Applepay),
                "bancomatpay" => Ok(Self::Bancomatpay),
                "bancontact" => Ok(Self::Bancontact),
                "banktransfer" => Ok(Self::Banktransfer),
                "belfius" => Ok(Self::Belfius),
                "billie" => Ok(Self::Billie),
                "bizum" => Ok(Self::Bizum),
                "bitcoin" => Ok(Self::Bitcoin),
                "blik" => Ok(Self::Blik),
                "creditcard" => Ok(Self::Creditcard),
                "directdebit" => Ok(Self::Directdebit),
                "eps" => Ok(Self::Eps),
                "giftcard" => Ok(Self::Giftcard),
                "giropay" => Ok(Self::Giropay),
                "googlepay" => Ok(Self::Googlepay),
                "ideal" => Ok(Self::Ideal),
                "in3" => Ok(Self::In3),
                "inghomepay" => Ok(Self::Inghomepay),
                "kbc" => Ok(Self::Kbc),
                "klarnapaylater" => Ok(Self::Klarnapaylater),
                "klarnapaynow" => Ok(Self::Klarnapaynow),
                "klarnasliceit" => Ok(Self::Klarnasliceit),
                "klarna" => Ok(Self::Klarna),
                "mbway" => Ok(Self::Mbway),
                "mobilepay" => Ok(Self::Mobilepay),
                "multibanco" => Ok(Self::Multibanco),
                "mybank" => Ok(Self::Mybank),
                "paybybank" => Ok(Self::Paybybank),
                "payconiq" => Ok(Self::Payconiq),
                "paypal" => Ok(Self::Paypal),
                "paysafecard" => Ok(Self::Paysafecard),
                "przelewy24" => Ok(Self::Przelewy24),
                "riverty" => Ok(Self::Riverty),
                "satispay" => Ok(Self::Satispay),
                "podiumcadeaukaart" => Ok(Self::Podiumcadeaukaart),
                "pointofsale" => Ok(Self::Pointofsale),
                "sofort" => Ok(Self::Sofort),
                "swish" => Ok(Self::Swish),
                "trustly" => Ok(Self::Trustly),
                "twint" => Ok(Self::Twint),
                "vipps" => Ok(Self::Vipps),
                "voucher" => Ok(Self::Voucher),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentMethodInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentMethodInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentMethodInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PaymentRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/entity-payment"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/extra-parameter-parameters"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<Amount>,
        #[serde(
            rename = "amountCaptured",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub amount_captured: ::std::option::Option<Amount>,
        #[serde(
            rename = "amountChargedBack",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub amount_charged_back: ::std::option::Option<Amount>,
        #[serde(
            rename = "amountRefunded",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub amount_refunded: ::std::option::Option<Amount>,
        #[serde(
            rename = "amountRemaining",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub amount_remaining: ::std::option::Option<Amount>,
        ///The Apple Pay Payment token object (encoded as JSON) that is part of
        /// the result of authorizing a payment request.
        /// The token contains the payment information needed to authorize the
        /// payment.
        ///
        ///The object should be passed encoded in a JSON string.
        #[serde(
            rename = "applePayPaymentToken",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub apple_pay_payment_token: ::std::option::Option<::std::string::String>,
        ///With Mollie Connect you can charge fees on payments that your app is
        /// processing on behalf of other Mollie merchants.
        ///
        ///If you use OAuth to create payments on a connected merchant's
        /// account, you can charge a fee using this `applicationFee`
        /// parameter. If the payment succeeds, the fee will be deducted from
        /// the merchant's balance and sent to your own account balance.
        ///
        ///If instead you want to split a payment on your own account between
        /// yourself and a connected merchant, refer to the
        /// `routing` parameter.
        #[serde(
            rename = "applicationFee",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub application_fee: ::std::option::Option<PaymentRequestApplicationFee>,
        ///The date and time the payment became authorized, in ISO 8601 format.
        /// This parameter is omitted if the payment is not authorized
        /// (yet).
        #[serde(
            rename = "authorizedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub authorized_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "billingAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub billing_address: ::std::option::Option<PaymentAddress>,
        ///The URL your customer will be redirected to when the customer
        /// explicitly cancels the payment. If this URL is not provided,
        /// the customer will be redirected to the `redirectUrl` instead — see
        /// above.
        ///
        ///Mollie will always give you status updates via webhooks, including
        /// for the canceled status. This parameter is
        /// therefore entirely optional, but can be useful when implementing a
        /// dedicated customer-facing flow to handle
        /// payment cancellations.
        #[serde(
            rename = "cancelUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub cancel_url: ::std::option::Option<::std::string::String>,
        ///The date and time the payment was canceled, in ISO 8601 format. This
        /// parameter is omitted if the payment is not canceled (yet).
        #[serde(
            rename = "canceledAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub canceled_at: ::std::option::Option<::std::string::String>,
        ///Indicates the date before which the payment needs to be captured, in
        /// ISO 8601 format. From this date onwards we can no longer
        /// guarantee a successful capture. The parameter is omitted if the
        /// payment is not authorized (yet).
        #[serde(
            rename = "captureBefore",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub capture_before: ::std::option::Option<::std::string::String>,
        ///**Only relevant if you wish to manage authorization and capturing
        /// separately.**
        ///
        ///Some payment methods allow placing a hold on the card or bank
        /// account. This hold or 'authorization' can then at a
        /// later point either be 'captured' or canceled.
        ///
        ///By default, we charge the customer's card or bank account
        /// immediately when they complete the payment. If you set a
        /// capture delay however, we will delay the automatic capturing of the
        /// payment for the specified amount of time. For example `8
        /// hours` or `2 days`.
        ///
        ///To schedule an automatic capture, the `captureMode` must be set to
        /// `automatic`.
        ///
        ///The maximum delay is 7 days (168 hours).
        ///
        ///Possible values: `... hours` `... days`
        #[serde(
            rename = "captureDelay",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub capture_delay: ::std::option::Option<PaymentRequestCaptureDelay>,
        #[serde(
            rename = "captureMode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub capture_mode: ::std::option::Option<CaptureMode>,
        ///When creating credit card payments using Mollie Components, you need
        /// to provide the card token you received from
        /// the card component in this field. The token represents the
        /// customer's card information needed to complete the
        /// payment. Note: field only valid for oneoff and first payments. For
        /// recurring payments, the customerId alone is enough.
        #[serde(
            rename = "cardToken",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_token: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub company: ::std::option::Option<PaymentRequestCompany>,
        ///The customer's date of birth. If not provided via the API, iDeal in3
        /// will ask the customer to provide it during the payment
        /// process.
        #[serde(
            rename = "consumerDateOfBirth",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_date_of_birth: ::std::option::Option<::chrono::naive::NaiveDate>,
        ///This optional field contains your customer's ISO 3166-1 alpha-2
        /// country code, detected by us during checkout. This
        /// field is omitted if the country code was not detected.
        #[serde(
            rename = "countryCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub country_code: ::std::option::Option<PaymentRequestCountryCode>,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        #[serde(
            rename = "customerId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub customer_id: ::std::option::Option<CustomerToken>,
        ///Used by paysafecard for customer identification across payments.
        /// When you generate a customer reference yourself,
        /// make sure not to put personal identifiable information or IP
        /// addresses in the customer reference directly.
        #[serde(
            rename = "customerReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub customer_reference: ::std::option::Option<::std::string::String>,
        ///The description of the payment. This will be shown to your customer
        /// on their card or bank statement when possible. We truncate
        /// the description automatically according to the limits of the used
        /// payment method. The description is also visible in any
        /// exports you generate.
        ///
        ///We recommend you use a unique identifier so that you can always link
        /// the payment to the order in your back office.
        /// This is particularly useful for bookkeeping.
        ///
        ///The maximum length of the description field differs per payment
        /// method, with the absolute maximum being 255 characters. The
        /// API will not reject strings longer than the maximum length but it
        /// will truncate them to fit.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<PaymentRequestDescription>,
        ///An object containing payment details collected during the payment
        /// process. For example, details may include the customer's
        /// card or bank details and a payment reference. For the full list of
        /// details, please refer to the [method-specific
        /// parameters](extra-payment-parameters) guide.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub details: ::std::option::Option<PaymentRequestDetails>,
        ///Indicate if you are about to deliver digital goods, such as for
        /// example a software license. Setting this parameter
        /// can have consequences for your PayPal Seller Protection. Refer to
        /// PayPal's documentation for more information.
        #[serde(
            rename = "digitalGoods",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub digital_goods: ::std::option::Option<bool>,
        ///The date by which the payment should be completed in `YYYY-MM-DD`
        /// format
        #[serde(
            rename = "dueDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub due_date: ::std::option::Option<::std::string::String>,
        ///The date and time the payment was expired, in ISO 8601 format. This
        /// parameter is omitted if the payment did not expire (yet).
        #[serde(
            rename = "expiredAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub expired_at: ::std::option::Option<::std::string::String>,
        ///The date and time the payment will expire, in ISO 8601 format. This
        /// parameter is omitted if the payment can no longer expire.
        #[serde(
            rename = "expiresAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub expires_at: ::std::option::Option<::std::string::String>,
        ///For some industries, additional purchase information can be sent to
        /// Klarna to increase the authorization rate. You can submit
        /// your extra data in this field if you have agreed upon this with
        /// Klarna. This field should be an object containing any of the
        /// allowed keys and sub-objects described at the Klarna Developer
        /// Documentation.
        #[serde(
            rename = "extraMerchantData",
            default,
            skip_serializing_if = "::serde_json::Map::is_empty"
        )]
        pub extra_merchant_data: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        ///The date and time the payment failed, in ISO 8601 format. This
        /// parameter is omitted if the payment did not fail (yet).
        #[serde(
            rename = "failedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub failed_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<PaymentToken>,
        ///Whether the payment can be canceled. This parameter is omitted if
        /// the payment reaches a final state.
        #[serde(
            rename = "isCancelable",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub is_cancelable: ::std::option::Option<bool>,
        ///**Only relevant for iDEAL, KBC/CBC, gift card, and voucher
        /// payments.**
        ///
        ///**⚠️ With the introduction of iDEAL 2 in 2025, this field will be
        /// ignored for iDEAL payments. For more information on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
        ///
        ///Some payment methods are a network of connected banks or card
        /// issuers. In these cases, after selecting the payment method,
        /// the customer may still need to select the appropriate issuer before
        /// the payment can proceed.
        ///
        ///We provide hosted issuer selection screens, but these screens can be
        /// skipped by providing the `issuer` via the API up front.
        ///
        ///The full list of issuers for a specific method can be retrieved via
        /// the Methods API by using the optional `issuers` include.
        ///
        ///A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING
        /// Bank).
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub issuer: ::std::option::Option<::std::string::String>,
        ///Optionally provide the order lines for the payment. Each line
        /// contains details such as a description of the item
        /// ordered and its price.
        ///
        ///All lines must have the same currency as the payment.
        ///
        ///Required for payment methods `billie`, `in3`, `klarna`, `riverty`
        /// and `voucher`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub lines: ::std::option::Option<::std::vec::Vec<PaymentRequestLinesItem>>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<PaymentRequestLinks>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub locale: ::std::option::Option<Locale>,
        #[serde(
            rename = "mandateId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub mandate_id: ::std::option::Option<MandateToken>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<Metadata>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub method: ::std::option::Option<Method>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<Mode>,
        #[serde(
            rename = "orderId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub order_id: ::std::option::Option<OrderToken>,
        ///The date and time the payment became paid, in ISO 8601 format. This
        /// parameter is omitted if the payment is not completed (yet).
        #[serde(
            rename = "paidAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paid_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "profileId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub profile_id: ::std::option::Option<ProfileToken>,
        ///The URL your customer will be redirected to after the payment
        /// process.
        ///
        ///It could make sense for the redirectUrl to contain a unique
        /// identifier – like your order ID – so you can show the
        /// right page referencing the order when your customer returns.
        ///
        ///The parameter is normally required, but can be omitted for recurring
        /// payments (`sequenceType: recurring`) and for
        /// Apple Pay payments with an `applePayPaymentToken`.
        #[serde(
            rename = "redirectUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub redirect_url: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a payment object. Will always
        /// contain the string `payment` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        ///For digital goods in most jurisdictions, you must apply the VAT rate
        /// from your customer's country. Choose the VAT rates you have
        /// used for the order to ensure your customer's country matches the VAT
        /// country.
        ///
        ///Use this parameter to restrict the payment methods available to your
        /// customer to those from a single country.
        ///
        ///If available, the credit card method will still be offered, but only
        /// cards from the allowed country are accepted.
        ///
        ///The field expects a country code in ISO 3166-1 alpha-2 format, for
        /// example `NL`.
        #[serde(
            rename = "restrictPaymentMethodsToCountry",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub restrict_payment_methods_to_country: ::std::option::Option<::std::string::String>,
        ///*This functionality is not enabled by default. Reach out to our
        /// partner management team if you wish to use it.*
        ///
        ///With Mollie Connect you can charge fees on payments that your app is
        /// processing on behalf of other Mollie merchants.
        ///
        ///If you create payments on your own account that you want to split
        /// between yourself and one or more connected merchants, you
        /// can use this `routing` parameter to route the payment accordingly.
        ///
        ///The `routing` parameter should contain an array of objects, with
        /// each object describing the destination for a
        /// specific portion of the payment.
        ///
        ///It is not necessary to indicate in the array which portion goes to
        /// yourself. After all portions of the total payment amount
        /// have been routed, the amount left will be routed to the current
        /// organization automatically.
        ///
        ///If instead you use OAuth to create payments on a connected
        /// merchant's account, refer to the `applicationFee` parameter.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub routing: ::std::option::Option<::std::vec::Vec<EntityPaymentRoute>>,
        #[serde(
            rename = "sequenceType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub sequence_type: ::std::option::Option<SequenceType>,
        ///The unique ID you have used for the PayPal fraud library. You should
        /// include this if you use PayPal for an on-demand payment.
        #[serde(
            rename = "sessionId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub session_id: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "settlementAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_amount: ::std::option::Option<Amount>,
        #[serde(
            rename = "settlementId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub settlement_id: ::std::option::Option<SettlementToken>,
        #[serde(
            rename = "shippingAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub shipping_address: ::std::option::Option<PaymentAddress>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<PaymentStatus>,
        #[serde(
            rename = "statusReason",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub status_reason: ::std::option::Option<StatusReason>,
        #[serde(
            rename = "subscriptionId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subscription_id: ::std::option::Option<SubscriptionToken>,
        ///The ID of the terminal device where you want to initiate the payment
        /// on.
        #[serde(
            rename = "terminalId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub terminal_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
        ///The card token you received from the card component of Mollie
        /// Components. The token represents the customer's card
        /// information needed to complete the payment.
        #[serde(
            rename = "voucherNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub voucher_number: ::std::option::Option<::std::string::String>,
        ///The PIN on the gift card. You can supply this to prefill the PIN, if
        /// the card has any.
        #[serde(
            rename = "voucherPin",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub voucher_pin: ::std::option::Option<::std::string::String>,
        ///The webhook URL where we will send payment status updates to.
        ///
        ///The webhookUrl is optional, but without a webhook you will miss out
        /// on important status changes to your payment.
        ///
        ///The webhookUrl must be reachable from Mollie's point of view, so you
        /// cannot use `localhost`. If you want to use webhook during
        /// development on `localhost`, you must use a tool like ngrok to have
        /// the webhooks delivered to your local machine.
        #[serde(
            rename = "webhookUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub webhook_url: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PaymentRequest> for PaymentRequest {
        fn from(value: &PaymentRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PaymentRequest {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                amount_captured: Default::default(),
                amount_charged_back: Default::default(),
                amount_refunded: Default::default(),
                amount_remaining: Default::default(),
                apple_pay_payment_token: Default::default(),
                application_fee: Default::default(),
                authorized_at: Default::default(),
                billing_address: Default::default(),
                cancel_url: Default::default(),
                canceled_at: Default::default(),
                capture_before: Default::default(),
                capture_delay: Default::default(),
                capture_mode: Default::default(),
                card_token: Default::default(),
                company: Default::default(),
                consumer_date_of_birth: Default::default(),
                country_code: Default::default(),
                created_at: Default::default(),
                customer_id: Default::default(),
                customer_reference: Default::default(),
                description: Default::default(),
                details: Default::default(),
                digital_goods: Default::default(),
                due_date: Default::default(),
                expired_at: Default::default(),
                expires_at: Default::default(),
                extra_merchant_data: Default::default(),
                failed_at: Default::default(),
                id: Default::default(),
                is_cancelable: Default::default(),
                issuer: Default::default(),
                lines: Default::default(),
                links: Default::default(),
                locale: Default::default(),
                mandate_id: Default::default(),
                metadata: Default::default(),
                method: Default::default(),
                mode: Default::default(),
                order_id: Default::default(),
                paid_at: Default::default(),
                profile_id: Default::default(),
                redirect_url: Default::default(),
                resource: Default::default(),
                restrict_payment_methods_to_country: Default::default(),
                routing: Default::default(),
                sequence_type: Default::default(),
                session_id: Default::default(),
                settlement_amount: Default::default(),
                settlement_id: Default::default(),
                shipping_address: Default::default(),
                status: Default::default(),
                status_reason: Default::default(),
                subscription_id: Default::default(),
                terminal_id: Default::default(),
                testmode: Default::default(),
                voucher_number: Default::default(),
                voucher_pin: Default::default(),
                webhook_url: Default::default(),
            }
        }
    }

    ///With Mollie Connect you can charge fees on payments that your app is
    /// processing on behalf of other Mollie merchants.
    ///
    ///If you use OAuth to create payments on a connected merchant's account,
    /// you can charge a fee using this `applicationFee` parameter. If the
    /// payment succeeds, the fee will be deducted from the merchant's balance
    /// and sent to your own account balance.
    ///
    ///If instead you want to split a payment on your own account between
    /// yourself and a connected merchant, refer to the `routing` parameter.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "With Mollie Connect you can charge fees on payments
    /// that your app is processing on behalf of other Mollie\nmerchants.\n\nIf
    /// you use OAuth to create payments on a connected merchant's account, you
    /// can charge a fee using this\n`applicationFee` parameter. If the payment
    /// succeeds, the fee will be deducted from the merchant's balance and
    /// sent\nto your own account balance.\n\nIf instead you want to split a
    /// payment on your own account between yourself and a connected merchant,
    /// refer to the\n`routing` parameter.",
    ///  "type": "object",
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "description": {
    ///      "description": "The description of the application fee. This will
    /// appear on settlement reports towards both you and the\nconnected
    /// merchant.",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentRequestApplicationFee {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<Amount>,
        ///The description of the application fee. This will appear on
        /// settlement reports towards both you and the
        /// connected merchant.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<PaymentRequestApplicationFeeDescription>,
    }

    impl ::std::convert::From<&PaymentRequestApplicationFee> for PaymentRequestApplicationFee {
        fn from(value: &PaymentRequestApplicationFee) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PaymentRequestApplicationFee {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                description: Default::default(),
            }
        }
    }

    ///The description of the application fee. This will appear on settlement
    /// reports towards both you and the connected merchant.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The description of the application fee. This will
    /// appear on settlement reports towards both you and the\nconnected
    /// merchant.",
    ///  "examples": [
    ///    10
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PaymentRequestApplicationFeeDescription(::std::string::String);
    impl ::std::ops::Deref for PaymentRequestApplicationFeeDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentRequestApplicationFeeDescription> for ::std::string::String {
        fn from(value: PaymentRequestApplicationFeeDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentRequestApplicationFeeDescription>
        for PaymentRequestApplicationFeeDescription
    {
        fn from(value: &PaymentRequestApplicationFeeDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PaymentRequestApplicationFeeDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentRequestApplicationFeeDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentRequestApplicationFeeDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentRequestApplicationFeeDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PaymentRequestApplicationFeeDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///**Only relevant if you wish to manage authorization and capturing
    /// separately.**
    ///
    ///Some payment methods allow placing a hold on the card or bank account.
    /// This hold or 'authorization' can then at a later point either be
    /// 'captured' or canceled.
    ///
    ///By default, we charge the customer's card or bank account immediately
    /// when they complete the payment. If you set a capture delay however,
    /// we will delay the automatic capturing of the payment for the specified
    /// amount of time. For example `8 hours` or `2 days`.
    ///
    ///To schedule an automatic capture, the `captureMode` must be set to
    /// `automatic`.
    ///
    ///The maximum delay is 7 days (168 hours).
    ///
    ///Possible values: `... hours` `... days`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "**Only relevant if you wish to manage authorization and
    /// capturing separately.**\n\nSome payment methods allow placing a hold on
    /// the card or bank account. This hold or 'authorization' can then at
    /// a\nlater point either be 'captured' or canceled.\n\nBy default, we
    /// charge the customer's card or bank account immediately when they
    /// complete the payment. If you set a\ncapture delay however, we will delay
    /// the automatic capturing of the payment for the specified amount of time.
    /// For\nexample `8 hours` or `2 days`.\n\nTo schedule an automatic capture,
    /// the `captureMode` must be set to `automatic`.\n\nThe maximum delay is 7
    /// days (168 hours).\n\nPossible values: `... hours` `... days`",
    ///  "examples": [
    ///    "8 hours"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+ (hours|days)$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PaymentRequestCaptureDelay(::std::string::String);
    impl ::std::ops::Deref for PaymentRequestCaptureDelay {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentRequestCaptureDelay> for ::std::string::String {
        fn from(value: PaymentRequestCaptureDelay) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentRequestCaptureDelay> for PaymentRequestCaptureDelay {
        fn from(value: &PaymentRequestCaptureDelay) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PaymentRequestCaptureDelay {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^\\d+ (hours|days)$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+ (hours|days)$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentRequestCaptureDelay {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentRequestCaptureDelay {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentRequestCaptureDelay {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PaymentRequestCaptureDelay {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Billie is a business-to-business (B2B) payment method. It requires extra
    /// information to identify the organization that is completing the
    /// payment. It is recommended to include these parameters up front for a
    /// seamless flow. Otherwise, Billie will ask the customer to complete
    /// the missing fields during checkout.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Billie is a business-to-business (B2B) payment method.
    /// It requires extra information to identify the organization\nthat is
    /// completing the payment. It is recommended to include these parameters up
    /// front for a seamless flow.\nOtherwise, Billie will ask the customer to
    /// complete the missing fields during checkout.",
    ///  "writeOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "entityType": {
    ///      "description": "The organization's entity type.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "registrationNumber": {
    ///      "description": "The organization's registration number.",
    ///      "examples": [
    ///        "12345678"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "vatNumber": {
    ///      "description": "The organization's VAT number.",
    ///      "examples": [
    ///        "NL123456789B01"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-methodSpecific": true
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentRequestCompany {
        ///The organization's entity type.
        #[serde(
            rename = "entityType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub entity_type: ::std::option::Option<::std::string::String>,
        ///The organization's registration number.
        #[serde(
            rename = "registrationNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub registration_number: ::std::option::Option<::std::string::String>,
        ///The organization's VAT number.
        #[serde(
            rename = "vatNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_number: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PaymentRequestCompany> for PaymentRequestCompany {
        fn from(value: &PaymentRequestCompany) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PaymentRequestCompany {
        fn default() -> Self {
            Self {
                entity_type: Default::default(),
                registration_number: Default::default(),
                vat_number: Default::default(),
            }
        }
    }

    ///This optional field contains your customer's ISO 3166-1 alpha-2 country
    /// code, detected by us during checkout. This field is omitted if the
    /// country code was not detected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This optional field contains your customer's ISO 3166-1
    /// alpha-2 country code, detected by us during checkout. This\nfield is
    /// omitted if the country code was not detected.",
    ///  "readOnly": true,
    ///  "examples": [
    ///    "BE"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 2,
    ///  "minLength": 2
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PaymentRequestCountryCode(::std::string::String);
    impl ::std::ops::Deref for PaymentRequestCountryCode {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentRequestCountryCode> for ::std::string::String {
        fn from(value: PaymentRequestCountryCode) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentRequestCountryCode> for PaymentRequestCountryCode {
        fn from(value: &PaymentRequestCountryCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PaymentRequestCountryCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 2usize {
                return Err("longer than 2 characters".into());
            }
            if value.chars().count() < 2usize {
                return Err("shorter than 2 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentRequestCountryCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentRequestCountryCode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentRequestCountryCode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PaymentRequestCountryCode {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The description of the payment. This will be shown to your customer on
    /// their card or bank statement when possible. We truncate the
    /// description automatically according to the limits of the used payment
    /// method. The description is also visible in any exports you generate.
    ///
    ///We recommend you use a unique identifier so that you can always link the
    /// payment to the order in your back office. This is particularly
    /// useful for bookkeeping.
    ///
    ///The maximum length of the description field differs per payment method,
    /// with the absolute maximum being 255 characters. The API will not
    /// reject strings longer than the maximum length but it will truncate them
    /// to fit.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The description of the payment. This will be shown to
    /// your customer on their card or bank statement when possible.\nWe
    /// truncate the description automatically according to the limits of the
    /// used payment method. The description is\nalso visible in any exports you
    /// generate.\n\nWe recommend you use a unique identifier so that you can
    /// always link the payment to the order in your back office.\nThis is
    /// particularly useful for bookkeeping.\n\nThe maximum length of the
    /// description field differs per payment method, with the absolute maximum
    /// being 255\ncharacters. The API will not reject strings longer than the
    /// maximum length but it will truncate them to fit.",
    ///  "examples": [
    ///    "Chess Board"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PaymentRequestDescription(::std::string::String);
    impl ::std::ops::Deref for PaymentRequestDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentRequestDescription> for ::std::string::String {
        fn from(value: PaymentRequestDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentRequestDescription> for PaymentRequestDescription {
        fn from(value: &PaymentRequestDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PaymentRequestDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentRequestDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentRequestDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentRequestDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PaymentRequestDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///An object containing payment details collected during the payment
    /// process. For example, details may include the customer's card or
    /// bank details and a payment reference. For the full list of details,
    /// please refer to the [method-specific
    /// parameters](extra-payment-parameters) guide.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object containing payment details collected during
    /// the payment process. For example, details may include the\ncustomer's
    /// card or bank details and a payment reference. For the full list of
    /// details, please refer to the\n[method-specific
    /// parameters](extra-payment-parameters) guide.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "bankAccount": {
    ///      "description": "The bank account number the customer will need to
    /// make the bank transfer payment towards.",
    ///      "examples": [
    ///        "NL91ABNA0417164300"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "bankBic": {
    ///      "description": "The BIC of the bank the customer will need to make
    /// the bank transfer payment towards.",
    ///      "examples": [
    ///        "ABNANL2A"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "bankName": {
    ///      "description": "The name of the bank that the customer will need to
    /// make the bank transfer payment towards.",
    ///      "examples": [
    ///        "Mollie Bank"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "bankReason": {
    ///      "description": "A human-friendly description of the failure
    /// reason.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "bankReasonCode": {
    ///      "description": "The official reason why this payment has failed. A
    /// detailed description of each reason is available on the\nwebsite of the
    /// European Payments Council.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "batchReference": {
    ///      "description": "The batch reference you provided in the batch
    /// file.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "card3dsEci": {
    ///      "description": "The outcome of authentication attempted on
    /// transactions enforced by 3DS (ie valid only for oneoff and first).",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardAudition": {
    ///      "$ref": "#/components/schemas/payment-details-card-audition"
    ///    },
    ///    "cardBin": {
    ///      "description": "The first 6 digit of the card bank identification
    /// number.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardCountryCode": {
    ///      "description": "The ISO 3166-1 alpha-2 country code of the country
    /// the card was issued in.",
    ///      "examples": [
    ///        "NL"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardExpiryDate": {
    ///      "description": "The expiry date (MM/YY) of the card as displayed on
    /// the card.",
    ///      "examples": [
    ///        "12/25"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardFingerprint": {
    ///      "description": "A unique fingerprint for a specific card. Can be
    /// used to identify returning customers.\n\nIn the case of Point-of-sale
    /// payments, it's a unique identifier assigned to a cardholder's payment
    /// account,\nlinking multiple transactions from wallets and physical card
    /// to a single account, also across payment methods\nor when the card is
    /// reissued.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardFunding": {
    ///      "$ref": "#/components/schemas/payment-details-card-funding"
    ///    },
    ///    "cardHolder": {
    ///      "description": "The customer's name as shown on their card.",
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardIssuer": {
    ///      "description": "The issuer of the Card.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardLabel": {
    ///      "$ref": "#/components/schemas/payment-details-card-label"
    ///    },
    ///    "cardMaskedNumber": {
    ///      "description": "The first 6 and last 4 digits of the card number.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardNumber": {
    ///      "description": "For bancontact, it will be the customer's masked
    /// card number. For cards, it will be the last 4-digit of the\nPAN. For
    /// Point-of-sale, it will be the the last 4 digits of the customer's masked
    /// card number.",
    ///      "examples": [
    ///        "************1234"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "cardSecurity": {
    ///      "$ref": "#/components/schemas/payment-details-card-security"
    ///    },
    ///    "consumerAccount": {
    ///      "description": "The customer's account reference.\n\nFor
    /// banking-based payment methods — such as iDEAL — this is normally either
    /// an IBAN or a domestic bank account\nnumber.\n\nFor PayPal, the account
    /// reference is an email address.\n\nFor card and Bancontact payments,
    /// refer to details.cardNumber.",
    ///      "examples": [
    ///        "NL91ABNA0417164300"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "consumerBic": {
    ///      "description": "The BIC of the customer's bank account, if
    /// applicable.",
    ///      "examples": [
    ///        "ABNANL2A"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "consumerName": {
    ///      "description": "The customer's name, if made available by the
    /// payment method. For card payments, refer to details.cardHolder.",
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "creditorIdentifier": {
    ///      "description": "The creditor identifier indicates who is authorized to execute the payment. In this case, it is a\nreference to Mollie.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "customerReference": {
    ///      "description": "The paysafecard customer reference either provided
    /// via the API or otherwise auto-generated by Mollie.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "dueDate": {
    ///      "description": "Estimated date the payment is debited from the
    /// customer's bank account, in YYYY-MM-DD format.",
    ///      "examples": [
    ///        "2025-01-01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "date",
    ///      "x-methodSpecific": true
    ///    },
    ///    "endToEndIdentifier": {
    ///      "description": "The end-to-end identifier you provided in the batch
    /// file.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "failureMessage": {
    ///      "description": "A human-friendly failure message that can be shown
    /// to the customer. The message is translated in accordance\nwith the
    /// payment's locale setting.",
    ///      "examples": [
    ///        "Your card was declined."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "failureReason": {
    ///      "$ref": "#/components/schemas/payment-details-failure-reason"
    ///    },
    ///    "feeRegion": {
    ///      "$ref": "#/components/schemas/payment-details-fee-region"
    ///    },
    ///    "fileReference": {
    ///      "description": "The file reference you provided in the batch
    /// file.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "giftcards": {
    ///      "description": "An array of detail objects for each gift card that
    /// was used on this payment, if any.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "additionalProperties": true
    ///      },
    ///      "x-methodSpecific": true
    ///    },
    ///    "issuer": {
    ///      "description": "For payments with vouchers: the brand name of the
    /// first voucher applied.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "mandateReference": {
    ///      "description": "The mandate reference you provided in the batch
    /// file.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "maskedNumber": {
    ///      "description": "The first 6 digits & last 4 digits of the
    /// customer's masked card number.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "paypalFee": {
    ///      "$ref": "#/components/schemas/amount-nullable"
    ///    },
    ///    "paypalPayerId": {
    ///      "description": "ID of the customer's PayPal account.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "paypalReference": {
    ///      "description": "PayPal's reference for the payment.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "qrCode": {
    ///      "description": "Optional include. If a QR code was requested during
    /// payment creation for a QR-compatible payment method,\nthe QR code
    /// details will be available in this object.\n\nThe QR code can be scanned
    /// by the customer to complete the payment on their mobile device. For
    /// example,\nBancontact QR payments can be completed by the customer using
    /// the Bancontact app.",
    ///      "type": "object",
    ///      "properties": {
    ///        "height": {
    ///          "description": "The height of the QR code image in pixels.",
    ///          "examples": [
    ///            300
    ///          ],
    ///          "type": "integer"
    ///        },
    ///        "src": {
    ///          "description": "The URL to the QR code image. The image is a PNG file, and can be displayed directly in the browser or\ndownloaded.",
    ///          "examples": [
    ///            "https://www.mollie.com/images/qr-code.png"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "width": {
    ///          "description": "The width of the QR code image in pixels.",
    ///          "examples": [
    ///            300
    ///          ],
    ///          "type": "integer"
    ///        }
    ///      },
    ///      "x-methodSpecific": true
    ///    },
    ///    "receipt": {
    ///      "description": "The Point of sale receipt object.",
    ///      "type": "object",
    ///      "properties": {
    ///        "applicationIdentifier": {
    ///          "description": "The unique number that identifies a specific
    /// payment application on a chip card.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "authorizationCode": {
    ///          "description": "A unique code provided by the cardholder’s bank
    /// to confirm that the transaction was successfully approved.",
    ///          "examples": [
    ///            "..."
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "cardReadMethod": {
    ///          "$ref":
    /// "#/components/schemas/payment-details-receipt-card-read-method"
    ///        },
    ///        "cardVerificationMethod": {
    ///          "$ref":
    /// "#/components/schemas/payment-details-receipt-card-verification-method"
    ///        }
    ///      },
    ///      "x-methodSpecific": true
    ///    },
    ///    "remainderAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "remainderDetails": {
    ///      "description": "Optional include. The full payment method details
    /// of the remainder payment.",
    ///      "type": "object",
    ///      "additionalProperties": true,
    ///      "x-methodSpecific": true
    ///    },
    ///    "remainderMethod": {
    ///      "description": "The payment method used to pay the remainder
    /// amount, after all gift cards or vouchers were applied.",
    ///      "examples": [
    ///        "creditcard"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "sellerProtection": {
    ///      "$ref": "#/components/schemas/payment-details-seller-protection"
    ///    },
    ///    "shippingAddress": {
    ///      "description": "For wallet payment methods — such as Apple Pay and
    /// PayPal — the shipping address is often already known by the\nwallet
    /// provider. In these cases the shipping address may be available as a
    /// payment detail.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "additionalProperties": true,
    ///      "x-methodSpecific": true
    ///    },
    ///    "signatureDate": {
    ///      "description": "Date the payment has been signed by the customer, in YYYY-MM-DD format. Only available if the payment\nhas been signed.",
    ///      "examples": [
    ///        "2024-03-20"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "date",
    ///      "x-methodSpecific": true
    ///    },
    ///    "terminalId": {
    ///      "description": "The ID of the terminal device where the payment
    /// took place on.",
    ///      "examples": [
    ///        "term_12345"
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "transferReference": {
    ///      "description": "The Mollie-generated reference the customer needs
    /// to use when transfering the amount. Do not apply any\nformatting here;
    /// show it to the customer as-is.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "x-methodSpecific": true
    ///    },
    ///    "voucherNumber": {
    ///      "description": "For payments with gift cards: the masked gift card
    /// number of the first gift card applied to the payment.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": "string",
    ///      "x-methodSpecific": true
    ///    },
    ///    "vouchers": {
    ///      "description": "An array of detail objects for each voucher that
    /// was used on this payment, if any.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "additionalProperties": true
    ///      },
    ///      "x-methodSpecific": true
    ///    },
    ///    "wallet": {
    ///      "$ref": "#/components/schemas/payment-details-wallet"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentRequestDetails {
        ///The bank account number the customer will need to make the bank
        /// transfer payment towards.
        #[serde(
            rename = "bankAccount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub bank_account: ::std::option::Option<::std::string::String>,
        ///The BIC of the bank the customer will need to make the bank transfer
        /// payment towards.
        #[serde(
            rename = "bankBic",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub bank_bic: ::std::option::Option<::std::string::String>,
        ///The name of the bank that the customer will need to make the bank
        /// transfer payment towards.
        #[serde(
            rename = "bankName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub bank_name: ::std::option::Option<::std::string::String>,
        ///A human-friendly description of the failure reason.
        #[serde(
            rename = "bankReason",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub bank_reason: ::std::option::Option<::std::string::String>,
        ///The official reason why this payment has failed. A detailed
        /// description of each reason is available on the website of
        /// the European Payments Council.
        #[serde(
            rename = "bankReasonCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub bank_reason_code: ::std::option::Option<::std::string::String>,
        ///The batch reference you provided in the batch file.
        #[serde(
            rename = "batchReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub batch_reference: ::std::option::Option<::std::string::String>,
        ///The outcome of authentication attempted on transactions enforced by
        /// 3DS (ie valid only for oneoff and first).
        #[serde(
            rename = "card3dsEci",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card3ds_eci: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cardAudition",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_audition: ::std::option::Option<PaymentDetailsCardAudition>,
        ///The first 6 digit of the card bank identification number.
        #[serde(
            rename = "cardBin",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_bin: ::std::option::Option<::std::string::String>,
        ///The ISO 3166-1 alpha-2 country code of the country the card was
        /// issued in.
        #[serde(
            rename = "cardCountryCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_country_code: ::std::option::Option<::std::string::String>,
        ///The expiry date (MM/YY) of the card as displayed on the card.
        #[serde(
            rename = "cardExpiryDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_expiry_date: ::std::option::Option<::std::string::String>,
        ///A unique fingerprint for a specific card. Can be used to identify
        /// returning customers.
        ///
        ///In the case of Point-of-sale payments, it's a unique identifier
        /// assigned to a cardholder's payment account, linking multiple
        /// transactions from wallets and physical card to a single account,
        /// also across payment methods or when the card is reissued.
        #[serde(
            rename = "cardFingerprint",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_fingerprint: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cardFunding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_funding: ::std::option::Option<PaymentDetailsCardFunding>,
        ///The customer's name as shown on their card.
        #[serde(
            rename = "cardHolder",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_holder: ::std::option::Option<::std::string::String>,
        ///The issuer of the Card.
        #[serde(
            rename = "cardIssuer",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_issuer: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cardLabel",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_label: ::std::option::Option<PaymentDetailsCardLabel>,
        ///The first 6 and last 4 digits of the card number.
        #[serde(
            rename = "cardMaskedNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_masked_number: ::std::option::Option<::std::string::String>,
        ///For bancontact, it will be the customer's masked card number. For
        /// cards, it will be the last 4-digit of the
        /// PAN. For Point-of-sale, it will be the the last 4 digits of the
        /// customer's masked card number.
        #[serde(
            rename = "cardNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_number: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cardSecurity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_security: ::std::option::Option<PaymentDetailsCardSecurity>,
        ///The customer's account reference.
        ///
        ///For banking-based payment methods — such as iDEAL — this is normally
        /// either an IBAN or a domestic bank account number.
        ///
        ///For PayPal, the account reference is an email address.
        ///
        ///For card and Bancontact payments, refer to details.cardNumber.
        #[serde(
            rename = "consumerAccount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_account: ::std::option::Option<::std::string::String>,
        ///The BIC of the customer's bank account, if applicable.
        #[serde(
            rename = "consumerBic",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_bic: ::std::option::Option<::std::string::String>,
        ///The customer's name, if made available by the payment method. For
        /// card payments, refer to details.cardHolder.
        #[serde(
            rename = "consumerName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub consumer_name: ::std::option::Option<::std::string::String>,
        ///The creditor identifier indicates who is authorized to execute the
        /// payment. In this case, it is a reference to Mollie.
        #[serde(
            rename = "creditorIdentifier",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub creditor_identifier: ::std::option::Option<::std::string::String>,
        ///The paysafecard customer reference either provided via the API or
        /// otherwise auto-generated by Mollie.
        #[serde(
            rename = "customerReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub customer_reference: ::std::option::Option<::std::string::String>,
        ///Estimated date the payment is debited from the customer's bank
        /// account, in YYYY-MM-DD format.
        #[serde(
            rename = "dueDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub due_date: ::std::option::Option<::chrono::naive::NaiveDate>,
        ///The end-to-end identifier you provided in the batch file.
        #[serde(
            rename = "endToEndIdentifier",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub end_to_end_identifier: ::std::option::Option<::std::string::String>,
        ///A human-friendly failure message that can be shown to the customer.
        /// The message is translated in accordance with the payment's
        /// locale setting.
        #[serde(
            rename = "failureMessage",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub failure_message: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "failureReason",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub failure_reason: ::std::option::Option<PaymentDetailsFailureReason>,
        #[serde(
            rename = "feeRegion",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub fee_region: ::std::option::Option<PaymentDetailsFeeRegion>,
        ///The file reference you provided in the batch file.
        #[serde(
            rename = "fileReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub file_reference: ::std::option::Option<::std::string::String>,
        ///An array of detail objects for each gift card that was used on this
        /// payment, if any.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub giftcards:
            ::std::vec::Vec<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        ///For payments with vouchers: the brand name of the first voucher
        /// applied.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub issuer: ::std::option::Option<::std::string::String>,
        ///The mandate reference you provided in the batch file.
        #[serde(
            rename = "mandateReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub mandate_reference: ::std::option::Option<::std::string::String>,
        ///The first 6 digits & last 4 digits of the customer's masked card
        /// number.
        #[serde(
            rename = "maskedNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub masked_number: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paypalFee",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paypal_fee: ::std::option::Option<AmountNullable>,
        ///ID of the customer's PayPal account.
        #[serde(
            rename = "paypalPayerId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paypal_payer_id: ::std::option::Option<::std::string::String>,
        ///PayPal's reference for the payment.
        #[serde(
            rename = "paypalReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paypal_reference: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "qrCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub qr_code: ::std::option::Option<PaymentRequestDetailsQrCode>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub receipt: ::std::option::Option<PaymentRequestDetailsReceipt>,
        #[serde(
            rename = "remainderAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub remainder_amount: ::std::option::Option<Amount>,
        ///Optional include. The full payment method details of the remainder
        /// payment.
        #[serde(
            rename = "remainderDetails",
            default,
            skip_serializing_if = "::serde_json::Map::is_empty"
        )]
        pub remainder_details: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        ///The payment method used to pay the remainder amount, after all gift
        /// cards or vouchers were applied.
        #[serde(
            rename = "remainderMethod",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub remainder_method: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "sellerProtection",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub seller_protection: ::std::option::Option<PaymentDetailsSellerProtection>,
        ///For wallet payment methods — such as Apple Pay and PayPal — the
        /// shipping address is often already known by the
        /// wallet provider. In these cases the shipping address may be
        /// available as a payment detail.
        #[serde(
            rename = "shippingAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub shipping_address:
            ::std::option::Option<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        ///Date the payment has been signed by the customer, in YYYY-MM-DD
        /// format. Only available if the payment has been signed.
        #[serde(
            rename = "signatureDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub signature_date: ::std::option::Option<::chrono::naive::NaiveDate>,
        ///The ID of the terminal device where the payment took place on.
        #[serde(
            rename = "terminalId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub terminal_id: ::std::option::Option<::std::string::String>,
        ///The Mollie-generated reference the customer needs to use when
        /// transfering the amount. Do not apply any formatting here;
        /// show it to the customer as-is.
        #[serde(
            rename = "transferReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub transfer_reference: ::std::option::Option<::std::string::String>,
        ///For payments with gift cards: the masked gift card number of the
        /// first gift card applied to the payment.
        #[serde(
            rename = "voucherNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub voucher_number: ::std::option::Option<::std::string::String>,
        ///An array of detail objects for each voucher that was used on this
        /// payment, if any.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub vouchers:
            ::std::vec::Vec<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub wallet: ::std::option::Option<PaymentDetailsWallet>,
    }

    impl ::std::convert::From<&PaymentRequestDetails> for PaymentRequestDetails {
        fn from(value: &PaymentRequestDetails) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PaymentRequestDetails {
        fn default() -> Self {
            Self {
                bank_account: Default::default(),
                bank_bic: Default::default(),
                bank_name: Default::default(),
                bank_reason: Default::default(),
                bank_reason_code: Default::default(),
                batch_reference: Default::default(),
                card3ds_eci: Default::default(),
                card_audition: Default::default(),
                card_bin: Default::default(),
                card_country_code: Default::default(),
                card_expiry_date: Default::default(),
                card_fingerprint: Default::default(),
                card_funding: Default::default(),
                card_holder: Default::default(),
                card_issuer: Default::default(),
                card_label: Default::default(),
                card_masked_number: Default::default(),
                card_number: Default::default(),
                card_security: Default::default(),
                consumer_account: Default::default(),
                consumer_bic: Default::default(),
                consumer_name: Default::default(),
                creditor_identifier: Default::default(),
                customer_reference: Default::default(),
                due_date: Default::default(),
                end_to_end_identifier: Default::default(),
                failure_message: Default::default(),
                failure_reason: Default::default(),
                fee_region: Default::default(),
                file_reference: Default::default(),
                giftcards: Default::default(),
                issuer: Default::default(),
                mandate_reference: Default::default(),
                masked_number: Default::default(),
                paypal_fee: Default::default(),
                paypal_payer_id: Default::default(),
                paypal_reference: Default::default(),
                qr_code: Default::default(),
                receipt: Default::default(),
                remainder_amount: Default::default(),
                remainder_details: Default::default(),
                remainder_method: Default::default(),
                seller_protection: Default::default(),
                shipping_address: Default::default(),
                signature_date: Default::default(),
                terminal_id: Default::default(),
                transfer_reference: Default::default(),
                voucher_number: Default::default(),
                vouchers: Default::default(),
                wallet: Default::default(),
            }
        }
    }

    ///Optional include. If a QR code was requested during payment creation for
    /// a QR-compatible payment method, the QR code details will be
    /// available in this object.
    ///
    ///The QR code can be scanned by the customer to complete the payment on
    /// their mobile device. For example, Bancontact QR payments can be
    /// completed by the customer using the Bancontact app.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Optional include. If a QR code was requested during
    /// payment creation for a QR-compatible payment method,\nthe QR code
    /// details will be available in this object.\n\nThe QR code can be scanned
    /// by the customer to complete the payment on their mobile device. For
    /// example,\nBancontact QR payments can be completed by the customer using
    /// the Bancontact app.",
    ///  "type": "object",
    ///  "properties": {
    ///    "height": {
    ///      "description": "The height of the QR code image in pixels.",
    ///      "examples": [
    ///        300
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "src": {
    ///      "description": "The URL to the QR code image. The image is a PNG
    /// file, and can be displayed directly in the browser or\ndownloaded.",
    ///      "examples": [
    ///        "https://www.mollie.com/images/qr-code.png"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "width": {
    ///      "description": "The width of the QR code image in pixels.",
    ///      "examples": [
    ///        300
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  },
    ///  "x-methodSpecific": true
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentRequestDetailsQrCode {
        ///The height of the QR code image in pixels.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub height: ::std::option::Option<i64>,
        ///The URL to the QR code image. The image is a PNG file, and can be
        /// displayed directly in the browser or downloaded.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub src: ::std::option::Option<::std::string::String>,
        ///The width of the QR code image in pixels.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub width: ::std::option::Option<i64>,
    }

    impl ::std::convert::From<&PaymentRequestDetailsQrCode> for PaymentRequestDetailsQrCode {
        fn from(value: &PaymentRequestDetailsQrCode) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PaymentRequestDetailsQrCode {
        fn default() -> Self {
            Self {
                height: Default::default(),
                src: Default::default(),
                width: Default::default(),
            }
        }
    }

    ///The Point of sale receipt object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The Point of sale receipt object.",
    ///  "type": "object",
    ///  "properties": {
    ///    "applicationIdentifier": {
    ///      "description": "The unique number that identifies a specific
    /// payment application on a chip card.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "authorizationCode": {
    ///      "description": "A unique code provided by the cardholder’s bank to
    /// confirm that the transaction was successfully approved.",
    ///      "examples": [
    ///        "..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "cardReadMethod": {
    ///      "$ref":
    /// "#/components/schemas/payment-details-receipt-card-read-method"
    ///    },
    ///    "cardVerificationMethod": {
    ///      "$ref":
    /// "#/components/schemas/payment-details-receipt-card-verification-method"
    ///    }
    ///  },
    ///  "x-methodSpecific": true
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentRequestDetailsReceipt {
        ///The unique number that identifies a specific payment application on
        /// a chip card.
        #[serde(
            rename = "applicationIdentifier",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub application_identifier: ::std::option::Option<::std::string::String>,
        ///A unique code provided by the cardholder’s bank to confirm that the
        /// transaction was successfully approved.
        #[serde(
            rename = "authorizationCode",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub authorization_code: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cardReadMethod",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_read_method: ::std::option::Option<PaymentDetailsReceiptCardReadMethod>,
        #[serde(
            rename = "cardVerificationMethod",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_verification_method:
            ::std::option::Option<PaymentDetailsReceiptCardVerificationMethod>,
    }

    impl ::std::convert::From<&PaymentRequestDetailsReceipt> for PaymentRequestDetailsReceipt {
        fn from(value: &PaymentRequestDetailsReceipt) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PaymentRequestDetailsReceipt {
        fn default() -> Self {
            Self {
                application_identifier: Default::default(),
                authorization_code: Default::default(),
                card_read_method: Default::default(),
                card_verification_method: Default::default(),
            }
        }
    }

    ///`PaymentRequestLinesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/payment-line-item"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "recurring": {
    ///          "$ref": "#/components/schemas/recurring-line-item"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentRequestLinesItem {
        ///An array with the voucher categories, in case of a line eligible for
        /// a voucher. See the [Integrating Vouchers](https://docs.mollie.com/docs/integrating-vouchers/) guide for more information.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub categories: ::std::vec::Vec<LineCategories>,
        ///A description of the line item. For example *LEGO 4440 Forest Police
        /// Station*.
        pub description: ::std::string::String,
        #[serde(
            rename = "discountAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub discount_amount: ::std::option::Option<Amount>,
        ///A link pointing to an image of the product sold.
        #[serde(
            rename = "imageUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub image_url: ::std::option::Option<::std::string::String>,
        ///A link pointing to the product page in your web shop of the product
        /// sold.
        #[serde(
            rename = "productUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub product_url: ::std::option::Option<::std::string::String>,
        ///The number of items.
        pub quantity: ::std::num::NonZeroU64,
        ///The unit for the quantity. For example *pcs*, *kg*, or *cm*.
        #[serde(
            rename = "quantityUnit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub quantity_unit: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub recurring: ::std::option::Option<RecurringLineItem>,
        ///The SKU, EAN, ISBN or UPC of the product sold.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sku: ::std::option::Option<PaymentRequestLinesItemSku>,
        #[serde(rename = "totalAmount")]
        pub total_amount: Amount,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<PaymentLineType>,
        #[serde(rename = "unitPrice")]
        pub unit_price: Amount,
        #[serde(
            rename = "vatAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_amount: ::std::option::Option<Amount>,
        ///The VAT rate applied to the line, for example `21.00` for 21%. The
        /// vatRate should be passed as a string and not as a float, to
        /// ensure the correct number of decimals are passed.
        #[serde(
            rename = "vatRate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_rate: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PaymentRequestLinesItem> for PaymentRequestLinesItem {
        fn from(value: &PaymentRequestLinesItem) -> Self {
            value.clone()
        }
    }

    ///The SKU, EAN, ISBN or UPC of the product sold.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The SKU, EAN, ISBN or UPC of the product sold.",
    ///  "examples": [
    ///    "9780241661628"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 64
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PaymentRequestLinesItemSku(::std::string::String);
    impl ::std::ops::Deref for PaymentRequestLinesItemSku {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentRequestLinesItemSku> for ::std::string::String {
        fn from(value: PaymentRequestLinesItemSku) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentRequestLinesItemSku> for PaymentRequestLinesItemSku {
        fn from(value: &PaymentRequestLinesItemSku) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PaymentRequestLinesItemSku {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 64usize {
                return Err("longer than 64 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentRequestLinesItemSku {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentRequestLinesItemSku {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentRequestLinesItemSku {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PaymentRequestLinesItemSku {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "dashboard",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "captures": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "changePaymentState": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "chargebacks": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "checkout": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "customer": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "dashboard": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "mandate": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "mobileAppCheckout": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "order": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "payOnline": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "refunds": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "settlement": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "subscription": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "terminal": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentRequestLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub captures: ::std::option::Option<Url>,
        #[serde(
            rename = "changePaymentState",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub change_payment_state: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chargebacks: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub checkout: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub customer: ::std::option::Option<Url>,
        pub dashboard: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mandate: ::std::option::Option<Url>,
        #[serde(
            rename = "mobileAppCheckout",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub mobile_app_checkout: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub order: ::std::option::Option<Url>,
        #[serde(
            rename = "payOnline",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub pay_online: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub refunds: ::std::option::Option<Url>,
        #[serde(rename = "self")]
        pub self_: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub settlement: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub subscription: ::std::option::Option<Url>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub terminal: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&PaymentRequestLinks> for PaymentRequestLinks {
        fn from(value: &PaymentRequestLinks) -> Self {
            value.clone()
        }
    }

    ///`PaymentResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/entity-payment-response"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "method": {
    ///          "$ref": "#/components/schemas/method-response"
    ///        }
    ///      }
    ///    }
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PaymentResponse(pub EntityPaymentResponse);
    impl ::std::ops::Deref for PaymentResponse {
        type Target = EntityPaymentResponse;
        fn deref(&self) -> &EntityPaymentResponse {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentResponse> for EntityPaymentResponse {
        fn from(value: PaymentResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentResponse> for PaymentResponse {
        fn from(value: &PaymentResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<EntityPaymentResponse> for PaymentResponse {
        fn from(value: EntityPaymentResponse) -> Self {
            Self(value)
        }
    }

    ///The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
    ///statuses occur at what point.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which\nstatuses occur at what point.",
    ///  "readOnly": true,
    ///  "examples": [
    ///    "open"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "open",
    ///    "pending",
    ///    "authorized",
    ///    "paid",
    ///    "canceled",
    ///    "expired",
    ///    "failed"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentStatus {
        #[serde(rename = "open")]
        Open,
        #[serde(rename = "pending")]
        Pending,
        #[serde(rename = "authorized")]
        Authorized,
        #[serde(rename = "paid")]
        Paid,
        #[serde(rename = "canceled")]
        Canceled,
        #[serde(rename = "expired")]
        Expired,
        #[serde(rename = "failed")]
        Failed,
    }

    impl ::std::convert::From<&Self> for PaymentStatus {
        fn from(value: &PaymentStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Open => f.write_str("open"),
                Self::Pending => f.write_str("pending"),
                Self::Authorized => f.write_str("authorized"),
                Self::Paid => f.write_str("paid"),
                Self::Canceled => f.write_str("canceled"),
                Self::Expired => f.write_str("expired"),
                Self::Failed => f.write_str("failed"),
            }
        }
    }

    impl ::std::str::FromStr for PaymentStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "open" => Ok(Self::Open),
                "pending" => Ok(Self::Pending),
                "authorized" => Ok(Self::Authorized),
                "paid" => Ok(Self::Paid),
                "canceled" => Ok(Self::Canceled),
                "expired" => Ok(Self::Expired),
                "failed" => Ok(Self::Failed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaymentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaymentStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaymentStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PaymentToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "tr_5B8cwPMGnU"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct PaymentToken(pub ::std::string::String);
    impl ::std::ops::Deref for PaymentToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PaymentToken> for ::std::string::String {
        fn from(value: PaymentToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PaymentToken> for PaymentToken {
        fn from(value: &PaymentToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for PaymentToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for PaymentToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for PaymentToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`PermissionToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "payments.read"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct PermissionToken(pub ::std::string::String);
    impl ::std::ops::Deref for PermissionToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PermissionToken> for ::std::string::String {
        fn from(value: PermissionToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PermissionToken> for PermissionToken {
        fn from(value: &PermissionToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for PermissionToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for PermissionToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for PermissionToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///The status of the requested changes.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status of the requested changes.",
    ///  "examples": [
    ///    "pending"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "pending",
    ///    "rejected"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ProfileReviewStatus {
        #[serde(rename = "pending")]
        Pending,
        #[serde(rename = "rejected")]
        Rejected,
    }

    impl ::std::convert::From<&Self> for ProfileReviewStatus {
        fn from(value: &ProfileReviewStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ProfileReviewStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Pending => f.write_str("pending"),
                Self::Rejected => f.write_str("rejected"),
            }
        }
    }

    impl ::std::str::FromStr for ProfileReviewStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "pending" => Ok(Self::Pending),
                "rejected" => Ok(Self::Rejected),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ProfileReviewStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ProfileReviewStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ProfileReviewStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The status of the requested changes.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status of the requested changes.",
    ///  "examples": [
    ///    "pending"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "pending",
    ///    "rejected"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ProfileReviewStatusResponse {
        #[serde(rename = "pending")]
        Pending,
        #[serde(rename = "rejected")]
        Rejected,
    }

    impl ::std::convert::From<&Self> for ProfileReviewStatusResponse {
        fn from(value: &ProfileReviewStatusResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ProfileReviewStatusResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Pending => f.write_str("pending"),
                Self::Rejected => f.write_str("rejected"),
            }
        }
    }

    impl ::std::str::FromStr for ProfileReviewStatusResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "pending" => Ok(Self::Pending),
                "rejected" => Ok(Self::Rejected),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ProfileReviewStatusResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ProfileReviewStatusResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ProfileReviewStatusResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The profile status determines whether the profile is able to receive
    /// live payments.
    ///
    /// * `unverified`: The profile has not been verified yet and can only be
    ///   used to create test payments.
    /// * `verified`: The profile has been verified and can be used to create
    ///   live payments and test payments.
    /// * `blocked`: The profile is blocked and can no longer be used or
    ///   changed.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The profile status determines whether the profile is
    /// able to receive live payments.\n\n* `unverified`: The profile has not
    /// been verified yet and can only be used to create test payments.\n*
    /// `verified`: The profile has been verified and can be used to create live
    /// payments and test payments.\n* `blocked`: The profile is blocked and can
    /// no longer be used or changed.",
    ///  "examples": [
    ///    "unverified"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "unverified",
    ///    "verified",
    ///    "blocked"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ProfileStatus {
        #[serde(rename = "unverified")]
        Unverified,
        #[serde(rename = "verified")]
        Verified,
        #[serde(rename = "blocked")]
        Blocked,
    }

    impl ::std::convert::From<&Self> for ProfileStatus {
        fn from(value: &ProfileStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ProfileStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Unverified => f.write_str("unverified"),
                Self::Verified => f.write_str("verified"),
                Self::Blocked => f.write_str("blocked"),
            }
        }
    }

    impl ::std::str::FromStr for ProfileStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "unverified" => Ok(Self::Unverified),
                "verified" => Ok(Self::Verified),
                "blocked" => Ok(Self::Blocked),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ProfileStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ProfileStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ProfileStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The identifier referring to the [profile](get-profile) this entity
    /// belongs to.
    ///
    ///Most API credentials are linked to a single profile. In these cases the
    /// `profileId` can be omitted in the creation request. For
    /// organization-level credentials such as OAuth access tokens however, the
    /// `profileId` parameter is required.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The identifier referring to the [profile](get-profile)
    /// this entity belongs to.\n\nMost API credentials are linked to a single
    /// profile. In these cases the `profileId` can be omitted in the
    /// creation\nrequest. For organization-level credentials such as OAuth
    /// access tokens however, the `profileId` parameter is\nrequired.",
    ///  "examples": [
    ///    "pfl_5B8cwPMGnU"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct ProfileToken(pub ::std::string::String);
    impl ::std::ops::Deref for ProfileToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<ProfileToken> for ::std::string::String {
        fn from(value: ProfileToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&ProfileToken> for ProfileToken {
        fn from(value: &ProfileToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for ProfileToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for ProfileToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for ProfileToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`RecurringLineItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "interval"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "description": {
    ///      "description": "A description of the recurring item. If not
    /// present, the main description of the item will be used.",
    ///      "examples": [
    ///        "Gym subscription"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interval": {
    ///      "description": "Cadence unit of the recurring item. For example:
    /// `12 months`, `52 weeks` or `365 days`.\n\nPossible values: `... days`,
    /// `... weeks`, `... months`.",
    ///      "examples": [
    ///        "12 months"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^(\\d+) (months?|weeks?|days?)$"
    ///    },
    ///    "startDate": {
    ///      "description": "The start date of the subscription if it does not
    /// start right away (format `YYYY-MM-DD`)",
    ///      "examples": [
    ///        "2024-12-12"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "times": {
    ///      "description": "Total number of charges for the subscription to
    /// complete. Leave empty for ongoing subscription.",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RecurringLineItem {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<Amount>,
        ///A description of the recurring item. If not present, the main
        /// description of the item will be used.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        ///Cadence unit of the recurring item. For example: `12 months`, `52
        /// weeks` or `365 days`.
        ///
        ///Possible values: `... days`, `... weeks`, `... months`.
        pub interval: RecurringLineItemInterval,
        ///The start date of the subscription if it does not start right away
        /// (format `YYYY-MM-DD`)
        #[serde(
            rename = "startDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub start_date: ::std::option::Option<::std::string::String>,
        ///Total number of charges for the subscription to complete. Leave
        /// empty for ongoing subscription.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub times: ::std::option::Option<i64>,
    }

    impl ::std::convert::From<&RecurringLineItem> for RecurringLineItem {
        fn from(value: &RecurringLineItem) -> Self {
            value.clone()
        }
    }

    ///Cadence unit of the recurring item. For example: `12 months`, `52 weeks`
    /// or `365 days`.
    ///
    ///Possible values: `... days`, `... weeks`, `... months`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Cadence unit of the recurring item. For example: `12
    /// months`, `52 weeks` or `365 days`.\n\nPossible values: `... days`, `...
    /// weeks`, `... months`.",
    ///  "examples": [
    ///    "12 months"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(\\d+) (months?|weeks?|days?)$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct RecurringLineItemInterval(::std::string::String);
    impl ::std::ops::Deref for RecurringLineItemInterval {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<RecurringLineItemInterval> for ::std::string::String {
        fn from(value: RecurringLineItemInterval) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&RecurringLineItemInterval> for RecurringLineItemInterval {
        fn from(value: &RecurringLineItemInterval) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for RecurringLineItemInterval {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^(\\d+) (months?|weeks?|days?)$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^(\\d+) (months?|weeks?|days?)$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for RecurringLineItemInterval {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RecurringLineItemInterval {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RecurringLineItemInterval {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for RecurringLineItemInterval {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The URL your customer will be redirected to after the payment process.
    ///
    ///It could make sense for the redirectUrl to contain a unique identifier –
    /// like your order ID – so you can show the right page referencing the
    /// order when your customer returns.
    ///
    ///The parameter is normally required, but can be omitted for recurring
    /// payments (`sequenceType: recurring`) and for Apple Pay payments with
    /// an `applePayPaymentToken`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The URL your customer will be redirected to after the
    /// payment process.\n\nIt could make sense for the redirectUrl to contain a
    /// unique identifier – like your order ID – so you can show the\nright page
    /// referencing the order when your customer returns.\n\nThe parameter is
    /// normally required, but can be omitted for recurring payments
    /// (`sequenceType: recurring`) and for\nApple Pay payments with an
    /// `applePayPaymentToken`.",
    ///  "examples": [
    ///    "https://example.org/redirect"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct RedirectUrl(pub ::std::option::Option<::std::string::String>);
    impl ::std::ops::Deref for RedirectUrl {
        type Target = ::std::option::Option<::std::string::String>;
        fn deref(&self) -> &::std::option::Option<::std::string::String> {
            &self.0
        }
    }

    impl ::std::convert::From<RedirectUrl> for ::std::option::Option<::std::string::String> {
        fn from(value: RedirectUrl) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&RedirectUrl> for RedirectUrl {
        fn from(value: &RedirectUrl) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<::std::string::String>> for RedirectUrl {
        fn from(value: ::std::option::Option<::std::string::String>) -> Self {
            Self(value)
        }
    }

    ///Specifies the reference type
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Specifies the reference type",
    ///  "examples": [
    ///    "acquirer-reference"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "acquirer-reference"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RefundExternalReferenceType {
        #[serde(rename = "acquirer-reference")]
        AcquirerReference,
    }

    impl ::std::convert::From<&Self> for RefundExternalReferenceType {
        fn from(value: &RefundExternalReferenceType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for RefundExternalReferenceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AcquirerReference => f.write_str("acquirer-reference"),
            }
        }
    }

    impl ::std::str::FromStr for RefundExternalReferenceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "acquirer-reference" => Ok(Self::AcquirerReference),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for RefundExternalReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RefundExternalReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RefundExternalReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Specifies the reference type
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Specifies the reference type",
    ///  "examples": [
    ///    "acquirer-reference"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "acquirer-reference"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RefundExternalReferenceTypeResponse {
        #[serde(rename = "acquirer-reference")]
        AcquirerReference,
    }

    impl ::std::convert::From<&Self> for RefundExternalReferenceTypeResponse {
        fn from(value: &RefundExternalReferenceTypeResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for RefundExternalReferenceTypeResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AcquirerReference => f.write_str("acquirer-reference"),
            }
        }
    }

    impl ::std::str::FromStr for RefundExternalReferenceTypeResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "acquirer-reference" => Ok(Self::AcquirerReference),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for RefundExternalReferenceTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RefundExternalReferenceTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RefundExternalReferenceTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`RefundRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/entity-refund"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct RefundRequest(pub EntityRefund);
    impl ::std::ops::Deref for RefundRequest {
        type Target = EntityRefund;
        fn deref(&self) -> &EntityRefund {
            &self.0
        }
    }

    impl ::std::convert::From<RefundRequest> for EntityRefund {
        fn from(value: RefundRequest) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&RefundRequest> for RefundRequest {
        fn from(value: &RefundRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<EntityRefund> for RefundRequest {
        fn from(value: EntityRefund) -> Self {
            Self(value)
        }
    }

    ///The type of source. Currently only the source type `organization` is
    /// supported.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of source. Currently only the source type
    /// `organization` is supported.",
    ///  "examples": [
    ///    "organization"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "organization"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RefundRoutingReversalsSourceType {
        #[serde(rename = "organization")]
        Organization,
    }

    impl ::std::convert::From<&Self> for RefundRoutingReversalsSourceType {
        fn from(value: &RefundRoutingReversalsSourceType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for RefundRoutingReversalsSourceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Organization => f.write_str("organization"),
            }
        }
    }

    impl ::std::str::FromStr for RefundRoutingReversalsSourceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "organization" => Ok(Self::Organization),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for RefundRoutingReversalsSourceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RefundRoutingReversalsSourceType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RefundRoutingReversalsSourceType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`RefundStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "queued"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "queued",
    ///    "pending",
    ///    "processing",
    ///    "refunded",
    ///    "failed",
    ///    "canceled"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RefundStatus {
        #[serde(rename = "queued")]
        Queued,
        #[serde(rename = "pending")]
        Pending,
        #[serde(rename = "processing")]
        Processing,
        #[serde(rename = "refunded")]
        Refunded,
        #[serde(rename = "failed")]
        Failed,
        #[serde(rename = "canceled")]
        Canceled,
    }

    impl ::std::convert::From<&Self> for RefundStatus {
        fn from(value: &RefundStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for RefundStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Queued => f.write_str("queued"),
                Self::Pending => f.write_str("pending"),
                Self::Processing => f.write_str("processing"),
                Self::Refunded => f.write_str("refunded"),
                Self::Failed => f.write_str("failed"),
                Self::Canceled => f.write_str("canceled"),
            }
        }
    }

    impl ::std::str::FromStr for RefundStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "queued" => Ok(Self::Queued),
                "pending" => Ok(Self::Pending),
                "processing" => Ok(Self::Processing),
                "refunded" => Ok(Self::Refunded),
                "failed" => Ok(Self::Failed),
                "canceled" => Ok(Self::Canceled),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for RefundStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RefundStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RefundStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`RefundToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "re_5B8cwPMGnU"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct RefundToken(pub ::std::string::String);
    impl ::std::ops::Deref for RefundToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<RefundToken> for ::std::string::String {
        fn from(value: RefundToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&RefundToken> for RefundToken {
        fn from(value: &RefundToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for RefundToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for RefundToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for RefundToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`ReleaseAuthorizationBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "profileId": {
    ///      "$ref": "#/components/schemas/profileToken"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReleaseAuthorizationBody {
        #[serde(
            rename = "profileId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub profile_id: ::std::option::Option<ProfileToken>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
    }

    impl ::std::convert::From<&ReleaseAuthorizationBody> for ReleaseAuthorizationBody {
        fn from(value: &ReleaseAuthorizationBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ReleaseAuthorizationBody {
        fn default() -> Self {
            Self {
                profile_id: Default::default(),
                testmode: Default::default(),
            }
        }
    }

    ///`RequestApplePayPaymentSessionBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "domain",
    ///    "validationUrl"
    ///  ],
    ///  "properties": {
    ///    "domain": {
    ///      "description": "The domain of your web shop, that is visible in the
    /// browser's location bar. For example\n`pay.myshop.com`.",
    ///      "examples": [
    ///        "pay.myshop.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "profileId": {
    ///      "$ref": "#/components/schemas/profileToken"
    ///    },
    ///    "validationUrl": {
    ///      "description": "The validationUrl you got from the\n[ApplePayValidateMerchant event](https://developer.apple.com/documentation/apple_pay_on_the_web/applepayvalidatemerchantevent).\n\nA list of all\n[valid host names](https://developer.apple.com/documentation/apple_pay_on_the_web/setting_up_your_server)\nfor merchant validation is available. You should white list these in your application and reject any\n`validationUrl`s that have a host name not in the list.",
    ///      "examples": [
    ///        "https://apple-pay-gateway-cert.apple.com/paymentservices/paymentSession"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RequestApplePayPaymentSessionBody {
        ///The domain of your web shop, that is visible in the browser's
        /// location bar. For example `pay.myshop.com`.
        pub domain: ::std::string::String,
        #[serde(
            rename = "profileId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub profile_id: ::std::option::Option<ProfileToken>,
        ///The validationUrl you got from the
        ///[ApplePayValidateMerchant event](https://developer.apple.com/documentation/apple_pay_on_the_web/applepayvalidatemerchantevent).
        ///
        ///A list of all
        ///[valid host names](https://developer.apple.com/documentation/apple_pay_on_the_web/setting_up_your_server)
        ///for merchant validation is available. You should white list these in
        /// your application and reject any `validationUrl`s that have a
        /// host name not in the list.
        #[serde(rename = "validationUrl")]
        pub validation_url: ::std::string::String,
    }

    impl ::std::convert::From<&RequestApplePayPaymentSessionBody>
        for RequestApplePayPaymentSessionBody
    {
        fn from(value: &RequestApplePayPaymentSessionBody) -> Self {
            value.clone()
        }
    }

    ///For digital goods in most jurisdictions, you must apply the VAT rate
    /// from your customer's country. Choose the VAT rates you have used for
    /// the order to ensure your customer's country matches the VAT country.
    ///
    ///Use this parameter to restrict the payment methods available to your
    /// customer to those from a single country.
    ///
    ///If available, the credit card method will still be offered, but only
    /// cards from the allowed country are accepted.
    ///
    ///The field expects a country code in ISO 3166-1 alpha-2 format, for
    /// example `NL`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "For digital goods in most jurisdictions, you must apply
    /// the VAT rate from your customer's country. Choose the VAT\nrates you
    /// have used for the order to ensure your customer's country matches the
    /// VAT country.\n\nUse this parameter to restrict the payment methods
    /// available to your customer to those from a single country.\n\nIf
    /// available, the credit card method will still be offered, but only cards
    /// from the allowed country are accepted.\n\nThe field expects a country
    /// code in ISO 3166-1 alpha-2 format, for example `NL`.",
    ///  "examples": [
    ///    "NL"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct RestrictPaymentMethodsToCountry(pub ::std::option::Option<::std::string::String>);
    impl ::std::ops::Deref for RestrictPaymentMethodsToCountry {
        type Target = ::std::option::Option<::std::string::String>;
        fn deref(&self) -> &::std::option::Option<::std::string::String> {
            &self.0
        }
    }

    impl ::std::convert::From<RestrictPaymentMethodsToCountry>
        for ::std::option::Option<::std::string::String>
    {
        fn from(value: RestrictPaymentMethodsToCountry) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&RestrictPaymentMethodsToCountry> for RestrictPaymentMethodsToCountry {
        fn from(value: &RestrictPaymentMethodsToCountry) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<::std::string::String>>
        for RestrictPaymentMethodsToCountry
    {
        fn from(value: ::std::option::Option<::std::string::String>) -> Self {
            Self(value)
        }
    }

    ///`RevokeMandateBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RevokeMandateBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<Testmode>,
    }

    impl ::std::convert::From<&RevokeMandateBody> for RevokeMandateBody {
        fn from(value: &RevokeMandateBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for RevokeMandateBody {
        fn default() -> Self {
            Self {
                testmode: Default::default(),
            }
        }
    }

    ///`RouteCreateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "documentation",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "description": {
    ///      "description": "The description of the route. This description is
    /// shown in the reports.",
    ///      "examples": [
    ///        "Payment for Order #12345"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "destination": {
    ///      "description": "The destination of the route.",
    ///      "type": "object",
    ///      "required": [
    ///        "organizationId",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "organizationId": {
    ///          "$ref": "#/components/schemas/organizationToken"
    ///        },
    ///        "type": {
    ///          "$ref": "#/components/schemas/route-destination-type"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/connectRouteToken"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a route object.
    /// Will always contain the string `route` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "route"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RouteCreateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<Amount>,
        ///The description of the route. This description is shown in the
        /// reports.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<RouteCreateRequestDescription>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub destination: ::std::option::Option<RouteCreateRequestDestination>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<ConnectRouteToken>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<RouteCreateRequestLinks>,
        #[serde(
            rename = "paymentId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_id: ::std::option::Option<PaymentToken>,
        ///Indicates the response contains a route object. Will always contain
        /// the string `route` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
    }

    impl ::std::convert::From<&RouteCreateRequest> for RouteCreateRequest {
        fn from(value: &RouteCreateRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for RouteCreateRequest {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                description: Default::default(),
                destination: Default::default(),
                id: Default::default(),
                links: Default::default(),
                payment_id: Default::default(),
                resource: Default::default(),
                testmode: Default::default(),
            }
        }
    }

    ///The description of the route. This description is shown in the reports.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The description of the route. This description is shown
    /// in the reports.",
    ///  "examples": [
    ///    "Payment for Order #12345"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct RouteCreateRequestDescription(::std::string::String);
    impl ::std::ops::Deref for RouteCreateRequestDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<RouteCreateRequestDescription> for ::std::string::String {
        fn from(value: RouteCreateRequestDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&RouteCreateRequestDescription> for RouteCreateRequestDescription {
        fn from(value: &RouteCreateRequestDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for RouteCreateRequestDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for RouteCreateRequestDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RouteCreateRequestDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RouteCreateRequestDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for RouteCreateRequestDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The destination of the route.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The destination of the route.",
    ///  "type": "object",
    ///  "required": [
    ///    "organizationId",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "organizationId": {
    ///      "$ref": "#/components/schemas/organizationToken"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/route-destination-type"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RouteCreateRequestDestination {
        #[serde(rename = "organizationId")]
        pub organization_id: OrganizationToken,
        #[serde(rename = "type")]
        pub type_: RouteDestinationType,
    }

    impl ::std::convert::From<&RouteCreateRequestDestination> for RouteCreateRequestDestination {
        fn from(value: &RouteCreateRequestDestination) -> Self {
            value.clone()
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "documentation",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RouteCreateRequestLinks {
        pub documentation: Url,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&RouteCreateRequestLinks> for RouteCreateRequestLinks {
        fn from(value: &RouteCreateRequestLinks) -> Self {
            value.clone()
        }
    }

    ///`RouteCreateResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_links",
    ///    "amount",
    ///    "description",
    ///    "destination",
    ///    "id",
    ///    "paymentId",
    ///    "resource"
    ///  ],
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "documentation",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "description": {
    ///      "description": "The description of the route. This description is
    /// shown in the reports.",
    ///      "examples": [
    ///        "Payment for Order #12345"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "destination": {
    ///      "description": "The destination of the route.",
    ///      "type": "object",
    ///      "required": [
    ///        "organizationId",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "organizationId": {
    ///          "$ref": "#/components/schemas/organizationToken"
    ///        },
    ///        "type": {
    ///          "$ref": "#/components/schemas/route-destination-type-response"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/connectRouteToken"
    ///    },
    ///    "paymentId": {
    ///      "$ref": "#/components/schemas/paymentToken"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a route object.
    /// Will always contain the string `route` for this endpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "route"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RouteCreateResponse {
        pub amount: Amount,
        ///The description of the route. This description is shown in the
        /// reports.
        pub description: RouteCreateResponseDescription,
        pub destination: RouteCreateResponseDestination,
        pub id: ConnectRouteToken,
        #[serde(rename = "_links")]
        pub links: RouteCreateResponseLinks,
        #[serde(rename = "paymentId")]
        pub payment_id: PaymentToken,
        ///Indicates the response contains a route object. Will always contain
        /// the string `route` for this endpoint.
        pub resource: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
    }

    impl ::std::convert::From<&RouteCreateResponse> for RouteCreateResponse {
        fn from(value: &RouteCreateResponse) -> Self {
            value.clone()
        }
    }

    ///The description of the route. This description is shown in the reports.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The description of the route. This description is shown
    /// in the reports.",
    ///  "examples": [
    ///    "Payment for Order #12345"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct RouteCreateResponseDescription(::std::string::String);
    impl ::std::ops::Deref for RouteCreateResponseDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<RouteCreateResponseDescription> for ::std::string::String {
        fn from(value: RouteCreateResponseDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&RouteCreateResponseDescription> for RouteCreateResponseDescription {
        fn from(value: &RouteCreateResponseDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for RouteCreateResponseDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for RouteCreateResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RouteCreateResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RouteCreateResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for RouteCreateResponseDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The destination of the route.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The destination of the route.",
    ///  "type": "object",
    ///  "required": [
    ///    "organizationId",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "organizationId": {
    ///      "$ref": "#/components/schemas/organizationToken"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/route-destination-type-response"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RouteCreateResponseDestination {
        #[serde(rename = "organizationId")]
        pub organization_id: OrganizationToken,
        #[serde(rename = "type")]
        pub type_: RouteDestinationTypeResponse,
    }

    impl ::std::convert::From<&RouteCreateResponseDestination> for RouteCreateResponseDestination {
        fn from(value: &RouteCreateResponseDestination) -> Self {
            value.clone()
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "documentation",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RouteCreateResponseLinks {
        pub documentation: Url,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&RouteCreateResponseLinks> for RouteCreateResponseLinks {
        fn from(value: &RouteCreateResponseLinks) -> Self {
            value.clone()
        }
    }

    ///The type of destination. Currently only the destination type
    /// `organization` is supported.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of destination. Currently only the destination
    /// type `organization` is supported.",
    ///  "examples": [
    ///    "organization"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "organization"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RouteDestinationType {
        #[serde(rename = "organization")]
        Organization,
    }

    impl ::std::convert::From<&Self> for RouteDestinationType {
        fn from(value: &RouteDestinationType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for RouteDestinationType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Organization => f.write_str("organization"),
            }
        }
    }

    impl ::std::str::FromStr for RouteDestinationType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "organization" => Ok(Self::Organization),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for RouteDestinationType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RouteDestinationType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RouteDestinationType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The type of destination. Currently only the destination type
    /// `organization` is supported.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of destination. Currently only the destination
    /// type `organization` is supported.",
    ///  "examples": [
    ///    "organization"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "organization"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RouteDestinationTypeResponse {
        #[serde(rename = "organization")]
        Organization,
    }

    impl ::std::convert::From<&Self> for RouteDestinationTypeResponse {
        fn from(value: &RouteDestinationTypeResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for RouteDestinationTypeResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Organization => f.write_str("organization"),
            }
        }
    }

    impl ::std::str::FromStr for RouteDestinationTypeResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "organization" => Ok(Self::Organization),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for RouteDestinationTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RouteDestinationTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RouteDestinationTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`RouteGetResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/entity-route"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "createdAt": {
    ///          "$ref": "#/components/schemas/created-at"
    ///        }
    ///      }
    ///    }
    ///  ],
    ///  "required": [
    ///    "_links",
    ///    "amount",
    ///    "createdAt",
    ///    "description",
    ///    "destination",
    ///    "id",
    ///    "paymentId",
    ///    "resource"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RouteGetResponse {
        pub amount: Amount,
        #[serde(rename = "createdAt")]
        pub created_at: CreatedAt,
        ///The description of the route. This description is shown in the
        /// reports.
        pub description: RouteGetResponseDescription,
        pub destination: RouteGetResponseDestination,
        pub id: ConnectRouteToken,
        #[serde(rename = "_links")]
        pub links: RouteGetResponseLinks,
        #[serde(rename = "paymentId")]
        pub payment_id: PaymentToken,
        ///Indicates the response contains a route object. Will always contain
        /// the string `route` for this endpoint.
        pub resource: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
    }

    impl ::std::convert::From<&RouteGetResponse> for RouteGetResponse {
        fn from(value: &RouteGetResponse) -> Self {
            value.clone()
        }
    }

    ///The description of the route. This description is shown in the reports.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The description of the route. This description is shown
    /// in the reports.",
    ///  "examples": [
    ///    "Payment for Order #12345"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct RouteGetResponseDescription(::std::string::String);
    impl ::std::ops::Deref for RouteGetResponseDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<RouteGetResponseDescription> for ::std::string::String {
        fn from(value: RouteGetResponseDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&RouteGetResponseDescription> for RouteGetResponseDescription {
        fn from(value: &RouteGetResponseDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for RouteGetResponseDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for RouteGetResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RouteGetResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RouteGetResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for RouteGetResponseDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The destination of the route.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The destination of the route.",
    ///  "type": "object",
    ///  "required": [
    ///    "organizationId",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "organizationId": {
    ///      "$ref": "#/components/schemas/organizationToken"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/route-destination-type-response"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RouteGetResponseDestination {
        #[serde(rename = "organizationId")]
        pub organization_id: OrganizationToken,
        #[serde(rename = "type")]
        pub type_: RouteDestinationTypeResponse,
    }

    impl ::std::convert::From<&RouteGetResponseDestination> for RouteGetResponseDestination {
        fn from(value: &RouteGetResponseDestination) -> Self {
            value.clone()
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "documentation",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RouteGetResponseLinks {
        pub documentation: Url,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&RouteGetResponseLinks> for RouteGetResponseLinks {
        fn from(value: &RouteGetResponseLinks) -> Self {
            value.clone()
        }
    }

    ///`RouteToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "rt_5B8cwPMGnU"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct RouteToken(pub ::std::string::String);
    impl ::std::ops::Deref for RouteToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<RouteToken> for ::std::string::String {
        fn from(value: RouteToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&RouteToken> for RouteToken {
        fn from(value: &RouteToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for RouteToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for RouteToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for RouteToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`SalesInvoiceDiscount`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": [
    ///    "object",
    ///    "null"
    ///  ],
    ///  "required": [
    ///    "type",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "$ref": "#/components/schemas/sales-invoice-discount-type"
    ///    },
    ///    "value": {
    ///      "description": "A string containing an exact monetary amount in the
    /// given currency, or the percentage.",
    ///      "examples": [
    ///        "10.00"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SalesInvoiceDiscount(pub ::std::option::Option<SalesInvoiceDiscountInner>);
    impl ::std::ops::Deref for SalesInvoiceDiscount {
        type Target = ::std::option::Option<SalesInvoiceDiscountInner>;
        fn deref(&self) -> &::std::option::Option<SalesInvoiceDiscountInner> {
            &self.0
        }
    }

    impl ::std::convert::From<SalesInvoiceDiscount>
        for ::std::option::Option<SalesInvoiceDiscountInner>
    {
        fn from(value: SalesInvoiceDiscount) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SalesInvoiceDiscount> for SalesInvoiceDiscount {
        fn from(value: &SalesInvoiceDiscount) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<SalesInvoiceDiscountInner>>
        for SalesInvoiceDiscount
    {
        fn from(value: ::std::option::Option<SalesInvoiceDiscountInner>) -> Self {
            Self(value)
        }
    }

    ///`SalesInvoiceDiscountInner`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "$ref": "#/components/schemas/sales-invoice-discount-type"
    ///    },
    ///    "value": {
    ///      "description": "A string containing an exact monetary amount in the
    /// given currency, or the percentage.",
    ///      "examples": [
    ///        "10.00"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SalesInvoiceDiscountInner {
        #[serde(rename = "type")]
        pub type_: SalesInvoiceDiscountType,
        ///A string containing an exact monetary amount in the given currency,
        /// or the percentage.
        pub value: ::std::string::String,
    }

    impl ::std::convert::From<&SalesInvoiceDiscountInner> for SalesInvoiceDiscountInner {
        fn from(value: &SalesInvoiceDiscountInner) -> Self {
            value.clone()
        }
    }

    ///`SalesInvoiceDiscountResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": [
    ///    "object",
    ///    "null"
    ///  ],
    ///  "required": [
    ///    "type",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "$ref": "#/components/schemas/sales-invoice-discount-type-response"
    ///    },
    ///    "value": {
    ///      "description": "A string containing an exact monetary amount in the
    /// given currency, or the percentage.",
    ///      "examples": [
    ///        "10.00"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SalesInvoiceDiscountResponse(
        pub ::std::option::Option<SalesInvoiceDiscountResponseInner>,
    );
    impl ::std::ops::Deref for SalesInvoiceDiscountResponse {
        type Target = ::std::option::Option<SalesInvoiceDiscountResponseInner>;
        fn deref(&self) -> &::std::option::Option<SalesInvoiceDiscountResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<SalesInvoiceDiscountResponse>
        for ::std::option::Option<SalesInvoiceDiscountResponseInner>
    {
        fn from(value: SalesInvoiceDiscountResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SalesInvoiceDiscountResponse> for SalesInvoiceDiscountResponse {
        fn from(value: &SalesInvoiceDiscountResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<SalesInvoiceDiscountResponseInner>>
        for SalesInvoiceDiscountResponse
    {
        fn from(value: ::std::option::Option<SalesInvoiceDiscountResponseInner>) -> Self {
            Self(value)
        }
    }

    ///`SalesInvoiceDiscountResponseInner`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "$ref": "#/components/schemas/sales-invoice-discount-type-response"
    ///    },
    ///    "value": {
    ///      "description": "A string containing an exact monetary amount in the
    /// given currency, or the percentage.",
    ///      "examples": [
    ///        "10.00"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SalesInvoiceDiscountResponseInner {
        #[serde(rename = "type")]
        pub type_: SalesInvoiceDiscountTypeResponse,
        ///A string containing an exact monetary amount in the given currency,
        /// or the percentage.
        pub value: ::std::string::String,
    }

    impl ::std::convert::From<&SalesInvoiceDiscountResponseInner>
        for SalesInvoiceDiscountResponseInner
    {
        fn from(value: &SalesInvoiceDiscountResponseInner) -> Self {
            value.clone()
        }
    }

    ///The type of discount.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of discount.",
    ///  "examples": [
    ///    "amount"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "amount",
    ///    "percentage"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SalesInvoiceDiscountType {
        #[serde(rename = "amount")]
        Amount,
        #[serde(rename = "percentage")]
        Percentage,
    }

    impl ::std::convert::From<&Self> for SalesInvoiceDiscountType {
        fn from(value: &SalesInvoiceDiscountType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SalesInvoiceDiscountType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Amount => f.write_str("amount"),
                Self::Percentage => f.write_str("percentage"),
            }
        }
    }

    impl ::std::str::FromStr for SalesInvoiceDiscountType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "amount" => Ok(Self::Amount),
                "percentage" => Ok(Self::Percentage),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoiceDiscountType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoiceDiscountType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoiceDiscountType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The type of discount.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of discount.",
    ///  "examples": [
    ///    "amount"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "amount",
    ///    "percentage"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SalesInvoiceDiscountTypeResponse {
        #[serde(rename = "amount")]
        Amount,
        #[serde(rename = "percentage")]
        Percentage,
    }

    impl ::std::convert::From<&Self> for SalesInvoiceDiscountTypeResponse {
        fn from(value: &SalesInvoiceDiscountTypeResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SalesInvoiceDiscountTypeResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Amount => f.write_str("amount"),
                Self::Percentage => f.write_str("percentage"),
            }
        }
    }

    impl ::std::str::FromStr for SalesInvoiceDiscountTypeResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "amount" => Ok(Self::Amount),
                "percentage" => Ok(Self::Percentage),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoiceDiscountTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoiceDiscountTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoiceDiscountTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SalesInvoiceEmailDetails`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": [
    ///    "object",
    ///    "null"
    ///  ],
    ///  "required": [
    ///    "body",
    ///    "subject"
    ///  ],
    ///  "properties": {
    ///    "body": {
    ///      "description": "The body of the email to be sent. To add newline
    /// characters, you can use `\\n`.",
    ///      "examples": [
    ///        "Please find your invoice enclosed."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "subject": {
    ///      "description": "The subject of the email to be sent.",
    ///      "examples": [
    ///        "Your invoice is available"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SalesInvoiceEmailDetails(pub ::std::option::Option<SalesInvoiceEmailDetailsInner>);
    impl ::std::ops::Deref for SalesInvoiceEmailDetails {
        type Target = ::std::option::Option<SalesInvoiceEmailDetailsInner>;
        fn deref(&self) -> &::std::option::Option<SalesInvoiceEmailDetailsInner> {
            &self.0
        }
    }

    impl ::std::convert::From<SalesInvoiceEmailDetails>
        for ::std::option::Option<SalesInvoiceEmailDetailsInner>
    {
        fn from(value: SalesInvoiceEmailDetails) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SalesInvoiceEmailDetails> for SalesInvoiceEmailDetails {
        fn from(value: &SalesInvoiceEmailDetails) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<SalesInvoiceEmailDetailsInner>>
        for SalesInvoiceEmailDetails
    {
        fn from(value: ::std::option::Option<SalesInvoiceEmailDetailsInner>) -> Self {
            Self(value)
        }
    }

    ///`SalesInvoiceEmailDetailsInner`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "body",
    ///    "subject"
    ///  ],
    ///  "properties": {
    ///    "body": {
    ///      "description": "The body of the email to be sent. To add newline
    /// characters, you can use `\\n`.",
    ///      "examples": [
    ///        "Please find your invoice enclosed."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "subject": {
    ///      "description": "The subject of the email to be sent.",
    ///      "examples": [
    ///        "Your invoice is available"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SalesInvoiceEmailDetailsInner {
        ///The body of the email to be sent. To add newline characters, you can
        /// use `\n`.
        pub body: ::std::string::String,
        ///The subject of the email to be sent.
        pub subject: ::std::string::String,
    }

    impl ::std::convert::From<&SalesInvoiceEmailDetailsInner> for SalesInvoiceEmailDetailsInner {
        fn from(value: &SalesInvoiceEmailDetailsInner) -> Self {
            value.clone()
        }
    }

    ///`SalesInvoiceLineItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "quantity",
    ///    "unitPrice",
    ///    "vatRate"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "A description of the line item. For example *LEGO
    /// 4440 Forest Police Station*.",
    ///      "examples": [
    ///        "LEGO 4440 Forest Police Station"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 100
    ///    },
    ///    "discount": {
    ///      "$ref": "#/components/schemas/sales-invoice-discount"
    ///    },
    ///    "quantity": {
    ///      "description": "The number of items.",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "minimum": 1.0
    ///    },
    ///    "unitPrice": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "vatRate": {
    ///      "description": "The vat rate to be applied to this line item.",
    ///      "examples": [
    ///        "21.00"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SalesInvoiceLineItem {
        ///A description of the line item. For example *LEGO 4440 Forest Police
        /// Station*.
        pub description: SalesInvoiceLineItemDescription,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub discount: ::std::option::Option<SalesInvoiceDiscount>,
        ///The number of items.
        pub quantity: ::std::num::NonZeroU64,
        #[serde(rename = "unitPrice")]
        pub unit_price: Amount,
        ///The vat rate to be applied to this line item.
        #[serde(rename = "vatRate")]
        pub vat_rate: ::std::string::String,
    }

    impl ::std::convert::From<&SalesInvoiceLineItem> for SalesInvoiceLineItem {
        fn from(value: &SalesInvoiceLineItem) -> Self {
            value.clone()
        }
    }

    ///A description of the line item. For example *LEGO 4440 Forest Police
    /// Station*.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A description of the line item. For example *LEGO 4440
    /// Forest Police Station*.",
    ///  "examples": [
    ///    "LEGO 4440 Forest Police Station"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 100
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SalesInvoiceLineItemDescription(::std::string::String);
    impl ::std::ops::Deref for SalesInvoiceLineItemDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<SalesInvoiceLineItemDescription> for ::std::string::String {
        fn from(value: SalesInvoiceLineItemDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SalesInvoiceLineItemDescription> for SalesInvoiceLineItemDescription {
        fn from(value: &SalesInvoiceLineItemDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for SalesInvoiceLineItemDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 100usize {
                return Err("longer than 100 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoiceLineItemDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoiceLineItemDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoiceLineItemDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for SalesInvoiceLineItemDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`SalesInvoiceLineItemResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "quantity",
    ///    "unitPrice",
    ///    "vatRate"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "A description of the line item. For example *LEGO
    /// 4440 Forest Police Station*.",
    ///      "examples": [
    ///        "LEGO 4440 Forest Police Station"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 100
    ///    },
    ///    "discount": {
    ///      "$ref": "#/components/schemas/sales-invoice-discount-response"
    ///    },
    ///    "quantity": {
    ///      "description": "The number of items.",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "minimum": 1.0
    ///    },
    ///    "unitPrice": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "vatRate": {
    ///      "description": "The vat rate to be applied to this line item.",
    ///      "examples": [
    ///        "21.00"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SalesInvoiceLineItemResponse {
        ///A description of the line item. For example *LEGO 4440 Forest Police
        /// Station*.
        pub description: SalesInvoiceLineItemResponseDescription,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub discount: ::std::option::Option<SalesInvoiceDiscountResponse>,
        ///The number of items.
        pub quantity: ::std::num::NonZeroU64,
        #[serde(rename = "unitPrice")]
        pub unit_price: Amount,
        ///The vat rate to be applied to this line item.
        #[serde(rename = "vatRate")]
        pub vat_rate: ::std::string::String,
    }

    impl ::std::convert::From<&SalesInvoiceLineItemResponse> for SalesInvoiceLineItemResponse {
        fn from(value: &SalesInvoiceLineItemResponse) -> Self {
            value.clone()
        }
    }

    ///A description of the line item. For example *LEGO 4440 Forest Police
    /// Station*.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A description of the line item. For example *LEGO 4440
    /// Forest Police Station*.",
    ///  "examples": [
    ///    "LEGO 4440 Forest Police Station"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 100
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SalesInvoiceLineItemResponseDescription(::std::string::String);
    impl ::std::ops::Deref for SalesInvoiceLineItemResponseDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<SalesInvoiceLineItemResponseDescription> for ::std::string::String {
        fn from(value: SalesInvoiceLineItemResponseDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SalesInvoiceLineItemResponseDescription>
        for SalesInvoiceLineItemResponseDescription
    {
        fn from(value: &SalesInvoiceLineItemResponseDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for SalesInvoiceLineItemResponseDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 100usize {
                return Err("longer than 100 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoiceLineItemResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoiceLineItemResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoiceLineItemResponseDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for SalesInvoiceLineItemResponseDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`SalesInvoicePaymentDetails`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": [
    ///    "object",
    ///    "null"
    ///  ],
    ///  "required": [
    ///    "source"
    ///  ],
    ///  "properties": {
    ///    "source": {
    ///      "$ref": "#/components/schemas/sales-invoice-payment-details-source"
    ///    },
    ///    "sourceReference": {
    ///      "description": "A reference to the payment the sales invoice is paid by. Required for `source` values `payment-link` and\n`payment`.",
    ///      "examples": [
    ///        "pl_d9fQur83kFdhH8hIhaZfq"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SalesInvoicePaymentDetails(
        pub ::std::option::Option<SalesInvoicePaymentDetailsInner>,
    );
    impl ::std::ops::Deref for SalesInvoicePaymentDetails {
        type Target = ::std::option::Option<SalesInvoicePaymentDetailsInner>;
        fn deref(&self) -> &::std::option::Option<SalesInvoicePaymentDetailsInner> {
            &self.0
        }
    }

    impl ::std::convert::From<SalesInvoicePaymentDetails>
        for ::std::option::Option<SalesInvoicePaymentDetailsInner>
    {
        fn from(value: SalesInvoicePaymentDetails) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SalesInvoicePaymentDetails> for SalesInvoicePaymentDetails {
        fn from(value: &SalesInvoicePaymentDetails) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<SalesInvoicePaymentDetailsInner>>
        for SalesInvoicePaymentDetails
    {
        fn from(value: ::std::option::Option<SalesInvoicePaymentDetailsInner>) -> Self {
            Self(value)
        }
    }

    ///`SalesInvoicePaymentDetailsInner`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "source"
    ///  ],
    ///  "properties": {
    ///    "source": {
    ///      "$ref": "#/components/schemas/sales-invoice-payment-details-source"
    ///    },
    ///    "sourceReference": {
    ///      "description": "A reference to the payment the sales invoice is paid by. Required for `source` values `payment-link` and\n`payment`.",
    ///      "examples": [
    ///        "pl_d9fQur83kFdhH8hIhaZfq"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SalesInvoicePaymentDetailsInner {
        pub source: SalesInvoicePaymentDetailsSource,
        ///A reference to the payment the sales invoice is paid by. Required
        /// for `source` values `payment-link` and `payment`.
        #[serde(
            rename = "sourceReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub source_reference: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SalesInvoicePaymentDetailsInner> for SalesInvoicePaymentDetailsInner {
        fn from(value: &SalesInvoicePaymentDetailsInner) -> Self {
            value.clone()
        }
    }

    ///`SalesInvoicePaymentDetailsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": [
    ///    "object",
    ///    "null"
    ///  ],
    ///  "required": [
    ///    "source"
    ///  ],
    ///  "properties": {
    ///    "source": {
    ///      "$ref":
    /// "#/components/schemas/sales-invoice-payment-details-source-response"
    ///    },
    ///    "sourceReference": {
    ///      "description": "A reference to the payment the sales invoice is paid by. Required for `source` values `payment-link` and\n`payment`.",
    ///      "examples": [
    ///        "pl_d9fQur83kFdhH8hIhaZfq"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SalesInvoicePaymentDetailsResponse(
        pub ::std::option::Option<SalesInvoicePaymentDetailsResponseInner>,
    );
    impl ::std::ops::Deref for SalesInvoicePaymentDetailsResponse {
        type Target = ::std::option::Option<SalesInvoicePaymentDetailsResponseInner>;
        fn deref(&self) -> &::std::option::Option<SalesInvoicePaymentDetailsResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<SalesInvoicePaymentDetailsResponse>
        for ::std::option::Option<SalesInvoicePaymentDetailsResponseInner>
    {
        fn from(value: SalesInvoicePaymentDetailsResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SalesInvoicePaymentDetailsResponse>
        for SalesInvoicePaymentDetailsResponse
    {
        fn from(value: &SalesInvoicePaymentDetailsResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<SalesInvoicePaymentDetailsResponseInner>>
        for SalesInvoicePaymentDetailsResponse
    {
        fn from(value: ::std::option::Option<SalesInvoicePaymentDetailsResponseInner>) -> Self {
            Self(value)
        }
    }

    ///`SalesInvoicePaymentDetailsResponseInner`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "source"
    ///  ],
    ///  "properties": {
    ///    "source": {
    ///      "$ref":
    /// "#/components/schemas/sales-invoice-payment-details-source-response"
    ///    },
    ///    "sourceReference": {
    ///      "description": "A reference to the payment the sales invoice is paid by. Required for `source` values `payment-link` and\n`payment`.",
    ///      "examples": [
    ///        "pl_d9fQur83kFdhH8hIhaZfq"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SalesInvoicePaymentDetailsResponseInner {
        pub source: SalesInvoicePaymentDetailsSourceResponse,
        ///A reference to the payment the sales invoice is paid by. Required
        /// for `source` values `payment-link` and `payment`.
        #[serde(
            rename = "sourceReference",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub source_reference: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SalesInvoicePaymentDetailsResponseInner>
        for SalesInvoicePaymentDetailsResponseInner
    {
        fn from(value: &SalesInvoicePaymentDetailsResponseInner) -> Self {
            value.clone()
        }
    }

    ///The way through which the invoice is to be set to paid.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The way through which the invoice is to be set to
    /// paid.",
    ///  "examples": [
    ///    "payment-link"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "manual",
    ///    "payment-link",
    ///    "payment"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SalesInvoicePaymentDetailsSource {
        #[serde(rename = "manual")]
        Manual,
        #[serde(rename = "payment-link")]
        PaymentLink,
        #[serde(rename = "payment")]
        Payment,
    }

    impl ::std::convert::From<&Self> for SalesInvoicePaymentDetailsSource {
        fn from(value: &SalesInvoicePaymentDetailsSource) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SalesInvoicePaymentDetailsSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Manual => f.write_str("manual"),
                Self::PaymentLink => f.write_str("payment-link"),
                Self::Payment => f.write_str("payment"),
            }
        }
    }

    impl ::std::str::FromStr for SalesInvoicePaymentDetailsSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "manual" => Ok(Self::Manual),
                "payment-link" => Ok(Self::PaymentLink),
                "payment" => Ok(Self::Payment),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoicePaymentDetailsSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoicePaymentDetailsSource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoicePaymentDetailsSource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The way through which the invoice is to be set to paid.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The way through which the invoice is to be set to
    /// paid.",
    ///  "examples": [
    ///    "payment-link"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "manual",
    ///    "payment-link",
    ///    "payment"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SalesInvoicePaymentDetailsSourceResponse {
        #[serde(rename = "manual")]
        Manual,
        #[serde(rename = "payment-link")]
        PaymentLink,
        #[serde(rename = "payment")]
        Payment,
    }

    impl ::std::convert::From<&Self> for SalesInvoicePaymentDetailsSourceResponse {
        fn from(value: &SalesInvoicePaymentDetailsSourceResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SalesInvoicePaymentDetailsSourceResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Manual => f.write_str("manual"),
                Self::PaymentLink => f.write_str("payment-link"),
                Self::Payment => f.write_str("payment"),
            }
        }
    }

    impl ::std::str::FromStr for SalesInvoicePaymentDetailsSourceResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "manual" => Ok(Self::Manual),
                "payment-link" => Ok(Self::PaymentLink),
                "payment" => Ok(Self::Payment),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoicePaymentDetailsSourceResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoicePaymentDetailsSourceResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoicePaymentDetailsSourceResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The payment term to be set on the invoice.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The payment term to be set on the invoice.",
    ///  "examples": [
    ///    "30 days"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "7 days",
    ///    "14 days",
    ///    "30 days",
    ///    "45 days",
    ///    "60 days",
    ///    "90 days",
    ///    "120 days"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SalesInvoicePaymentTerm(pub ::std::option::Option<SalesInvoicePaymentTermInner>);
    impl ::std::ops::Deref for SalesInvoicePaymentTerm {
        type Target = ::std::option::Option<SalesInvoicePaymentTermInner>;
        fn deref(&self) -> &::std::option::Option<SalesInvoicePaymentTermInner> {
            &self.0
        }
    }

    impl ::std::convert::From<SalesInvoicePaymentTerm>
        for ::std::option::Option<SalesInvoicePaymentTermInner>
    {
        fn from(value: SalesInvoicePaymentTerm) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SalesInvoicePaymentTerm> for SalesInvoicePaymentTerm {
        fn from(value: &SalesInvoicePaymentTerm) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<SalesInvoicePaymentTermInner>>
        for SalesInvoicePaymentTerm
    {
        fn from(value: ::std::option::Option<SalesInvoicePaymentTermInner>) -> Self {
            Self(value)
        }
    }

    ///The payment term to be set on the invoice.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The payment term to be set on the invoice.",
    ///  "examples": [
    ///    "30 days"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "7 days",
    ///    "14 days",
    ///    "30 days",
    ///    "45 days",
    ///    "60 days",
    ///    "90 days",
    ///    "120 days"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SalesInvoicePaymentTermInner {
        #[serde(rename = "7 days")]
        X7Days,
        #[serde(rename = "14 days")]
        X14Days,
        #[serde(rename = "30 days")]
        X30Days,
        #[serde(rename = "45 days")]
        X45Days,
        #[serde(rename = "60 days")]
        X60Days,
        #[serde(rename = "90 days")]
        X90Days,
        #[serde(rename = "120 days")]
        X120Days,
    }

    impl ::std::convert::From<&Self> for SalesInvoicePaymentTermInner {
        fn from(value: &SalesInvoicePaymentTermInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SalesInvoicePaymentTermInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X7Days => f.write_str("7 days"),
                Self::X14Days => f.write_str("14 days"),
                Self::X30Days => f.write_str("30 days"),
                Self::X45Days => f.write_str("45 days"),
                Self::X60Days => f.write_str("60 days"),
                Self::X90Days => f.write_str("90 days"),
                Self::X120Days => f.write_str("120 days"),
            }
        }
    }

    impl ::std::str::FromStr for SalesInvoicePaymentTermInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "7 days" => Ok(Self::X7Days),
                "14 days" => Ok(Self::X14Days),
                "30 days" => Ok(Self::X30Days),
                "45 days" => Ok(Self::X45Days),
                "60 days" => Ok(Self::X60Days),
                "90 days" => Ok(Self::X90Days),
                "120 days" => Ok(Self::X120Days),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoicePaymentTermInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoicePaymentTermInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoicePaymentTermInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The payment term to be set on the invoice.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The payment term to be set on the invoice.",
    ///  "examples": [
    ///    "30 days"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "7 days",
    ///    "14 days",
    ///    "30 days",
    ///    "45 days",
    ///    "60 days",
    ///    "90 days",
    ///    "120 days"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SalesInvoicePaymentTermResponse(
        pub ::std::option::Option<SalesInvoicePaymentTermResponseInner>,
    );
    impl ::std::ops::Deref for SalesInvoicePaymentTermResponse {
        type Target = ::std::option::Option<SalesInvoicePaymentTermResponseInner>;
        fn deref(&self) -> &::std::option::Option<SalesInvoicePaymentTermResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<SalesInvoicePaymentTermResponse>
        for ::std::option::Option<SalesInvoicePaymentTermResponseInner>
    {
        fn from(value: SalesInvoicePaymentTermResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SalesInvoicePaymentTermResponse> for SalesInvoicePaymentTermResponse {
        fn from(value: &SalesInvoicePaymentTermResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<SalesInvoicePaymentTermResponseInner>>
        for SalesInvoicePaymentTermResponse
    {
        fn from(value: ::std::option::Option<SalesInvoicePaymentTermResponseInner>) -> Self {
            Self(value)
        }
    }

    ///The payment term to be set on the invoice.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The payment term to be set on the invoice.",
    ///  "examples": [
    ///    "30 days"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "7 days",
    ///    "14 days",
    ///    "30 days",
    ///    "45 days",
    ///    "60 days",
    ///    "90 days",
    ///    "120 days"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SalesInvoicePaymentTermResponseInner {
        #[serde(rename = "7 days")]
        X7Days,
        #[serde(rename = "14 days")]
        X14Days,
        #[serde(rename = "30 days")]
        X30Days,
        #[serde(rename = "45 days")]
        X45Days,
        #[serde(rename = "60 days")]
        X60Days,
        #[serde(rename = "90 days")]
        X90Days,
        #[serde(rename = "120 days")]
        X120Days,
    }

    impl ::std::convert::From<&Self> for SalesInvoicePaymentTermResponseInner {
        fn from(value: &SalesInvoicePaymentTermResponseInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SalesInvoicePaymentTermResponseInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X7Days => f.write_str("7 days"),
                Self::X14Days => f.write_str("14 days"),
                Self::X30Days => f.write_str("30 days"),
                Self::X45Days => f.write_str("45 days"),
                Self::X60Days => f.write_str("60 days"),
                Self::X90Days => f.write_str("90 days"),
                Self::X120Days => f.write_str("120 days"),
            }
        }
    }

    impl ::std::str::FromStr for SalesInvoicePaymentTermResponseInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "7 days" => Ok(Self::X7Days),
                "14 days" => Ok(Self::X14Days),
                "30 days" => Ok(Self::X30Days),
                "45 days" => Ok(Self::X45Days),
                "60 days" => Ok(Self::X60Days),
                "90 days" => Ok(Self::X90Days),
                "120 days" => Ok(Self::X120Days),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoicePaymentTermResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoicePaymentTermResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoicePaymentTermResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SalesInvoiceRecipient`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": [
    ///    "object",
    ///    "null"
    ///  ],
    ///  "required": [
    ///    "city",
    ///    "country",
    ///    "email",
    ///    "locale",
    ///    "postalCode",
    ///    "streetAndNumber",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "city": {
    ///      "description": "The recipient's city.",
    ///      "examples": [
    ///        "Amsterdam"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "country": {
    ///      "description": "A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.",
    ///      "examples": [
    ///        "NL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "email": {
    ///      "description": "The email address of the recipient.",
    ///      "examples": [
    ///        "example@email.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "familyName": {
    ///      "description": "The given name (last name) of the `consumer` type
    /// recipient should be at least two characters and cannot contain\nonly
    /// numbers.",
    ///      "examples": [
    ///        "Doe"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "givenName": {
    ///      "description": "The given name (first name) of the `consumer` type
    /// recipient should be at least two characters and cannot contain\nonly
    /// numbers.",
    ///      "examples": [
    ///        "Jane"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "locale": {
    ///      "$ref": "#/components/schemas/sales-invoice-recipient-locale"
    ///    },
    ///    "organizationName": {
    ///      "description": "The trading name of the `business` type
    /// recipient.",
    ///      "examples": [
    ///        "Organization Corp."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "organizationNumber": {
    ///      "description": "The Chamber of Commerce number of the organization
    /// for a `business` type recipient. Either this or `vatNumber`\nhas to be
    /// provided.",
    ///      "examples": [
    ///        "12345678"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "phone": {
    ///      "description": "The phone number of the recipient.",
    ///      "examples": [
    ///        "+0123456789"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "postalCode": {
    ///      "description": "A postal code.",
    ///      "examples": [
    ///        "5678AB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "region": {
    ///      "description": "The recipient's region.",
    ///      "examples": [
    ///        "Noord-Holland"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "streetAdditional": {
    ///      "description": "Any additional addressing details, for example an
    /// apartment number.",
    ///      "examples": [
    ///        "4th floor"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "streetAndNumber": {
    ///      "description": "A street and street number.",
    ///      "examples": [
    ///        "Keizersgracht 126"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "title": {
    ///      "description": "The title of the `consumer` type recipient, for
    /// example Mr. or Mrs..",
    ///      "examples": [
    ///        "Mrs."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/sales-invoice-recipient-type"
    ///    },
    ///    "vatNumber": {
    ///      "description": "The VAT number of the organization for a `business`
    /// type recipient. Either this or `organizationNumber`\nhas to be
    /// provided.",
    ///      "examples": [
    ///        "NL123456789B01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SalesInvoiceRecipient(pub ::std::option::Option<SalesInvoiceRecipientInner>);
    impl ::std::ops::Deref for SalesInvoiceRecipient {
        type Target = ::std::option::Option<SalesInvoiceRecipientInner>;
        fn deref(&self) -> &::std::option::Option<SalesInvoiceRecipientInner> {
            &self.0
        }
    }

    impl ::std::convert::From<SalesInvoiceRecipient>
        for ::std::option::Option<SalesInvoiceRecipientInner>
    {
        fn from(value: SalesInvoiceRecipient) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SalesInvoiceRecipient> for SalesInvoiceRecipient {
        fn from(value: &SalesInvoiceRecipient) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<SalesInvoiceRecipientInner>>
        for SalesInvoiceRecipient
    {
        fn from(value: ::std::option::Option<SalesInvoiceRecipientInner>) -> Self {
            Self(value)
        }
    }

    ///`SalesInvoiceRecipientInner`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "city",
    ///    "country",
    ///    "email",
    ///    "locale",
    ///    "postalCode",
    ///    "streetAndNumber",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "city": {
    ///      "description": "The recipient's city.",
    ///      "examples": [
    ///        "Amsterdam"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "country": {
    ///      "description": "A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.",
    ///      "examples": [
    ///        "NL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "email": {
    ///      "description": "The email address of the recipient.",
    ///      "examples": [
    ///        "example@email.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "familyName": {
    ///      "description": "The given name (last name) of the `consumer` type
    /// recipient should be at least two characters and cannot contain\nonly
    /// numbers.",
    ///      "examples": [
    ///        "Doe"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "givenName": {
    ///      "description": "The given name (first name) of the `consumer` type
    /// recipient should be at least two characters and cannot contain\nonly
    /// numbers.",
    ///      "examples": [
    ///        "Jane"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "locale": {
    ///      "$ref": "#/components/schemas/sales-invoice-recipient-locale"
    ///    },
    ///    "organizationName": {
    ///      "description": "The trading name of the `business` type
    /// recipient.",
    ///      "examples": [
    ///        "Organization Corp."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "organizationNumber": {
    ///      "description": "The Chamber of Commerce number of the organization
    /// for a `business` type recipient. Either this or `vatNumber`\nhas to be
    /// provided.",
    ///      "examples": [
    ///        "12345678"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "phone": {
    ///      "description": "The phone number of the recipient.",
    ///      "examples": [
    ///        "+0123456789"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "postalCode": {
    ///      "description": "A postal code.",
    ///      "examples": [
    ///        "5678AB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "region": {
    ///      "description": "The recipient's region.",
    ///      "examples": [
    ///        "Noord-Holland"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "streetAdditional": {
    ///      "description": "Any additional addressing details, for example an
    /// apartment number.",
    ///      "examples": [
    ///        "4th floor"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "streetAndNumber": {
    ///      "description": "A street and street number.",
    ///      "examples": [
    ///        "Keizersgracht 126"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "title": {
    ///      "description": "The title of the `consumer` type recipient, for
    /// example Mr. or Mrs..",
    ///      "examples": [
    ///        "Mrs."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/sales-invoice-recipient-type"
    ///    },
    ///    "vatNumber": {
    ///      "description": "The VAT number of the organization for a `business`
    /// type recipient. Either this or `organizationNumber`\nhas to be
    /// provided.",
    ///      "examples": [
    ///        "NL123456789B01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SalesInvoiceRecipientInner {
        ///The recipient's city.
        pub city: ::std::string::String,
        ///A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
        pub country: ::std::string::String,
        ///The email address of the recipient.
        pub email: ::std::string::String,
        ///The given name (last name) of the `consumer` type recipient should
        /// be at least two characters and cannot contain only numbers.
        #[serde(
            rename = "familyName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub family_name: ::std::option::Option<::std::string::String>,
        ///The given name (first name) of the `consumer` type recipient should
        /// be at least two characters and cannot contain only numbers.
        #[serde(
            rename = "givenName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub given_name: ::std::option::Option<::std::string::String>,
        pub locale: SalesInvoiceRecipientLocale,
        ///The trading name of the `business` type recipient.
        #[serde(
            rename = "organizationName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub organization_name: ::std::option::Option<::std::string::String>,
        ///The Chamber of Commerce number of the organization for a `business`
        /// type recipient. Either this or `vatNumber`
        /// has to be provided.
        #[serde(
            rename = "organizationNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub organization_number: ::std::option::Option<::std::string::String>,
        ///The phone number of the recipient.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub phone: ::std::option::Option<::std::string::String>,
        ///A postal code.
        #[serde(rename = "postalCode")]
        pub postal_code: ::std::string::String,
        ///The recipient's region.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub region: ::std::option::Option<::std::string::String>,
        ///Any additional addressing details, for example an apartment number.
        #[serde(
            rename = "streetAdditional",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub street_additional: ::std::option::Option<::std::string::String>,
        ///A street and street number.
        #[serde(rename = "streetAndNumber")]
        pub street_and_number: ::std::string::String,
        ///The title of the `consumer` type recipient, for example Mr. or Mrs..
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub title: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: SalesInvoiceRecipientType,
        ///The VAT number of the organization for a `business` type recipient.
        /// Either this or `organizationNumber` has to be provided.
        #[serde(
            rename = "vatNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_number: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SalesInvoiceRecipientInner> for SalesInvoiceRecipientInner {
        fn from(value: &SalesInvoiceRecipientInner) -> Self {
            value.clone()
        }
    }

    ///The locale for the recipient, to be used for translations in PDF
    /// generation and payment pages.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The locale for the recipient, to be used for
    /// translations in PDF generation and payment pages.",
    ///  "examples": [
    ///    "nl_NL"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "en_US",
    ///    "en_GB",
    ///    "nl_NL",
    ///    "nl_BE",
    ///    "de_DE",
    ///    "de_AT",
    ///    "de_CH",
    ///    "fr_FR",
    ///    "fr_BE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SalesInvoiceRecipientLocale {
        #[serde(rename = "en_US")]
        EnUs,
        #[serde(rename = "en_GB")]
        EnGb,
        #[serde(rename = "nl_NL")]
        NlNl,
        #[serde(rename = "nl_BE")]
        NlBe,
        #[serde(rename = "de_DE")]
        DeDe,
        #[serde(rename = "de_AT")]
        DeAt,
        #[serde(rename = "de_CH")]
        DeCh,
        #[serde(rename = "fr_FR")]
        FrFr,
        #[serde(rename = "fr_BE")]
        FrBe,
    }

    impl ::std::convert::From<&Self> for SalesInvoiceRecipientLocale {
        fn from(value: &SalesInvoiceRecipientLocale) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SalesInvoiceRecipientLocale {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EnUs => f.write_str("en_US"),
                Self::EnGb => f.write_str("en_GB"),
                Self::NlNl => f.write_str("nl_NL"),
                Self::NlBe => f.write_str("nl_BE"),
                Self::DeDe => f.write_str("de_DE"),
                Self::DeAt => f.write_str("de_AT"),
                Self::DeCh => f.write_str("de_CH"),
                Self::FrFr => f.write_str("fr_FR"),
                Self::FrBe => f.write_str("fr_BE"),
            }
        }
    }

    impl ::std::str::FromStr for SalesInvoiceRecipientLocale {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "en_US" => Ok(Self::EnUs),
                "en_GB" => Ok(Self::EnGb),
                "nl_NL" => Ok(Self::NlNl),
                "nl_BE" => Ok(Self::NlBe),
                "de_DE" => Ok(Self::DeDe),
                "de_AT" => Ok(Self::DeAt),
                "de_CH" => Ok(Self::DeCh),
                "fr_FR" => Ok(Self::FrFr),
                "fr_BE" => Ok(Self::FrBe),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoiceRecipientLocale {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoiceRecipientLocale {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoiceRecipientLocale {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The locale for the recipient, to be used for translations in PDF
    /// generation and payment pages.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The locale for the recipient, to be used for
    /// translations in PDF generation and payment pages.",
    ///  "examples": [
    ///    "nl_NL"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "en_US",
    ///    "en_GB",
    ///    "nl_NL",
    ///    "nl_BE",
    ///    "de_DE",
    ///    "de_AT",
    ///    "de_CH",
    ///    "fr_FR",
    ///    "fr_BE"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SalesInvoiceRecipientLocaleResponse {
        #[serde(rename = "en_US")]
        EnUs,
        #[serde(rename = "en_GB")]
        EnGb,
        #[serde(rename = "nl_NL")]
        NlNl,
        #[serde(rename = "nl_BE")]
        NlBe,
        #[serde(rename = "de_DE")]
        DeDe,
        #[serde(rename = "de_AT")]
        DeAt,
        #[serde(rename = "de_CH")]
        DeCh,
        #[serde(rename = "fr_FR")]
        FrFr,
        #[serde(rename = "fr_BE")]
        FrBe,
    }

    impl ::std::convert::From<&Self> for SalesInvoiceRecipientLocaleResponse {
        fn from(value: &SalesInvoiceRecipientLocaleResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SalesInvoiceRecipientLocaleResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EnUs => f.write_str("en_US"),
                Self::EnGb => f.write_str("en_GB"),
                Self::NlNl => f.write_str("nl_NL"),
                Self::NlBe => f.write_str("nl_BE"),
                Self::DeDe => f.write_str("de_DE"),
                Self::DeAt => f.write_str("de_AT"),
                Self::DeCh => f.write_str("de_CH"),
                Self::FrFr => f.write_str("fr_FR"),
                Self::FrBe => f.write_str("fr_BE"),
            }
        }
    }

    impl ::std::str::FromStr for SalesInvoiceRecipientLocaleResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "en_US" => Ok(Self::EnUs),
                "en_GB" => Ok(Self::EnGb),
                "nl_NL" => Ok(Self::NlNl),
                "nl_BE" => Ok(Self::NlBe),
                "de_DE" => Ok(Self::DeDe),
                "de_AT" => Ok(Self::DeAt),
                "de_CH" => Ok(Self::DeCh),
                "fr_FR" => Ok(Self::FrFr),
                "fr_BE" => Ok(Self::FrBe),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoiceRecipientLocaleResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoiceRecipientLocaleResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoiceRecipientLocaleResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SalesInvoiceRecipientResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": [
    ///    "object",
    ///    "null"
    ///  ],
    ///  "required": [
    ///    "city",
    ///    "country",
    ///    "email",
    ///    "locale",
    ///    "postalCode",
    ///    "streetAndNumber",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "city": {
    ///      "description": "The recipient's city.",
    ///      "examples": [
    ///        "Amsterdam"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "country": {
    ///      "description": "A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.",
    ///      "examples": [
    ///        "NL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "email": {
    ///      "description": "The email address of the recipient.",
    ///      "examples": [
    ///        "example@email.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "familyName": {
    ///      "description": "The given name (last name) of the `consumer` type
    /// recipient should be at least two characters and cannot contain\nonly
    /// numbers.",
    ///      "examples": [
    ///        "Doe"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "givenName": {
    ///      "description": "The given name (first name) of the `consumer` type
    /// recipient should be at least two characters and cannot contain\nonly
    /// numbers.",
    ///      "examples": [
    ///        "Jane"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "locale": {
    ///      "$ref":
    /// "#/components/schemas/sales-invoice-recipient-locale-response"
    ///    },
    ///    "organizationName": {
    ///      "description": "The trading name of the `business` type
    /// recipient.",
    ///      "examples": [
    ///        "Organization Corp."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "organizationNumber": {
    ///      "description": "The Chamber of Commerce number of the organization
    /// for a `business` type recipient. Either this or `vatNumber`\nhas to be
    /// provided.",
    ///      "examples": [
    ///        "12345678"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "phone": {
    ///      "description": "The phone number of the recipient.",
    ///      "examples": [
    ///        "+0123456789"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "postalCode": {
    ///      "description": "A postal code.",
    ///      "examples": [
    ///        "5678AB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "region": {
    ///      "description": "The recipient's region.",
    ///      "examples": [
    ///        "Noord-Holland"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "streetAdditional": {
    ///      "description": "Any additional addressing details, for example an
    /// apartment number.",
    ///      "examples": [
    ///        "4th floor"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "streetAndNumber": {
    ///      "description": "A street and street number.",
    ///      "examples": [
    ///        "Keizersgracht 126"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "title": {
    ///      "description": "The title of the `consumer` type recipient, for
    /// example Mr. or Mrs..",
    ///      "examples": [
    ///        "Mrs."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "type": {
    ///      "$ref":
    /// "#/components/schemas/sales-invoice-recipient-type-response"
    ///    },
    ///    "vatNumber": {
    ///      "description": "The VAT number of the organization for a `business`
    /// type recipient. Either this or `organizationNumber`\nhas to be
    /// provided.",
    ///      "examples": [
    ///        "NL123456789B01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SalesInvoiceRecipientResponse(
        pub ::std::option::Option<SalesInvoiceRecipientResponseInner>,
    );
    impl ::std::ops::Deref for SalesInvoiceRecipientResponse {
        type Target = ::std::option::Option<SalesInvoiceRecipientResponseInner>;
        fn deref(&self) -> &::std::option::Option<SalesInvoiceRecipientResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<SalesInvoiceRecipientResponse>
        for ::std::option::Option<SalesInvoiceRecipientResponseInner>
    {
        fn from(value: SalesInvoiceRecipientResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SalesInvoiceRecipientResponse> for SalesInvoiceRecipientResponse {
        fn from(value: &SalesInvoiceRecipientResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<SalesInvoiceRecipientResponseInner>>
        for SalesInvoiceRecipientResponse
    {
        fn from(value: ::std::option::Option<SalesInvoiceRecipientResponseInner>) -> Self {
            Self(value)
        }
    }

    ///`SalesInvoiceRecipientResponseInner`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "city",
    ///    "country",
    ///    "email",
    ///    "locale",
    ///    "postalCode",
    ///    "streetAndNumber",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "city": {
    ///      "description": "The recipient's city.",
    ///      "examples": [
    ///        "Amsterdam"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "country": {
    ///      "description": "A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.",
    ///      "examples": [
    ///        "NL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "email": {
    ///      "description": "The email address of the recipient.",
    ///      "examples": [
    ///        "example@email.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "familyName": {
    ///      "description": "The given name (last name) of the `consumer` type
    /// recipient should be at least two characters and cannot contain\nonly
    /// numbers.",
    ///      "examples": [
    ///        "Doe"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "givenName": {
    ///      "description": "The given name (first name) of the `consumer` type
    /// recipient should be at least two characters and cannot contain\nonly
    /// numbers.",
    ///      "examples": [
    ///        "Jane"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "locale": {
    ///      "$ref":
    /// "#/components/schemas/sales-invoice-recipient-locale-response"
    ///    },
    ///    "organizationName": {
    ///      "description": "The trading name of the `business` type
    /// recipient.",
    ///      "examples": [
    ///        "Organization Corp."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "organizationNumber": {
    ///      "description": "The Chamber of Commerce number of the organization
    /// for a `business` type recipient. Either this or `vatNumber`\nhas to be
    /// provided.",
    ///      "examples": [
    ///        "12345678"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "phone": {
    ///      "description": "The phone number of the recipient.",
    ///      "examples": [
    ///        "+0123456789"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "postalCode": {
    ///      "description": "A postal code.",
    ///      "examples": [
    ///        "5678AB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "region": {
    ///      "description": "The recipient's region.",
    ///      "examples": [
    ///        "Noord-Holland"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "streetAdditional": {
    ///      "description": "Any additional addressing details, for example an
    /// apartment number.",
    ///      "examples": [
    ///        "4th floor"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "streetAndNumber": {
    ///      "description": "A street and street number.",
    ///      "examples": [
    ///        "Keizersgracht 126"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "title": {
    ///      "description": "The title of the `consumer` type recipient, for
    /// example Mr. or Mrs..",
    ///      "examples": [
    ///        "Mrs."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "type": {
    ///      "$ref":
    /// "#/components/schemas/sales-invoice-recipient-type-response"
    ///    },
    ///    "vatNumber": {
    ///      "description": "The VAT number of the organization for a `business`
    /// type recipient. Either this or `organizationNumber`\nhas to be
    /// provided.",
    ///      "examples": [
    ///        "NL123456789B01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SalesInvoiceRecipientResponseInner {
        ///The recipient's city.
        pub city: ::std::string::String,
        ///A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
        pub country: ::std::string::String,
        ///The email address of the recipient.
        pub email: ::std::string::String,
        ///The given name (last name) of the `consumer` type recipient should
        /// be at least two characters and cannot contain only numbers.
        #[serde(
            rename = "familyName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub family_name: ::std::option::Option<::std::string::String>,
        ///The given name (first name) of the `consumer` type recipient should
        /// be at least two characters and cannot contain only numbers.
        #[serde(
            rename = "givenName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub given_name: ::std::option::Option<::std::string::String>,
        pub locale: SalesInvoiceRecipientLocaleResponse,
        ///The trading name of the `business` type recipient.
        #[serde(
            rename = "organizationName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub organization_name: ::std::option::Option<::std::string::String>,
        ///The Chamber of Commerce number of the organization for a `business`
        /// type recipient. Either this or `vatNumber`
        /// has to be provided.
        #[serde(
            rename = "organizationNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub organization_number: ::std::option::Option<::std::string::String>,
        ///The phone number of the recipient.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub phone: ::std::option::Option<::std::string::String>,
        ///A postal code.
        #[serde(rename = "postalCode")]
        pub postal_code: ::std::string::String,
        ///The recipient's region.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub region: ::std::option::Option<::std::string::String>,
        ///Any additional addressing details, for example an apartment number.
        #[serde(
            rename = "streetAdditional",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub street_additional: ::std::option::Option<::std::string::String>,
        ///A street and street number.
        #[serde(rename = "streetAndNumber")]
        pub street_and_number: ::std::string::String,
        ///The title of the `consumer` type recipient, for example Mr. or Mrs..
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub title: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: SalesInvoiceRecipientTypeResponse,
        ///The VAT number of the organization for a `business` type recipient.
        /// Either this or `organizationNumber` has to be provided.
        #[serde(
            rename = "vatNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_number: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SalesInvoiceRecipientResponseInner>
        for SalesInvoiceRecipientResponseInner
    {
        fn from(value: &SalesInvoiceRecipientResponseInner) -> Self {
            value.clone()
        }
    }

    ///The type of recipient, either `consumer` or `business`. This will
    /// determine what further fields are required on the `recipient`
    /// object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of recipient, either `consumer` or `business`.
    /// This will determine what further fields are\nrequired on the `recipient`
    /// object.",
    ///  "examples": [
    ///    "consumer"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "consumer",
    ///    "business"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SalesInvoiceRecipientType {
        #[serde(rename = "consumer")]
        Consumer,
        #[serde(rename = "business")]
        Business,
    }

    impl ::std::convert::From<&Self> for SalesInvoiceRecipientType {
        fn from(value: &SalesInvoiceRecipientType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SalesInvoiceRecipientType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Consumer => f.write_str("consumer"),
                Self::Business => f.write_str("business"),
            }
        }
    }

    impl ::std::str::FromStr for SalesInvoiceRecipientType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "consumer" => Ok(Self::Consumer),
                "business" => Ok(Self::Business),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoiceRecipientType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoiceRecipientType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoiceRecipientType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The type of recipient, either `consumer` or `business`. This will
    /// determine what further fields are required on the `recipient`
    /// object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of recipient, either `consumer` or `business`.
    /// This will determine what further fields are\nrequired on the `recipient`
    /// object.",
    ///  "examples": [
    ///    "consumer"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "consumer",
    ///    "business"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SalesInvoiceRecipientTypeResponse {
        #[serde(rename = "consumer")]
        Consumer,
        #[serde(rename = "business")]
        Business,
    }

    impl ::std::convert::From<&Self> for SalesInvoiceRecipientTypeResponse {
        fn from(value: &SalesInvoiceRecipientTypeResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SalesInvoiceRecipientTypeResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Consumer => f.write_str("consumer"),
                Self::Business => f.write_str("business"),
            }
        }
    }

    impl ::std::str::FromStr for SalesInvoiceRecipientTypeResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "consumer" => Ok(Self::Consumer),
                "business" => Ok(Self::Business),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoiceRecipientTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoiceRecipientTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoiceRecipientTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The status for the invoice to end up in.
    ///
    ///A `draft` invoice is not paid or not sent and can be updated after
    /// creation. Setting it to `issued` sends it to the recipient so they
    /// may then pay through our payment system. To skip our payment process,
    /// set this to `paid` to mark it as paid. It can then subsequently be
    /// sent as well, same as with `issued`.
    ///
    ///A status value that cannot be set but can be returned is `canceled`, for
    /// invoices which were issued, but then canceled. Currently this can
    /// only be done for invoices created in the dashboard.
    ///
    ///Dependent parameters:
    ///  - `paymentDetails` is required if invoice should be set directly to
    ///    `paid`
    ///  - `customerId` and `mandateId` are required if a recurring payment
    ///    should be used to set the invoice to `paid`
    ///  - `emailDetails` optional for `issued` and `paid` to send the invoice
    ///    by email
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status for the invoice to end up in.\n\nA `draft`
    /// invoice is not paid or not sent and can be updated after creation.
    /// Setting it to `issued` sends it to\nthe recipient so they may then pay
    /// through our payment system. To skip our payment process, set this to
    /// `paid` to\nmark it as paid. It can then subsequently be sent as well,
    /// same as with `issued`.\n\nA status value that cannot be set but can be
    /// returned is `canceled`, for invoices which were\nissued, but then
    /// canceled. Currently this can only be done for invoices created in the
    /// dashboard.\n\nDependent parameters:\n  - `paymentDetails` is required if
    /// invoice should be set directly to `paid`\n  - `customerId` and
    /// `mandateId` are required if a recurring payment should be used to set
    /// the invoice to `paid`\n  - `emailDetails` optional for `issued` and
    /// `paid` to send the invoice by email",
    ///  "examples": [
    ///    "draft"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "draft",
    ///    "issued",
    ///    "paid"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SalesInvoiceStatus {
        #[serde(rename = "draft")]
        Draft,
        #[serde(rename = "issued")]
        Issued,
        #[serde(rename = "paid")]
        Paid,
    }

    impl ::std::convert::From<&Self> for SalesInvoiceStatus {
        fn from(value: &SalesInvoiceStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SalesInvoiceStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Draft => f.write_str("draft"),
                Self::Issued => f.write_str("issued"),
                Self::Paid => f.write_str("paid"),
            }
        }
    }

    impl ::std::str::FromStr for SalesInvoiceStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "draft" => Ok(Self::Draft),
                "issued" => Ok(Self::Issued),
                "paid" => Ok(Self::Paid),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoiceStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoiceStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoiceStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The status for the invoice to end up in.
    ///
    ///A `draft` invoice is not paid or not sent and can be updated after
    /// creation. Setting it to `issued` sends it to the recipient so they
    /// may then pay through our payment system. To skip our payment process,
    /// set this to `paid` to mark it as paid. It can then subsequently be
    /// sent as well, same as with `issued`.
    ///
    ///A status value that cannot be set but can be returned is `canceled`, for
    /// invoices which were issued, but then canceled. Currently this can
    /// only be done for invoices created in the dashboard.
    ///
    ///Dependent parameters:
    ///  - `paymentDetails` is required if invoice should be set directly to
    ///    `paid`
    ///  - `customerId` and `mandateId` are required if a recurring payment
    ///    should be used to set the invoice to `paid`
    ///  - `emailDetails` optional for `issued` and `paid` to send the invoice
    ///    by email
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status for the invoice to end up in.\n\nA `draft`
    /// invoice is not paid or not sent and can be updated after creation.
    /// Setting it to `issued` sends it to\nthe recipient so they may then pay
    /// through our payment system. To skip our payment process, set this to
    /// `paid` to\nmark it as paid. It can then subsequently be sent as well,
    /// same as with `issued`.\n\nA status value that cannot be set but can be
    /// returned is `canceled`, for invoices which were\nissued, but then
    /// canceled. Currently this can only be done for invoices created in the
    /// dashboard.\n\nDependent parameters:\n  - `paymentDetails` is required if
    /// invoice should be set directly to `paid`\n  - `customerId` and
    /// `mandateId` are required if a recurring payment should be used to set
    /// the invoice to `paid`\n  - `emailDetails` optional for `issued` and
    /// `paid` to send the invoice by email",
    ///  "examples": [
    ///    "draft"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "draft",
    ///    "issued",
    ///    "paid"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SalesInvoiceStatusResponse {
        #[serde(rename = "draft")]
        Draft,
        #[serde(rename = "issued")]
        Issued,
        #[serde(rename = "paid")]
        Paid,
    }

    impl ::std::convert::From<&Self> for SalesInvoiceStatusResponse {
        fn from(value: &SalesInvoiceStatusResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SalesInvoiceStatusResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Draft => f.write_str("draft"),
                Self::Issued => f.write_str("issued"),
                Self::Paid => f.write_str("paid"),
            }
        }
    }

    impl ::std::str::FromStr for SalesInvoiceStatusResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "draft" => Ok(Self::Draft),
                "issued" => Ok(Self::Issued),
                "paid" => Ok(Self::Paid),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoiceStatusResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoiceStatusResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoiceStatusResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SalesInvoiceToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "invoice_4Y0eZitmBnQ6IDoMqZQKh"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct SalesInvoiceToken(pub ::std::string::String);
    impl ::std::ops::Deref for SalesInvoiceToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<SalesInvoiceToken> for ::std::string::String {
        fn from(value: SalesInvoiceToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SalesInvoiceToken> for SalesInvoiceToken {
        fn from(value: &SalesInvoiceToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for SalesInvoiceToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for SalesInvoiceToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for SalesInvoiceToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///The VAT mode to use for VAT calculation. `exclusive` mode means we will
    /// apply the relevant VAT on top of the price. `inclusive` means the
    /// prices you are providing to us already contain the VAT you want to
    /// apply.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The VAT mode to use for VAT calculation. `exclusive`
    /// mode means we will apply the relevant VAT on top of the\nprice.
    /// `inclusive` means the prices you are providing to us already contain the
    /// VAT you want to apply.",
    ///  "examples": [
    ///    "exclusive"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "exclusive",
    ///    "inclusive"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SalesInvoiceVatMode {
        #[serde(rename = "exclusive")]
        Exclusive,
        #[serde(rename = "inclusive")]
        Inclusive,
    }

    impl ::std::convert::From<&Self> for SalesInvoiceVatMode {
        fn from(value: &SalesInvoiceVatMode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SalesInvoiceVatMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Exclusive => f.write_str("exclusive"),
                Self::Inclusive => f.write_str("inclusive"),
            }
        }
    }

    impl ::std::str::FromStr for SalesInvoiceVatMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "exclusive" => Ok(Self::Exclusive),
                "inclusive" => Ok(Self::Inclusive),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoiceVatMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoiceVatMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoiceVatMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The VAT mode to use for VAT calculation. `exclusive` mode means we will
    /// apply the relevant VAT on top of the price. `inclusive` means the
    /// prices you are providing to us already contain the VAT you want to
    /// apply.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The VAT mode to use for VAT calculation. `exclusive`
    /// mode means we will apply the relevant VAT on top of the\nprice.
    /// `inclusive` means the prices you are providing to us already contain the
    /// VAT you want to apply.",
    ///  "examples": [
    ///    "exclusive"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "exclusive",
    ///    "inclusive"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SalesInvoiceVatModeResponse {
        #[serde(rename = "exclusive")]
        Exclusive,
        #[serde(rename = "inclusive")]
        Inclusive,
    }

    impl ::std::convert::From<&Self> for SalesInvoiceVatModeResponse {
        fn from(value: &SalesInvoiceVatModeResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SalesInvoiceVatModeResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Exclusive => f.write_str("exclusive"),
                Self::Inclusive => f.write_str("inclusive"),
            }
        }
    }

    impl ::std::str::FromStr for SalesInvoiceVatModeResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "exclusive" => Ok(Self::Exclusive),
                "inclusive" => Ok(Self::Inclusive),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoiceVatModeResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoiceVatModeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoiceVatModeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The VAT scheme to create the invoice for. You must be enrolled with One
    /// Stop Shop enabled to use it.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The VAT scheme to create the invoice for. You must be
    /// enrolled with One Stop Shop enabled to use it.",
    ///  "examples": [
    ///    "standard"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "standard",
    ///    "one-stop-shop"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SalesInvoiceVatScheme {
        #[serde(rename = "standard")]
        Standard,
        #[serde(rename = "one-stop-shop")]
        OneStopShop,
    }

    impl ::std::convert::From<&Self> for SalesInvoiceVatScheme {
        fn from(value: &SalesInvoiceVatScheme) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SalesInvoiceVatScheme {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Standard => f.write_str("standard"),
                Self::OneStopShop => f.write_str("one-stop-shop"),
            }
        }
    }

    impl ::std::str::FromStr for SalesInvoiceVatScheme {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "standard" => Ok(Self::Standard),
                "one-stop-shop" => Ok(Self::OneStopShop),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoiceVatScheme {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoiceVatScheme {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoiceVatScheme {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The VAT scheme to create the invoice for. You must be enrolled with One
    /// Stop Shop enabled to use it.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The VAT scheme to create the invoice for. You must be
    /// enrolled with One Stop Shop enabled to use it.",
    ///  "examples": [
    ///    "standard"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "standard",
    ///    "one-stop-shop"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SalesInvoiceVatSchemeResponse {
        #[serde(rename = "standard")]
        Standard,
        #[serde(rename = "one-stop-shop")]
        OneStopShop,
    }

    impl ::std::convert::From<&Self> for SalesInvoiceVatSchemeResponse {
        fn from(value: &SalesInvoiceVatSchemeResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SalesInvoiceVatSchemeResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Standard => f.write_str("standard"),
                Self::OneStopShop => f.write_str("one-stop-shop"),
            }
        }
    }

    impl ::std::str::FromStr for SalesInvoiceVatSchemeResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "standard" => Ok(Self::Standard),
                "one-stop-shop" => Ok(Self::OneStopShop),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SalesInvoiceVatSchemeResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SalesInvoiceVatSchemeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SalesInvoiceVatSchemeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SequenceType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "oneoff"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "oneoff",
    ///    "first",
    ///    "recurring"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SequenceType {
        #[serde(rename = "oneoff")]
        Oneoff,
        #[serde(rename = "first")]
        First,
        #[serde(rename = "recurring")]
        Recurring,
    }

    impl ::std::convert::From<&Self> for SequenceType {
        fn from(value: &SequenceType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SequenceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Oneoff => f.write_str("oneoff"),
                Self::First => f.write_str("first"),
                Self::Recurring => f.write_str("recurring"),
            }
        }
    }

    impl ::std::str::FromStr for SequenceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "oneoff" => Ok(Self::Oneoff),
                "first" => Ok(Self::First),
                "recurring" => Ok(Self::Recurring),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SequenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SequenceType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SequenceType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SequenceTypeResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "oneoff"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "oneoff",
    ///    "first",
    ///    "recurring"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SequenceTypeResponse {
        #[serde(rename = "oneoff")]
        Oneoff,
        #[serde(rename = "first")]
        First,
        #[serde(rename = "recurring")]
        Recurring,
    }

    impl ::std::convert::From<&Self> for SequenceTypeResponse {
        fn from(value: &SequenceTypeResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SequenceTypeResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Oneoff => f.write_str("oneoff"),
                Self::First => f.write_str("first"),
                Self::Recurring => f.write_str("recurring"),
            }
        }
    }

    impl ::std::str::FromStr for SequenceTypeResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "oneoff" => Ok(Self::Oneoff),
                "first" => Ok(Self::First),
                "recurring" => Ok(Self::Recurring),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SequenceTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SequenceTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SequenceTypeResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The status of the settlement.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status of the settlement.",
    ///  "examples": [
    ///    "paidout"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "open",
    ///    "pending",
    ///    "paidout",
    ///    "failed"
    ///  ],
    ///  "x-enumDescriptions": {
    ///    "failed": "The settlement could not be paid out",
    ///    "open": "The settlement has not been closed yet",
    ///    "paidout": "The settlement has been paid out",
    ///    "pending": "The settlement has been closed and is being processed"
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SettlementStatus {
        #[serde(rename = "open")]
        Open,
        #[serde(rename = "pending")]
        Pending,
        #[serde(rename = "paidout")]
        Paidout,
        #[serde(rename = "failed")]
        Failed,
    }

    impl ::std::convert::From<&Self> for SettlementStatus {
        fn from(value: &SettlementStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SettlementStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Open => f.write_str("open"),
                Self::Pending => f.write_str("pending"),
                Self::Paidout => f.write_str("paidout"),
                Self::Failed => f.write_str("failed"),
            }
        }
    }

    impl ::std::str::FromStr for SettlementStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "open" => Ok(Self::Open),
                "pending" => Ok(Self::Pending),
                "paidout" => Ok(Self::Paidout),
                "failed" => Ok(Self::Failed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SettlementStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SettlementStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SettlementStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SettlementToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "stl_5B8cwPMGnU"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct SettlementToken(pub ::std::string::String);
    impl ::std::ops::Deref for SettlementToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<SettlementToken> for ::std::string::String {
        fn from(value: SettlementToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SettlementToken> for SettlementToken {
        fn from(value: &SettlementToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for SettlementToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for SettlementToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for SettlementToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`ShipmentToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "shp_5x4xQJDWGNcY3tKGL7X5J"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct ShipmentToken(pub ::std::string::String);
    impl ::std::ops::Deref for ShipmentToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<ShipmentToken> for ::std::string::String {
        fn from(value: ShipmentToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&ShipmentToken> for ShipmentToken {
        fn from(value: &ShipmentToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for ShipmentToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for ShipmentToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for ShipmentToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///This object offers details about the status of a payment. Currently it
    /// is only available for point-of-sale payments.
    ///
    ///You can find more information about the possible values of this object
    /// on [this page](status-reasons).**
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This object offers details about the status of a
    /// payment. Currently it is only available for
    /// point-of-sale\npayments.\n\nYou can find more information about the
    /// possible values of this object on\n[this page](status-reasons).**",
    ///  "readOnly": true,
    ///  "type": [
    ///    "object",
    ///    "null"
    ///  ],
    ///  "required": [
    ///    "code",
    ///    "message"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "allOf": [
    ///        {
    ///          "description": "A machine-readable code that indicates the
    /// reason for the payment's status.",
    ///          "examples": [
    ///            "insufficient_funds"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "string",
    ///          "enum": [
    ///            "approved_or_completed_successfully",
    ///            "refer_to_card_issuer",
    ///            "invalid_merchant",
    ///            "capture_card",
    ///            "do_not_honor",
    ///            "error",
    ///            "partial_approval",
    ///            "invalid_transaction",
    ///            "invalid_amount",
    ///            "invalid_issuer",
    ///            "lost_card",
    ///            "stolen_card",
    ///            "insufficient_funds",
    ///            "expired_card",
    ///            "invalid_pin",
    ///            "transaction_not_permitted_to_cardholder",
    ///            "transaction_not_allowed_at_terminal",
    ///            "exceeds_withdrawal_amount_limit",
    ///            "restricted_card",
    ///            "security_violation",
    ///            "exceeds_withdrawal_count_limit",
    ///            "allowable_number_of_pin_tries_exceeded",
    ///            "no_reason_to_decline",
    ///            "cannot_verify_pin",
    ///            "issuer_unavailable",
    ///            "unable_to_route_transaction",
    ///            "duplicate_transaction",
    ///            "system_malfunction",
    ///            "honor_with_id",
    ///            "invalid_card_number",
    ///            "format_error",
    ///            "contact_card_issuer",
    ///            "pin_not_changed",
    ///            "invalid_nonexistent_to_account_specified",
    ///            "invalid_nonexistent_from_account_specified",
    ///            "invalid_nonexistent_account_specified",
    ///            "lifecycle_related",
    ///            "domestic_debit_transaction_not_allowed",
    ///            "policy_related",
    ///            "fraud_security_related",
    ///            "invalid_authorization_life_cycle",
    ///            "purchase_amount_only_no_cash_back_allowed",
    ///            "cryptographic_failure",
    ///            "unacceptable_pin",
    ///            "refer_to_card_issuer_special_condition",
    ///            "pick_up_card_special_condition",
    ///            "vip_approval",
    ///            "invalid_account_number",
    ///            "re_enter_transaction",
    ///            "no_action_taken",
    ///            "unable_to_locate_record",
    ///            "file_temporarily_unavailable",
    ///            "no_credit_account",
    ///            "closed_account",
    ///            "no_checking_account",
    ///            "no_savings_account",
    ///            "suspected_fraud",
    ///            "transaction_does_not_fulfill_aml_requirement",
    ///            "pin_data_required",
    ///            "unable_to_locate_previous_message",
    ///            "previous_message_located_inconsistent_data",
    ///            "blocked_first_used",
    ///            "transaction_reversed",
    ///            "credit_issuer_unavailable",
    ///            "pin_cryptographic_error_found",
    ///            "negative_online_cam_result",
    ///            "violation_of_law",
    ///            "force_stip",
    ///            "cash_service_not_available",
    ///            "cashback_request_exceeds_issuer_limit",
    ///            "decline_for_cvv2_failure",
    ///            "transaction_amount_exceeds_pre_authorized_amount",
    ///            "invalid_biller_information",
    ///            "pin_change_unblock_request_declined",
    ///            "unsafe_pin",
    ///            "card_authentication_failed",
    ///            "stop_payment_order",
    ///            "revocation_of_authorization",
    ///            "revocation_of_all_authorizations",
    ///            "forward_to_issuer_xa",
    ///            "forward_to_issuer_xd",
    ///            "unable_to_go_online",
    ///            "additional_customer_authentication_required",
    ///            "merchant_id_not_found",
    ///            "merchant_account_closed",
    ///            "terminal_id_not_found",
    ///            "terminal_closed",
    ///            "invalid_category_code",
    ///            "invalid_currency",
    ///            "missing_cvv2_cvc2",
    ///            "cvv2_not_allowed",
    ///            "merchant_not_registered_vbv",
    ///            "merchant_not_registered_for_amex",
    ///            "transaction_not_permitted_at_terminal",
    ///            "agreement_terminal_not_related",
    ///            "invalid_processor_id",
    ///            "invalid_merchant_data",
    ///            "sub_merchant_account_closed",
    ///            "terminal_busy",
    ///            "terminal_unreachable",
    ///            "service_failed",
    ///            "invalid_operation",
    ///            "authorization_error",
    ///            "login_failed_without_reason",
    ///            "invalid_retailer",
    ///            "card_does_not_exist",
    ///            "card_is_blocked",
    ///            "invalid_card_id",
    ///            "card_is_transferred",
    ///            "card_is_not_active",
    ///            "incorrect_purchase_value",
    ///            "card_not_available",
    ///            "wrong_currency",
    ///            "login_failed_unknown_user",
    ///            "login_failed_invalid_password",
    ///            "invalid_ean_code"
    ///          ],
    ///          "x-methodSpecific": true
    ///        }
    ///      ]
    ///    },
    ///    "message": {
    ///      "description": "A description of the status reason, localized
    /// according to the payment `locale`.",
    ///      "examples": [
    ///        "The account associated with the card has insufficient funds. The
    /// shopper should use another payment method or\ncontact their bank."
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct StatusReason(pub ::std::option::Option<StatusReasonInner>);
    impl ::std::ops::Deref for StatusReason {
        type Target = ::std::option::Option<StatusReasonInner>;
        fn deref(&self) -> &::std::option::Option<StatusReasonInner> {
            &self.0
        }
    }

    impl ::std::convert::From<StatusReason> for ::std::option::Option<StatusReasonInner> {
        fn from(value: StatusReason) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&StatusReason> for StatusReason {
        fn from(value: &StatusReason) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<StatusReasonInner>> for StatusReason {
        fn from(value: ::std::option::Option<StatusReasonInner>) -> Self {
            Self(value)
        }
    }

    ///This object offers details about the status of a payment. Currently it
    /// is only available for point-of-sale payments.
    ///
    ///You can find more information about the possible values of this object
    /// on [this page](status-reasons).**
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This object offers details about the status of a
    /// payment. Currently it is only available for
    /// point-of-sale\npayments.\n\nYou can find more information about the
    /// possible values of this object on\n[this page](status-reasons).**",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "message"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "allOf": [
    ///        {
    ///          "description": "A machine-readable code that indicates the
    /// reason for the payment's status.",
    ///          "examples": [
    ///            "insufficient_funds"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "string",
    ///          "enum": [
    ///            "approved_or_completed_successfully",
    ///            "refer_to_card_issuer",
    ///            "invalid_merchant",
    ///            "capture_card",
    ///            "do_not_honor",
    ///            "error",
    ///            "partial_approval",
    ///            "invalid_transaction",
    ///            "invalid_amount",
    ///            "invalid_issuer",
    ///            "lost_card",
    ///            "stolen_card",
    ///            "insufficient_funds",
    ///            "expired_card",
    ///            "invalid_pin",
    ///            "transaction_not_permitted_to_cardholder",
    ///            "transaction_not_allowed_at_terminal",
    ///            "exceeds_withdrawal_amount_limit",
    ///            "restricted_card",
    ///            "security_violation",
    ///            "exceeds_withdrawal_count_limit",
    ///            "allowable_number_of_pin_tries_exceeded",
    ///            "no_reason_to_decline",
    ///            "cannot_verify_pin",
    ///            "issuer_unavailable",
    ///            "unable_to_route_transaction",
    ///            "duplicate_transaction",
    ///            "system_malfunction",
    ///            "honor_with_id",
    ///            "invalid_card_number",
    ///            "format_error",
    ///            "contact_card_issuer",
    ///            "pin_not_changed",
    ///            "invalid_nonexistent_to_account_specified",
    ///            "invalid_nonexistent_from_account_specified",
    ///            "invalid_nonexistent_account_specified",
    ///            "lifecycle_related",
    ///            "domestic_debit_transaction_not_allowed",
    ///            "policy_related",
    ///            "fraud_security_related",
    ///            "invalid_authorization_life_cycle",
    ///            "purchase_amount_only_no_cash_back_allowed",
    ///            "cryptographic_failure",
    ///            "unacceptable_pin",
    ///            "refer_to_card_issuer_special_condition",
    ///            "pick_up_card_special_condition",
    ///            "vip_approval",
    ///            "invalid_account_number",
    ///            "re_enter_transaction",
    ///            "no_action_taken",
    ///            "unable_to_locate_record",
    ///            "file_temporarily_unavailable",
    ///            "no_credit_account",
    ///            "closed_account",
    ///            "no_checking_account",
    ///            "no_savings_account",
    ///            "suspected_fraud",
    ///            "transaction_does_not_fulfill_aml_requirement",
    ///            "pin_data_required",
    ///            "unable_to_locate_previous_message",
    ///            "previous_message_located_inconsistent_data",
    ///            "blocked_first_used",
    ///            "transaction_reversed",
    ///            "credit_issuer_unavailable",
    ///            "pin_cryptographic_error_found",
    ///            "negative_online_cam_result",
    ///            "violation_of_law",
    ///            "force_stip",
    ///            "cash_service_not_available",
    ///            "cashback_request_exceeds_issuer_limit",
    ///            "decline_for_cvv2_failure",
    ///            "transaction_amount_exceeds_pre_authorized_amount",
    ///            "invalid_biller_information",
    ///            "pin_change_unblock_request_declined",
    ///            "unsafe_pin",
    ///            "card_authentication_failed",
    ///            "stop_payment_order",
    ///            "revocation_of_authorization",
    ///            "revocation_of_all_authorizations",
    ///            "forward_to_issuer_xa",
    ///            "forward_to_issuer_xd",
    ///            "unable_to_go_online",
    ///            "additional_customer_authentication_required",
    ///            "merchant_id_not_found",
    ///            "merchant_account_closed",
    ///            "terminal_id_not_found",
    ///            "terminal_closed",
    ///            "invalid_category_code",
    ///            "invalid_currency",
    ///            "missing_cvv2_cvc2",
    ///            "cvv2_not_allowed",
    ///            "merchant_not_registered_vbv",
    ///            "merchant_not_registered_for_amex",
    ///            "transaction_not_permitted_at_terminal",
    ///            "agreement_terminal_not_related",
    ///            "invalid_processor_id",
    ///            "invalid_merchant_data",
    ///            "sub_merchant_account_closed",
    ///            "terminal_busy",
    ///            "terminal_unreachable",
    ///            "service_failed",
    ///            "invalid_operation",
    ///            "authorization_error",
    ///            "login_failed_without_reason",
    ///            "invalid_retailer",
    ///            "card_does_not_exist",
    ///            "card_is_blocked",
    ///            "invalid_card_id",
    ///            "card_is_transferred",
    ///            "card_is_not_active",
    ///            "incorrect_purchase_value",
    ///            "card_not_available",
    ///            "wrong_currency",
    ///            "login_failed_unknown_user",
    ///            "login_failed_invalid_password",
    ///            "invalid_ean_code"
    ///          ],
    ///          "x-methodSpecific": true
    ///        }
    ///      ]
    ///    },
    ///    "message": {
    ///      "description": "A description of the status reason, localized
    /// according to the payment `locale`.",
    ///      "examples": [
    ///        "The account associated with the card has insufficient funds. The
    /// shopper should use another payment method or\ncontact their bank."
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct StatusReasonInner {
        pub code: StatusReasonInnerCode,
        ///A description of the status reason, localized according to the
        /// payment `locale`.
        pub message: ::std::string::String,
    }

    impl ::std::convert::From<&StatusReasonInner> for StatusReasonInner {
        fn from(value: &StatusReasonInner) -> Self {
            value.clone()
        }
    }

    ///`StatusReasonInnerCode`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "description": "A machine-readable code that indicates the reason
    /// for the payment's status.",
    ///      "examples": [
    ///        "insufficient_funds"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "string",
    ///      "enum": [
    ///        "approved_or_completed_successfully",
    ///        "refer_to_card_issuer",
    ///        "invalid_merchant",
    ///        "capture_card",
    ///        "do_not_honor",
    ///        "error",
    ///        "partial_approval",
    ///        "invalid_transaction",
    ///        "invalid_amount",
    ///        "invalid_issuer",
    ///        "lost_card",
    ///        "stolen_card",
    ///        "insufficient_funds",
    ///        "expired_card",
    ///        "invalid_pin",
    ///        "transaction_not_permitted_to_cardholder",
    ///        "transaction_not_allowed_at_terminal",
    ///        "exceeds_withdrawal_amount_limit",
    ///        "restricted_card",
    ///        "security_violation",
    ///        "exceeds_withdrawal_count_limit",
    ///        "allowable_number_of_pin_tries_exceeded",
    ///        "no_reason_to_decline",
    ///        "cannot_verify_pin",
    ///        "issuer_unavailable",
    ///        "unable_to_route_transaction",
    ///        "duplicate_transaction",
    ///        "system_malfunction",
    ///        "honor_with_id",
    ///        "invalid_card_number",
    ///        "format_error",
    ///        "contact_card_issuer",
    ///        "pin_not_changed",
    ///        "invalid_nonexistent_to_account_specified",
    ///        "invalid_nonexistent_from_account_specified",
    ///        "invalid_nonexistent_account_specified",
    ///        "lifecycle_related",
    ///        "domestic_debit_transaction_not_allowed",
    ///        "policy_related",
    ///        "fraud_security_related",
    ///        "invalid_authorization_life_cycle",
    ///        "purchase_amount_only_no_cash_back_allowed",
    ///        "cryptographic_failure",
    ///        "unacceptable_pin",
    ///        "refer_to_card_issuer_special_condition",
    ///        "pick_up_card_special_condition",
    ///        "vip_approval",
    ///        "invalid_account_number",
    ///        "re_enter_transaction",
    ///        "no_action_taken",
    ///        "unable_to_locate_record",
    ///        "file_temporarily_unavailable",
    ///        "no_credit_account",
    ///        "closed_account",
    ///        "no_checking_account",
    ///        "no_savings_account",
    ///        "suspected_fraud",
    ///        "transaction_does_not_fulfill_aml_requirement",
    ///        "pin_data_required",
    ///        "unable_to_locate_previous_message",
    ///        "previous_message_located_inconsistent_data",
    ///        "blocked_first_used",
    ///        "transaction_reversed",
    ///        "credit_issuer_unavailable",
    ///        "pin_cryptographic_error_found",
    ///        "negative_online_cam_result",
    ///        "violation_of_law",
    ///        "force_stip",
    ///        "cash_service_not_available",
    ///        "cashback_request_exceeds_issuer_limit",
    ///        "decline_for_cvv2_failure",
    ///        "transaction_amount_exceeds_pre_authorized_amount",
    ///        "invalid_biller_information",
    ///        "pin_change_unblock_request_declined",
    ///        "unsafe_pin",
    ///        "card_authentication_failed",
    ///        "stop_payment_order",
    ///        "revocation_of_authorization",
    ///        "revocation_of_all_authorizations",
    ///        "forward_to_issuer_xa",
    ///        "forward_to_issuer_xd",
    ///        "unable_to_go_online",
    ///        "additional_customer_authentication_required",
    ///        "merchant_id_not_found",
    ///        "merchant_account_closed",
    ///        "terminal_id_not_found",
    ///        "terminal_closed",
    ///        "invalid_category_code",
    ///        "invalid_currency",
    ///        "missing_cvv2_cvc2",
    ///        "cvv2_not_allowed",
    ///        "merchant_not_registered_vbv",
    ///        "merchant_not_registered_for_amex",
    ///        "transaction_not_permitted_at_terminal",
    ///        "agreement_terminal_not_related",
    ///        "invalid_processor_id",
    ///        "invalid_merchant_data",
    ///        "sub_merchant_account_closed",
    ///        "terminal_busy",
    ///        "terminal_unreachable",
    ///        "service_failed",
    ///        "invalid_operation",
    ///        "authorization_error",
    ///        "login_failed_without_reason",
    ///        "invalid_retailer",
    ///        "card_does_not_exist",
    ///        "card_is_blocked",
    ///        "invalid_card_id",
    ///        "card_is_transferred",
    ///        "card_is_not_active",
    ///        "incorrect_purchase_value",
    ///        "card_not_available",
    ///        "wrong_currency",
    ///        "login_failed_unknown_user",
    ///        "login_failed_invalid_password",
    ///        "invalid_ean_code"
    ///      ],
    ///      "x-methodSpecific": true
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum StatusReasonInnerCode {
        #[serde(rename = "approved_or_completed_successfully")]
        ApprovedOrCompletedSuccessfully,
        #[serde(rename = "refer_to_card_issuer")]
        ReferToCardIssuer,
        #[serde(rename = "invalid_merchant")]
        InvalidMerchant,
        #[serde(rename = "capture_card")]
        CaptureCard,
        #[serde(rename = "do_not_honor")]
        DoNotHonor,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "partial_approval")]
        PartialApproval,
        #[serde(rename = "invalid_transaction")]
        InvalidTransaction,
        #[serde(rename = "invalid_amount")]
        InvalidAmount,
        #[serde(rename = "invalid_issuer")]
        InvalidIssuer,
        #[serde(rename = "lost_card")]
        LostCard,
        #[serde(rename = "stolen_card")]
        StolenCard,
        #[serde(rename = "insufficient_funds")]
        InsufficientFunds,
        #[serde(rename = "expired_card")]
        ExpiredCard,
        #[serde(rename = "invalid_pin")]
        InvalidPin,
        #[serde(rename = "transaction_not_permitted_to_cardholder")]
        TransactionNotPermittedToCardholder,
        #[serde(rename = "transaction_not_allowed_at_terminal")]
        TransactionNotAllowedAtTerminal,
        #[serde(rename = "exceeds_withdrawal_amount_limit")]
        ExceedsWithdrawalAmountLimit,
        #[serde(rename = "restricted_card")]
        RestrictedCard,
        #[serde(rename = "security_violation")]
        SecurityViolation,
        #[serde(rename = "exceeds_withdrawal_count_limit")]
        ExceedsWithdrawalCountLimit,
        #[serde(rename = "allowable_number_of_pin_tries_exceeded")]
        AllowableNumberOfPinTriesExceeded,
        #[serde(rename = "no_reason_to_decline")]
        NoReasonToDecline,
        #[serde(rename = "cannot_verify_pin")]
        CannotVerifyPin,
        #[serde(rename = "issuer_unavailable")]
        IssuerUnavailable,
        #[serde(rename = "unable_to_route_transaction")]
        UnableToRouteTransaction,
        #[serde(rename = "duplicate_transaction")]
        DuplicateTransaction,
        #[serde(rename = "system_malfunction")]
        SystemMalfunction,
        #[serde(rename = "honor_with_id")]
        HonorWithId,
        #[serde(rename = "invalid_card_number")]
        InvalidCardNumber,
        #[serde(rename = "format_error")]
        FormatError,
        #[serde(rename = "contact_card_issuer")]
        ContactCardIssuer,
        #[serde(rename = "pin_not_changed")]
        PinNotChanged,
        #[serde(rename = "invalid_nonexistent_to_account_specified")]
        InvalidNonexistentToAccountSpecified,
        #[serde(rename = "invalid_nonexistent_from_account_specified")]
        InvalidNonexistentFromAccountSpecified,
        #[serde(rename = "invalid_nonexistent_account_specified")]
        InvalidNonexistentAccountSpecified,
        #[serde(rename = "lifecycle_related")]
        LifecycleRelated,
        #[serde(rename = "domestic_debit_transaction_not_allowed")]
        DomesticDebitTransactionNotAllowed,
        #[serde(rename = "policy_related")]
        PolicyRelated,
        #[serde(rename = "fraud_security_related")]
        FraudSecurityRelated,
        #[serde(rename = "invalid_authorization_life_cycle")]
        InvalidAuthorizationLifeCycle,
        #[serde(rename = "purchase_amount_only_no_cash_back_allowed")]
        PurchaseAmountOnlyNoCashBackAllowed,
        #[serde(rename = "cryptographic_failure")]
        CryptographicFailure,
        #[serde(rename = "unacceptable_pin")]
        UnacceptablePin,
        #[serde(rename = "refer_to_card_issuer_special_condition")]
        ReferToCardIssuerSpecialCondition,
        #[serde(rename = "pick_up_card_special_condition")]
        PickUpCardSpecialCondition,
        #[serde(rename = "vip_approval")]
        VipApproval,
        #[serde(rename = "invalid_account_number")]
        InvalidAccountNumber,
        #[serde(rename = "re_enter_transaction")]
        ReEnterTransaction,
        #[serde(rename = "no_action_taken")]
        NoActionTaken,
        #[serde(rename = "unable_to_locate_record")]
        UnableToLocateRecord,
        #[serde(rename = "file_temporarily_unavailable")]
        FileTemporarilyUnavailable,
        #[serde(rename = "no_credit_account")]
        NoCreditAccount,
        #[serde(rename = "closed_account")]
        ClosedAccount,
        #[serde(rename = "no_checking_account")]
        NoCheckingAccount,
        #[serde(rename = "no_savings_account")]
        NoSavingsAccount,
        #[serde(rename = "suspected_fraud")]
        SuspectedFraud,
        #[serde(rename = "transaction_does_not_fulfill_aml_requirement")]
        TransactionDoesNotFulfillAmlRequirement,
        #[serde(rename = "pin_data_required")]
        PinDataRequired,
        #[serde(rename = "unable_to_locate_previous_message")]
        UnableToLocatePreviousMessage,
        #[serde(rename = "previous_message_located_inconsistent_data")]
        PreviousMessageLocatedInconsistentData,
        #[serde(rename = "blocked_first_used")]
        BlockedFirstUsed,
        #[serde(rename = "transaction_reversed")]
        TransactionReversed,
        #[serde(rename = "credit_issuer_unavailable")]
        CreditIssuerUnavailable,
        #[serde(rename = "pin_cryptographic_error_found")]
        PinCryptographicErrorFound,
        #[serde(rename = "negative_online_cam_result")]
        NegativeOnlineCamResult,
        #[serde(rename = "violation_of_law")]
        ViolationOfLaw,
        #[serde(rename = "force_stip")]
        ForceStip,
        #[serde(rename = "cash_service_not_available")]
        CashServiceNotAvailable,
        #[serde(rename = "cashback_request_exceeds_issuer_limit")]
        CashbackRequestExceedsIssuerLimit,
        #[serde(rename = "decline_for_cvv2_failure")]
        DeclineForCvv2Failure,
        #[serde(rename = "transaction_amount_exceeds_pre_authorized_amount")]
        TransactionAmountExceedsPreAuthorizedAmount,
        #[serde(rename = "invalid_biller_information")]
        InvalidBillerInformation,
        #[serde(rename = "pin_change_unblock_request_declined")]
        PinChangeUnblockRequestDeclined,
        #[serde(rename = "unsafe_pin")]
        UnsafePin,
        #[serde(rename = "card_authentication_failed")]
        CardAuthenticationFailed,
        #[serde(rename = "stop_payment_order")]
        StopPaymentOrder,
        #[serde(rename = "revocation_of_authorization")]
        RevocationOfAuthorization,
        #[serde(rename = "revocation_of_all_authorizations")]
        RevocationOfAllAuthorizations,
        #[serde(rename = "forward_to_issuer_xa")]
        ForwardToIssuerXa,
        #[serde(rename = "forward_to_issuer_xd")]
        ForwardToIssuerXd,
        #[serde(rename = "unable_to_go_online")]
        UnableToGoOnline,
        #[serde(rename = "additional_customer_authentication_required")]
        AdditionalCustomerAuthenticationRequired,
        #[serde(rename = "merchant_id_not_found")]
        MerchantIdNotFound,
        #[serde(rename = "merchant_account_closed")]
        MerchantAccountClosed,
        #[serde(rename = "terminal_id_not_found")]
        TerminalIdNotFound,
        #[serde(rename = "terminal_closed")]
        TerminalClosed,
        #[serde(rename = "invalid_category_code")]
        InvalidCategoryCode,
        #[serde(rename = "invalid_currency")]
        InvalidCurrency,
        #[serde(rename = "missing_cvv2_cvc2")]
        MissingCvv2Cvc2,
        #[serde(rename = "cvv2_not_allowed")]
        Cvv2NotAllowed,
        #[serde(rename = "merchant_not_registered_vbv")]
        MerchantNotRegisteredVbv,
        #[serde(rename = "merchant_not_registered_for_amex")]
        MerchantNotRegisteredForAmex,
        #[serde(rename = "transaction_not_permitted_at_terminal")]
        TransactionNotPermittedAtTerminal,
        #[serde(rename = "agreement_terminal_not_related")]
        AgreementTerminalNotRelated,
        #[serde(rename = "invalid_processor_id")]
        InvalidProcessorId,
        #[serde(rename = "invalid_merchant_data")]
        InvalidMerchantData,
        #[serde(rename = "sub_merchant_account_closed")]
        SubMerchantAccountClosed,
        #[serde(rename = "terminal_busy")]
        TerminalBusy,
        #[serde(rename = "terminal_unreachable")]
        TerminalUnreachable,
        #[serde(rename = "service_failed")]
        ServiceFailed,
        #[serde(rename = "invalid_operation")]
        InvalidOperation,
        #[serde(rename = "authorization_error")]
        AuthorizationError,
        #[serde(rename = "login_failed_without_reason")]
        LoginFailedWithoutReason,
        #[serde(rename = "invalid_retailer")]
        InvalidRetailer,
        #[serde(rename = "card_does_not_exist")]
        CardDoesNotExist,
        #[serde(rename = "card_is_blocked")]
        CardIsBlocked,
        #[serde(rename = "invalid_card_id")]
        InvalidCardId,
        #[serde(rename = "card_is_transferred")]
        CardIsTransferred,
        #[serde(rename = "card_is_not_active")]
        CardIsNotActive,
        #[serde(rename = "incorrect_purchase_value")]
        IncorrectPurchaseValue,
        #[serde(rename = "card_not_available")]
        CardNotAvailable,
        #[serde(rename = "wrong_currency")]
        WrongCurrency,
        #[serde(rename = "login_failed_unknown_user")]
        LoginFailedUnknownUser,
        #[serde(rename = "login_failed_invalid_password")]
        LoginFailedInvalidPassword,
        #[serde(rename = "invalid_ean_code")]
        InvalidEanCode,
    }

    impl ::std::convert::From<&Self> for StatusReasonInnerCode {
        fn from(value: &StatusReasonInnerCode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for StatusReasonInnerCode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ApprovedOrCompletedSuccessfully => {
                    f.write_str("approved_or_completed_successfully")
                }
                Self::ReferToCardIssuer => f.write_str("refer_to_card_issuer"),
                Self::InvalidMerchant => f.write_str("invalid_merchant"),
                Self::CaptureCard => f.write_str("capture_card"),
                Self::DoNotHonor => f.write_str("do_not_honor"),
                Self::Error => f.write_str("error"),
                Self::PartialApproval => f.write_str("partial_approval"),
                Self::InvalidTransaction => f.write_str("invalid_transaction"),
                Self::InvalidAmount => f.write_str("invalid_amount"),
                Self::InvalidIssuer => f.write_str("invalid_issuer"),
                Self::LostCard => f.write_str("lost_card"),
                Self::StolenCard => f.write_str("stolen_card"),
                Self::InsufficientFunds => f.write_str("insufficient_funds"),
                Self::ExpiredCard => f.write_str("expired_card"),
                Self::InvalidPin => f.write_str("invalid_pin"),
                Self::TransactionNotPermittedToCardholder => {
                    f.write_str("transaction_not_permitted_to_cardholder")
                }
                Self::TransactionNotAllowedAtTerminal => {
                    f.write_str("transaction_not_allowed_at_terminal")
                }
                Self::ExceedsWithdrawalAmountLimit => {
                    f.write_str("exceeds_withdrawal_amount_limit")
                }
                Self::RestrictedCard => f.write_str("restricted_card"),
                Self::SecurityViolation => f.write_str("security_violation"),
                Self::ExceedsWithdrawalCountLimit => f.write_str("exceeds_withdrawal_count_limit"),
                Self::AllowableNumberOfPinTriesExceeded => {
                    f.write_str("allowable_number_of_pin_tries_exceeded")
                }
                Self::NoReasonToDecline => f.write_str("no_reason_to_decline"),
                Self::CannotVerifyPin => f.write_str("cannot_verify_pin"),
                Self::IssuerUnavailable => f.write_str("issuer_unavailable"),
                Self::UnableToRouteTransaction => f.write_str("unable_to_route_transaction"),
                Self::DuplicateTransaction => f.write_str("duplicate_transaction"),
                Self::SystemMalfunction => f.write_str("system_malfunction"),
                Self::HonorWithId => f.write_str("honor_with_id"),
                Self::InvalidCardNumber => f.write_str("invalid_card_number"),
                Self::FormatError => f.write_str("format_error"),
                Self::ContactCardIssuer => f.write_str("contact_card_issuer"),
                Self::PinNotChanged => f.write_str("pin_not_changed"),
                Self::InvalidNonexistentToAccountSpecified => {
                    f.write_str("invalid_nonexistent_to_account_specified")
                }
                Self::InvalidNonexistentFromAccountSpecified => {
                    f.write_str("invalid_nonexistent_from_account_specified")
                }
                Self::InvalidNonexistentAccountSpecified => {
                    f.write_str("invalid_nonexistent_account_specified")
                }
                Self::LifecycleRelated => f.write_str("lifecycle_related"),
                Self::DomesticDebitTransactionNotAllowed => {
                    f.write_str("domestic_debit_transaction_not_allowed")
                }
                Self::PolicyRelated => f.write_str("policy_related"),
                Self::FraudSecurityRelated => f.write_str("fraud_security_related"),
                Self::InvalidAuthorizationLifeCycle => {
                    f.write_str("invalid_authorization_life_cycle")
                }
                Self::PurchaseAmountOnlyNoCashBackAllowed => {
                    f.write_str("purchase_amount_only_no_cash_back_allowed")
                }
                Self::CryptographicFailure => f.write_str("cryptographic_failure"),
                Self::UnacceptablePin => f.write_str("unacceptable_pin"),
                Self::ReferToCardIssuerSpecialCondition => {
                    f.write_str("refer_to_card_issuer_special_condition")
                }
                Self::PickUpCardSpecialCondition => f.write_str("pick_up_card_special_condition"),
                Self::VipApproval => f.write_str("vip_approval"),
                Self::InvalidAccountNumber => f.write_str("invalid_account_number"),
                Self::ReEnterTransaction => f.write_str("re_enter_transaction"),
                Self::NoActionTaken => f.write_str("no_action_taken"),
                Self::UnableToLocateRecord => f.write_str("unable_to_locate_record"),
                Self::FileTemporarilyUnavailable => f.write_str("file_temporarily_unavailable"),
                Self::NoCreditAccount => f.write_str("no_credit_account"),
                Self::ClosedAccount => f.write_str("closed_account"),
                Self::NoCheckingAccount => f.write_str("no_checking_account"),
                Self::NoSavingsAccount => f.write_str("no_savings_account"),
                Self::SuspectedFraud => f.write_str("suspected_fraud"),
                Self::TransactionDoesNotFulfillAmlRequirement => {
                    f.write_str("transaction_does_not_fulfill_aml_requirement")
                }
                Self::PinDataRequired => f.write_str("pin_data_required"),
                Self::UnableToLocatePreviousMessage => {
                    f.write_str("unable_to_locate_previous_message")
                }
                Self::PreviousMessageLocatedInconsistentData => {
                    f.write_str("previous_message_located_inconsistent_data")
                }
                Self::BlockedFirstUsed => f.write_str("blocked_first_used"),
                Self::TransactionReversed => f.write_str("transaction_reversed"),
                Self::CreditIssuerUnavailable => f.write_str("credit_issuer_unavailable"),
                Self::PinCryptographicErrorFound => f.write_str("pin_cryptographic_error_found"),
                Self::NegativeOnlineCamResult => f.write_str("negative_online_cam_result"),
                Self::ViolationOfLaw => f.write_str("violation_of_law"),
                Self::ForceStip => f.write_str("force_stip"),
                Self::CashServiceNotAvailable => f.write_str("cash_service_not_available"),
                Self::CashbackRequestExceedsIssuerLimit => {
                    f.write_str("cashback_request_exceeds_issuer_limit")
                }
                Self::DeclineForCvv2Failure => f.write_str("decline_for_cvv2_failure"),
                Self::TransactionAmountExceedsPreAuthorizedAmount => {
                    f.write_str("transaction_amount_exceeds_pre_authorized_amount")
                }
                Self::InvalidBillerInformation => f.write_str("invalid_biller_information"),
                Self::PinChangeUnblockRequestDeclined => {
                    f.write_str("pin_change_unblock_request_declined")
                }
                Self::UnsafePin => f.write_str("unsafe_pin"),
                Self::CardAuthenticationFailed => f.write_str("card_authentication_failed"),
                Self::StopPaymentOrder => f.write_str("stop_payment_order"),
                Self::RevocationOfAuthorization => f.write_str("revocation_of_authorization"),
                Self::RevocationOfAllAuthorizations => {
                    f.write_str("revocation_of_all_authorizations")
                }
                Self::ForwardToIssuerXa => f.write_str("forward_to_issuer_xa"),
                Self::ForwardToIssuerXd => f.write_str("forward_to_issuer_xd"),
                Self::UnableToGoOnline => f.write_str("unable_to_go_online"),
                Self::AdditionalCustomerAuthenticationRequired => {
                    f.write_str("additional_customer_authentication_required")
                }
                Self::MerchantIdNotFound => f.write_str("merchant_id_not_found"),
                Self::MerchantAccountClosed => f.write_str("merchant_account_closed"),
                Self::TerminalIdNotFound => f.write_str("terminal_id_not_found"),
                Self::TerminalClosed => f.write_str("terminal_closed"),
                Self::InvalidCategoryCode => f.write_str("invalid_category_code"),
                Self::InvalidCurrency => f.write_str("invalid_currency"),
                Self::MissingCvv2Cvc2 => f.write_str("missing_cvv2_cvc2"),
                Self::Cvv2NotAllowed => f.write_str("cvv2_not_allowed"),
                Self::MerchantNotRegisteredVbv => f.write_str("merchant_not_registered_vbv"),
                Self::MerchantNotRegisteredForAmex => {
                    f.write_str("merchant_not_registered_for_amex")
                }
                Self::TransactionNotPermittedAtTerminal => {
                    f.write_str("transaction_not_permitted_at_terminal")
                }
                Self::AgreementTerminalNotRelated => f.write_str("agreement_terminal_not_related"),
                Self::InvalidProcessorId => f.write_str("invalid_processor_id"),
                Self::InvalidMerchantData => f.write_str("invalid_merchant_data"),
                Self::SubMerchantAccountClosed => f.write_str("sub_merchant_account_closed"),
                Self::TerminalBusy => f.write_str("terminal_busy"),
                Self::TerminalUnreachable => f.write_str("terminal_unreachable"),
                Self::ServiceFailed => f.write_str("service_failed"),
                Self::InvalidOperation => f.write_str("invalid_operation"),
                Self::AuthorizationError => f.write_str("authorization_error"),
                Self::LoginFailedWithoutReason => f.write_str("login_failed_without_reason"),
                Self::InvalidRetailer => f.write_str("invalid_retailer"),
                Self::CardDoesNotExist => f.write_str("card_does_not_exist"),
                Self::CardIsBlocked => f.write_str("card_is_blocked"),
                Self::InvalidCardId => f.write_str("invalid_card_id"),
                Self::CardIsTransferred => f.write_str("card_is_transferred"),
                Self::CardIsNotActive => f.write_str("card_is_not_active"),
                Self::IncorrectPurchaseValue => f.write_str("incorrect_purchase_value"),
                Self::CardNotAvailable => f.write_str("card_not_available"),
                Self::WrongCurrency => f.write_str("wrong_currency"),
                Self::LoginFailedUnknownUser => f.write_str("login_failed_unknown_user"),
                Self::LoginFailedInvalidPassword => f.write_str("login_failed_invalid_password"),
                Self::InvalidEanCode => f.write_str("invalid_ean_code"),
            }
        }
    }

    impl ::std::str::FromStr for StatusReasonInnerCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "approved_or_completed_successfully" => Ok(Self::ApprovedOrCompletedSuccessfully),
                "refer_to_card_issuer" => Ok(Self::ReferToCardIssuer),
                "invalid_merchant" => Ok(Self::InvalidMerchant),
                "capture_card" => Ok(Self::CaptureCard),
                "do_not_honor" => Ok(Self::DoNotHonor),
                "error" => Ok(Self::Error),
                "partial_approval" => Ok(Self::PartialApproval),
                "invalid_transaction" => Ok(Self::InvalidTransaction),
                "invalid_amount" => Ok(Self::InvalidAmount),
                "invalid_issuer" => Ok(Self::InvalidIssuer),
                "lost_card" => Ok(Self::LostCard),
                "stolen_card" => Ok(Self::StolenCard),
                "insufficient_funds" => Ok(Self::InsufficientFunds),
                "expired_card" => Ok(Self::ExpiredCard),
                "invalid_pin" => Ok(Self::InvalidPin),
                "transaction_not_permitted_to_cardholder" => {
                    Ok(Self::TransactionNotPermittedToCardholder)
                }
                "transaction_not_allowed_at_terminal" => Ok(Self::TransactionNotAllowedAtTerminal),
                "exceeds_withdrawal_amount_limit" => Ok(Self::ExceedsWithdrawalAmountLimit),
                "restricted_card" => Ok(Self::RestrictedCard),
                "security_violation" => Ok(Self::SecurityViolation),
                "exceeds_withdrawal_count_limit" => Ok(Self::ExceedsWithdrawalCountLimit),
                "allowable_number_of_pin_tries_exceeded" => {
                    Ok(Self::AllowableNumberOfPinTriesExceeded)
                }
                "no_reason_to_decline" => Ok(Self::NoReasonToDecline),
                "cannot_verify_pin" => Ok(Self::CannotVerifyPin),
                "issuer_unavailable" => Ok(Self::IssuerUnavailable),
                "unable_to_route_transaction" => Ok(Self::UnableToRouteTransaction),
                "duplicate_transaction" => Ok(Self::DuplicateTransaction),
                "system_malfunction" => Ok(Self::SystemMalfunction),
                "honor_with_id" => Ok(Self::HonorWithId),
                "invalid_card_number" => Ok(Self::InvalidCardNumber),
                "format_error" => Ok(Self::FormatError),
                "contact_card_issuer" => Ok(Self::ContactCardIssuer),
                "pin_not_changed" => Ok(Self::PinNotChanged),
                "invalid_nonexistent_to_account_specified" => {
                    Ok(Self::InvalidNonexistentToAccountSpecified)
                }
                "invalid_nonexistent_from_account_specified" => {
                    Ok(Self::InvalidNonexistentFromAccountSpecified)
                }
                "invalid_nonexistent_account_specified" => {
                    Ok(Self::InvalidNonexistentAccountSpecified)
                }
                "lifecycle_related" => Ok(Self::LifecycleRelated),
                "domestic_debit_transaction_not_allowed" => {
                    Ok(Self::DomesticDebitTransactionNotAllowed)
                }
                "policy_related" => Ok(Self::PolicyRelated),
                "fraud_security_related" => Ok(Self::FraudSecurityRelated),
                "invalid_authorization_life_cycle" => Ok(Self::InvalidAuthorizationLifeCycle),
                "purchase_amount_only_no_cash_back_allowed" => {
                    Ok(Self::PurchaseAmountOnlyNoCashBackAllowed)
                }
                "cryptographic_failure" => Ok(Self::CryptographicFailure),
                "unacceptable_pin" => Ok(Self::UnacceptablePin),
                "refer_to_card_issuer_special_condition" => {
                    Ok(Self::ReferToCardIssuerSpecialCondition)
                }
                "pick_up_card_special_condition" => Ok(Self::PickUpCardSpecialCondition),
                "vip_approval" => Ok(Self::VipApproval),
                "invalid_account_number" => Ok(Self::InvalidAccountNumber),
                "re_enter_transaction" => Ok(Self::ReEnterTransaction),
                "no_action_taken" => Ok(Self::NoActionTaken),
                "unable_to_locate_record" => Ok(Self::UnableToLocateRecord),
                "file_temporarily_unavailable" => Ok(Self::FileTemporarilyUnavailable),
                "no_credit_account" => Ok(Self::NoCreditAccount),
                "closed_account" => Ok(Self::ClosedAccount),
                "no_checking_account" => Ok(Self::NoCheckingAccount),
                "no_savings_account" => Ok(Self::NoSavingsAccount),
                "suspected_fraud" => Ok(Self::SuspectedFraud),
                "transaction_does_not_fulfill_aml_requirement" => {
                    Ok(Self::TransactionDoesNotFulfillAmlRequirement)
                }
                "pin_data_required" => Ok(Self::PinDataRequired),
                "unable_to_locate_previous_message" => Ok(Self::UnableToLocatePreviousMessage),
                "previous_message_located_inconsistent_data" => {
                    Ok(Self::PreviousMessageLocatedInconsistentData)
                }
                "blocked_first_used" => Ok(Self::BlockedFirstUsed),
                "transaction_reversed" => Ok(Self::TransactionReversed),
                "credit_issuer_unavailable" => Ok(Self::CreditIssuerUnavailable),
                "pin_cryptographic_error_found" => Ok(Self::PinCryptographicErrorFound),
                "negative_online_cam_result" => Ok(Self::NegativeOnlineCamResult),
                "violation_of_law" => Ok(Self::ViolationOfLaw),
                "force_stip" => Ok(Self::ForceStip),
                "cash_service_not_available" => Ok(Self::CashServiceNotAvailable),
                "cashback_request_exceeds_issuer_limit" => {
                    Ok(Self::CashbackRequestExceedsIssuerLimit)
                }
                "decline_for_cvv2_failure" => Ok(Self::DeclineForCvv2Failure),
                "transaction_amount_exceeds_pre_authorized_amount" => {
                    Ok(Self::TransactionAmountExceedsPreAuthorizedAmount)
                }
                "invalid_biller_information" => Ok(Self::InvalidBillerInformation),
                "pin_change_unblock_request_declined" => Ok(Self::PinChangeUnblockRequestDeclined),
                "unsafe_pin" => Ok(Self::UnsafePin),
                "card_authentication_failed" => Ok(Self::CardAuthenticationFailed),
                "stop_payment_order" => Ok(Self::StopPaymentOrder),
                "revocation_of_authorization" => Ok(Self::RevocationOfAuthorization),
                "revocation_of_all_authorizations" => Ok(Self::RevocationOfAllAuthorizations),
                "forward_to_issuer_xa" => Ok(Self::ForwardToIssuerXa),
                "forward_to_issuer_xd" => Ok(Self::ForwardToIssuerXd),
                "unable_to_go_online" => Ok(Self::UnableToGoOnline),
                "additional_customer_authentication_required" => {
                    Ok(Self::AdditionalCustomerAuthenticationRequired)
                }
                "merchant_id_not_found" => Ok(Self::MerchantIdNotFound),
                "merchant_account_closed" => Ok(Self::MerchantAccountClosed),
                "terminal_id_not_found" => Ok(Self::TerminalIdNotFound),
                "terminal_closed" => Ok(Self::TerminalClosed),
                "invalid_category_code" => Ok(Self::InvalidCategoryCode),
                "invalid_currency" => Ok(Self::InvalidCurrency),
                "missing_cvv2_cvc2" => Ok(Self::MissingCvv2Cvc2),
                "cvv2_not_allowed" => Ok(Self::Cvv2NotAllowed),
                "merchant_not_registered_vbv" => Ok(Self::MerchantNotRegisteredVbv),
                "merchant_not_registered_for_amex" => Ok(Self::MerchantNotRegisteredForAmex),
                "transaction_not_permitted_at_terminal" => {
                    Ok(Self::TransactionNotPermittedAtTerminal)
                }
                "agreement_terminal_not_related" => Ok(Self::AgreementTerminalNotRelated),
                "invalid_processor_id" => Ok(Self::InvalidProcessorId),
                "invalid_merchant_data" => Ok(Self::InvalidMerchantData),
                "sub_merchant_account_closed" => Ok(Self::SubMerchantAccountClosed),
                "terminal_busy" => Ok(Self::TerminalBusy),
                "terminal_unreachable" => Ok(Self::TerminalUnreachable),
                "service_failed" => Ok(Self::ServiceFailed),
                "invalid_operation" => Ok(Self::InvalidOperation),
                "authorization_error" => Ok(Self::AuthorizationError),
                "login_failed_without_reason" => Ok(Self::LoginFailedWithoutReason),
                "invalid_retailer" => Ok(Self::InvalidRetailer),
                "card_does_not_exist" => Ok(Self::CardDoesNotExist),
                "card_is_blocked" => Ok(Self::CardIsBlocked),
                "invalid_card_id" => Ok(Self::InvalidCardId),
                "card_is_transferred" => Ok(Self::CardIsTransferred),
                "card_is_not_active" => Ok(Self::CardIsNotActive),
                "incorrect_purchase_value" => Ok(Self::IncorrectPurchaseValue),
                "card_not_available" => Ok(Self::CardNotAvailable),
                "wrong_currency" => Ok(Self::WrongCurrency),
                "login_failed_unknown_user" => Ok(Self::LoginFailedUnknownUser),
                "login_failed_invalid_password" => Ok(Self::LoginFailedInvalidPassword),
                "invalid_ean_code" => Ok(Self::InvalidEanCode),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for StatusReasonInnerCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for StatusReasonInnerCode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for StatusReasonInnerCode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SubGroup`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "subtotals": {
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/components-sub-totals"
    ///      }
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SubGroup {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<Amount>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub subtotals: ::std::option::Option<::std::vec::Vec<ComponentsSubTotals>>,
    }

    impl ::std::convert::From<&SubGroup> for SubGroup {
        fn from(value: &SubGroup) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SubGroup {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                subtotals: Default::default(),
            }
        }
    }

    ///`SubTotals`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "cardAudience": {
    ///      "description": "In case of payments trnsactions with card, the card
    /// audience will be available.",
    ///      "examples": [
    ///        "other"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "enum": [
    ///        "corporate",
    ///        "other"
    ///      ]
    ///    },
    ///    "cardIssuer": {
    ///      "description": "In case of payments transactions with card, the
    /// card issuer will be available",
    ///      "examples": [
    ///        "amex"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "enum": [
    ///        "amex",
    ///        "maestro",
    ///        "carte-bancaire",
    ///        "other"
    ///      ]
    ///    },
    ///    "cardRegion": {
    ///      "description": "In case of payments transactions with card, the
    /// card region will be available.",
    ///      "examples": [
    ///        "domestic"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "enum": [
    ///        "intra-eea",
    ///        "intra-eu",
    ///        "domestic",
    ///        "other"
    ///      ]
    ///    },
    ///    "count": {
    ///      "description": "Number of transactions of this type",
    ///      "examples": [
    ///        50
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "feeType": {
    ///      "description": "Present when the transaction represents a fee.",
    ///      "examples": [
    ///        "payment-fee"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "enum": [
    ///        "payment-fee",
    ///        "direct-debit-failure-fee",
    ///        "unauthorized-direct-debit-fee",
    ///        "bank-charged-direct-debit-failure-fee",
    ///        "partner-commission",
    ///        "application-fee",
    ///        "capture-fee",
    ///        "refund-fee",
    ///        "chargeback-fee",
    ///        "payment-notification-fee",
    ///        "transfer-notification-fee",
    ///        "payout-fee",
    ///        "fee-discount",
    ///        "fee-reimbursement",
    ///        "platform-volume-fee",
    ///        "platform-connected-organizations-fee",
    ///        "balance-charge-fee",
    ///        "3ds-authentication-attempt-fee",
    ///        "terminal-monthly-fee",
    ///        "acceptance-risk-fee",
    ///        "top-up-fee",
    ///        "payment-gateway-fee",
    ///        "mastercard-specialty-merchant-program-processing-fee",
    ///        "mastercard-specialty-merchant-program-registration-fee",
    ///        "visa-integrity-risk-program-processing-fee",
    ///        "visa-integrity-risk-program-registration-fee",
    ///        "minimum-invoice-amount-fee"
    ///      ]
    ///    },
    ///    "method": {
    ///      "$ref": "#/components/schemas/payment-method"
    ///    },
    ///    "prepaymentPartType": {
    ///      "description": "Prepayment part: fee itself, reimbursement,
    /// discount, VAT or rounding compensation.",
    ///      "examples": [
    ///        "fee"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "enum": [
    ///        "fee",
    ///        "fee-reimbursement",
    ///        "fee-discount",
    ///        "fee-vat",
    ///        "fee-rounding-compensation"
    ///      ]
    ///    },
    ///    "transactionType": {
    ///      "description": "Represents the transaction type",
    ///      "examples": [
    ///        "payment"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "enum": [
    ///        "payment",
    ///        "split-payment",
    ///        "failed-payment",
    ///        "failed-platform-split-payment",
    ///        "failed-split-payment-compensation",
    ///        "capture",
    ///        "split-transaction",
    ///        "refund",
    ///        "platform-payment-refund",
    ///        "returned-platform-payment-refund",
    ///        "refund-compensation",
    ///        "returned-refund-compensation",
    ///        "returned-refund",
    ///        "chargeback",
    ///        "chargeback-reversal",
    ///        "chargeback-compensation",
    ///        "reversed-chargeback-compensation",
    ///        "platform-payment-chargeback",
    ///        "reversed-platform-payment-chargeback",
    ///        "fee-prepayment",
    ///        "outgoing-transfer",
    ///        "incoming-transfer",
    ///        "canceled-transfer",
    ///        "returned-transfer",
    ///        "balance-reserve",
    ///        "balance-reserve-return",
    ///        "invoice-rounding-compensation",
    ///        "rolling-reserve-hold",
    ///        "rolling-reserve-release",
    ///        "balance-correction",
    ///        "repayment",
    ///        "loan",
    ///        "balance-topup",
    ///        "cash-collateral-issuance';",
    ///        "cash-collateral-release",
    ///        "pending-rolling-reserve",
    ///        "to-be-released-rolling-reserve",
    ///        "held-rolling-reserve",
    ///        "released-rolling-reserve"
    ///      ]
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SubTotals {
        ///In case of payments trnsactions with card, the card audience will be
        /// available.
        #[serde(
            rename = "cardAudience",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_audience: ::std::option::Option<SubTotalsCardAudience>,
        ///In case of payments transactions with card, the card issuer will be
        /// available
        #[serde(
            rename = "cardIssuer",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_issuer: ::std::option::Option<SubTotalsCardIssuer>,
        ///In case of payments transactions with card, the card region will be
        /// available.
        #[serde(
            rename = "cardRegion",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub card_region: ::std::option::Option<SubTotalsCardRegion>,
        ///Number of transactions of this type
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub count: ::std::option::Option<i64>,
        ///Present when the transaction represents a fee.
        #[serde(
            rename = "feeType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub fee_type: ::std::option::Option<SubTotalsFeeType>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub method: ::std::option::Option<PaymentMethod>,
        ///Prepayment part: fee itself, reimbursement, discount, VAT or
        /// rounding compensation.
        #[serde(
            rename = "prepaymentPartType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub prepayment_part_type: ::std::option::Option<SubTotalsPrepaymentPartType>,
        ///Represents the transaction type
        #[serde(
            rename = "transactionType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub transaction_type: ::std::option::Option<SubTotalsTransactionType>,
    }

    impl ::std::convert::From<&SubTotals> for SubTotals {
        fn from(value: &SubTotals) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SubTotals {
        fn default() -> Self {
            Self {
                card_audience: Default::default(),
                card_issuer: Default::default(),
                card_region: Default::default(),
                count: Default::default(),
                fee_type: Default::default(),
                method: Default::default(),
                prepayment_part_type: Default::default(),
                transaction_type: Default::default(),
            }
        }
    }

    ///In case of payments trnsactions with card, the card audience will be
    /// available.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "In case of payments trnsactions with card, the card
    /// audience will be available.",
    ///  "examples": [
    ///    "other"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "corporate",
    ///    "other"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SubTotalsCardAudience {
        #[serde(rename = "corporate")]
        Corporate,
        #[serde(rename = "other")]
        Other,
    }

    impl ::std::convert::From<&Self> for SubTotalsCardAudience {
        fn from(value: &SubTotalsCardAudience) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SubTotalsCardAudience {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Corporate => f.write_str("corporate"),
                Self::Other => f.write_str("other"),
            }
        }
    }

    impl ::std::str::FromStr for SubTotalsCardAudience {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "corporate" => Ok(Self::Corporate),
                "other" => Ok(Self::Other),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SubTotalsCardAudience {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SubTotalsCardAudience {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SubTotalsCardAudience {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///In case of payments transactions with card, the card issuer will be
    /// available
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "In case of payments transactions with card, the card
    /// issuer will be available",
    ///  "examples": [
    ///    "amex"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "amex",
    ///    "maestro",
    ///    "carte-bancaire",
    ///    "other"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SubTotalsCardIssuer {
        #[serde(rename = "amex")]
        Amex,
        #[serde(rename = "maestro")]
        Maestro,
        #[serde(rename = "carte-bancaire")]
        CarteBancaire,
        #[serde(rename = "other")]
        Other,
    }

    impl ::std::convert::From<&Self> for SubTotalsCardIssuer {
        fn from(value: &SubTotalsCardIssuer) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SubTotalsCardIssuer {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Amex => f.write_str("amex"),
                Self::Maestro => f.write_str("maestro"),
                Self::CarteBancaire => f.write_str("carte-bancaire"),
                Self::Other => f.write_str("other"),
            }
        }
    }

    impl ::std::str::FromStr for SubTotalsCardIssuer {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "amex" => Ok(Self::Amex),
                "maestro" => Ok(Self::Maestro),
                "carte-bancaire" => Ok(Self::CarteBancaire),
                "other" => Ok(Self::Other),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SubTotalsCardIssuer {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SubTotalsCardIssuer {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SubTotalsCardIssuer {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///In case of payments transactions with card, the card region will be
    /// available.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "In case of payments transactions with card, the card
    /// region will be available.",
    ///  "examples": [
    ///    "domestic"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "intra-eea",
    ///    "intra-eu",
    ///    "domestic",
    ///    "other"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SubTotalsCardRegion {
        #[serde(rename = "intra-eea")]
        IntraEea,
        #[serde(rename = "intra-eu")]
        IntraEu,
        #[serde(rename = "domestic")]
        Domestic,
        #[serde(rename = "other")]
        Other,
    }

    impl ::std::convert::From<&Self> for SubTotalsCardRegion {
        fn from(value: &SubTotalsCardRegion) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SubTotalsCardRegion {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::IntraEea => f.write_str("intra-eea"),
                Self::IntraEu => f.write_str("intra-eu"),
                Self::Domestic => f.write_str("domestic"),
                Self::Other => f.write_str("other"),
            }
        }
    }

    impl ::std::str::FromStr for SubTotalsCardRegion {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "intra-eea" => Ok(Self::IntraEea),
                "intra-eu" => Ok(Self::IntraEu),
                "domestic" => Ok(Self::Domestic),
                "other" => Ok(Self::Other),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SubTotalsCardRegion {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SubTotalsCardRegion {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SubTotalsCardRegion {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Present when the transaction represents a fee.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Present when the transaction represents a fee.",
    ///  "examples": [
    ///    "payment-fee"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "payment-fee",
    ///    "direct-debit-failure-fee",
    ///    "unauthorized-direct-debit-fee",
    ///    "bank-charged-direct-debit-failure-fee",
    ///    "partner-commission",
    ///    "application-fee",
    ///    "capture-fee",
    ///    "refund-fee",
    ///    "chargeback-fee",
    ///    "payment-notification-fee",
    ///    "transfer-notification-fee",
    ///    "payout-fee",
    ///    "fee-discount",
    ///    "fee-reimbursement",
    ///    "platform-volume-fee",
    ///    "platform-connected-organizations-fee",
    ///    "balance-charge-fee",
    ///    "3ds-authentication-attempt-fee",
    ///    "terminal-monthly-fee",
    ///    "acceptance-risk-fee",
    ///    "top-up-fee",
    ///    "payment-gateway-fee",
    ///    "mastercard-specialty-merchant-program-processing-fee",
    ///    "mastercard-specialty-merchant-program-registration-fee",
    ///    "visa-integrity-risk-program-processing-fee",
    ///    "visa-integrity-risk-program-registration-fee",
    ///    "minimum-invoice-amount-fee"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SubTotalsFeeType {
        #[serde(rename = "payment-fee")]
        PaymentFee,
        #[serde(rename = "direct-debit-failure-fee")]
        DirectDebitFailureFee,
        #[serde(rename = "unauthorized-direct-debit-fee")]
        UnauthorizedDirectDebitFee,
        #[serde(rename = "bank-charged-direct-debit-failure-fee")]
        BankChargedDirectDebitFailureFee,
        #[serde(rename = "partner-commission")]
        PartnerCommission,
        #[serde(rename = "application-fee")]
        ApplicationFee,
        #[serde(rename = "capture-fee")]
        CaptureFee,
        #[serde(rename = "refund-fee")]
        RefundFee,
        #[serde(rename = "chargeback-fee")]
        ChargebackFee,
        #[serde(rename = "payment-notification-fee")]
        PaymentNotificationFee,
        #[serde(rename = "transfer-notification-fee")]
        TransferNotificationFee,
        #[serde(rename = "payout-fee")]
        PayoutFee,
        #[serde(rename = "fee-discount")]
        FeeDiscount,
        #[serde(rename = "fee-reimbursement")]
        FeeReimbursement,
        #[serde(rename = "platform-volume-fee")]
        PlatformVolumeFee,
        #[serde(rename = "platform-connected-organizations-fee")]
        PlatformConnectedOrganizationsFee,
        #[serde(rename = "balance-charge-fee")]
        BalanceChargeFee,
        #[serde(rename = "3ds-authentication-attempt-fee")]
        X3dsAuthenticationAttemptFee,
        #[serde(rename = "terminal-monthly-fee")]
        TerminalMonthlyFee,
        #[serde(rename = "acceptance-risk-fee")]
        AcceptanceRiskFee,
        #[serde(rename = "top-up-fee")]
        TopUpFee,
        #[serde(rename = "payment-gateway-fee")]
        PaymentGatewayFee,
        #[serde(rename = "mastercard-specialty-merchant-program-processing-fee")]
        MastercardSpecialtyMerchantProgramProcessingFee,
        #[serde(rename = "mastercard-specialty-merchant-program-registration-fee")]
        MastercardSpecialtyMerchantProgramRegistrationFee,
        #[serde(rename = "visa-integrity-risk-program-processing-fee")]
        VisaIntegrityRiskProgramProcessingFee,
        #[serde(rename = "visa-integrity-risk-program-registration-fee")]
        VisaIntegrityRiskProgramRegistrationFee,
        #[serde(rename = "minimum-invoice-amount-fee")]
        MinimumInvoiceAmountFee,
    }

    impl ::std::convert::From<&Self> for SubTotalsFeeType {
        fn from(value: &SubTotalsFeeType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SubTotalsFeeType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PaymentFee => f.write_str("payment-fee"),
                Self::DirectDebitFailureFee => f.write_str("direct-debit-failure-fee"),
                Self::UnauthorizedDirectDebitFee => f.write_str("unauthorized-direct-debit-fee"),
                Self::BankChargedDirectDebitFailureFee => {
                    f.write_str("bank-charged-direct-debit-failure-fee")
                }
                Self::PartnerCommission => f.write_str("partner-commission"),
                Self::ApplicationFee => f.write_str("application-fee"),
                Self::CaptureFee => f.write_str("capture-fee"),
                Self::RefundFee => f.write_str("refund-fee"),
                Self::ChargebackFee => f.write_str("chargeback-fee"),
                Self::PaymentNotificationFee => f.write_str("payment-notification-fee"),
                Self::TransferNotificationFee => f.write_str("transfer-notification-fee"),
                Self::PayoutFee => f.write_str("payout-fee"),
                Self::FeeDiscount => f.write_str("fee-discount"),
                Self::FeeReimbursement => f.write_str("fee-reimbursement"),
                Self::PlatformVolumeFee => f.write_str("platform-volume-fee"),
                Self::PlatformConnectedOrganizationsFee => {
                    f.write_str("platform-connected-organizations-fee")
                }
                Self::BalanceChargeFee => f.write_str("balance-charge-fee"),
                Self::X3dsAuthenticationAttemptFee => f.write_str("3ds-authentication-attempt-fee"),
                Self::TerminalMonthlyFee => f.write_str("terminal-monthly-fee"),
                Self::AcceptanceRiskFee => f.write_str("acceptance-risk-fee"),
                Self::TopUpFee => f.write_str("top-up-fee"),
                Self::PaymentGatewayFee => f.write_str("payment-gateway-fee"),
                Self::MastercardSpecialtyMerchantProgramProcessingFee => {
                    f.write_str("mastercard-specialty-merchant-program-processing-fee")
                }
                Self::MastercardSpecialtyMerchantProgramRegistrationFee => {
                    f.write_str("mastercard-specialty-merchant-program-registration-fee")
                }
                Self::VisaIntegrityRiskProgramProcessingFee => {
                    f.write_str("visa-integrity-risk-program-processing-fee")
                }
                Self::VisaIntegrityRiskProgramRegistrationFee => {
                    f.write_str("visa-integrity-risk-program-registration-fee")
                }
                Self::MinimumInvoiceAmountFee => f.write_str("minimum-invoice-amount-fee"),
            }
        }
    }

    impl ::std::str::FromStr for SubTotalsFeeType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "payment-fee" => Ok(Self::PaymentFee),
                "direct-debit-failure-fee" => Ok(Self::DirectDebitFailureFee),
                "unauthorized-direct-debit-fee" => Ok(Self::UnauthorizedDirectDebitFee),
                "bank-charged-direct-debit-failure-fee" => {
                    Ok(Self::BankChargedDirectDebitFailureFee)
                }
                "partner-commission" => Ok(Self::PartnerCommission),
                "application-fee" => Ok(Self::ApplicationFee),
                "capture-fee" => Ok(Self::CaptureFee),
                "refund-fee" => Ok(Self::RefundFee),
                "chargeback-fee" => Ok(Self::ChargebackFee),
                "payment-notification-fee" => Ok(Self::PaymentNotificationFee),
                "transfer-notification-fee" => Ok(Self::TransferNotificationFee),
                "payout-fee" => Ok(Self::PayoutFee),
                "fee-discount" => Ok(Self::FeeDiscount),
                "fee-reimbursement" => Ok(Self::FeeReimbursement),
                "platform-volume-fee" => Ok(Self::PlatformVolumeFee),
                "platform-connected-organizations-fee" => {
                    Ok(Self::PlatformConnectedOrganizationsFee)
                }
                "balance-charge-fee" => Ok(Self::BalanceChargeFee),
                "3ds-authentication-attempt-fee" => Ok(Self::X3dsAuthenticationAttemptFee),
                "terminal-monthly-fee" => Ok(Self::TerminalMonthlyFee),
                "acceptance-risk-fee" => Ok(Self::AcceptanceRiskFee),
                "top-up-fee" => Ok(Self::TopUpFee),
                "payment-gateway-fee" => Ok(Self::PaymentGatewayFee),
                "mastercard-specialty-merchant-program-processing-fee" => {
                    Ok(Self::MastercardSpecialtyMerchantProgramProcessingFee)
                }
                "mastercard-specialty-merchant-program-registration-fee" => {
                    Ok(Self::MastercardSpecialtyMerchantProgramRegistrationFee)
                }
                "visa-integrity-risk-program-processing-fee" => {
                    Ok(Self::VisaIntegrityRiskProgramProcessingFee)
                }
                "visa-integrity-risk-program-registration-fee" => {
                    Ok(Self::VisaIntegrityRiskProgramRegistrationFee)
                }
                "minimum-invoice-amount-fee" => Ok(Self::MinimumInvoiceAmountFee),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SubTotalsFeeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SubTotalsFeeType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SubTotalsFeeType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Prepayment part: fee itself, reimbursement, discount, VAT or rounding
    /// compensation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Prepayment part: fee itself, reimbursement, discount,
    /// VAT or rounding compensation.",
    ///  "examples": [
    ///    "fee"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "fee",
    ///    "fee-reimbursement",
    ///    "fee-discount",
    ///    "fee-vat",
    ///    "fee-rounding-compensation"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SubTotalsPrepaymentPartType {
        #[serde(rename = "fee")]
        Fee,
        #[serde(rename = "fee-reimbursement")]
        FeeReimbursement,
        #[serde(rename = "fee-discount")]
        FeeDiscount,
        #[serde(rename = "fee-vat")]
        FeeVat,
        #[serde(rename = "fee-rounding-compensation")]
        FeeRoundingCompensation,
    }

    impl ::std::convert::From<&Self> for SubTotalsPrepaymentPartType {
        fn from(value: &SubTotalsPrepaymentPartType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SubTotalsPrepaymentPartType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Fee => f.write_str("fee"),
                Self::FeeReimbursement => f.write_str("fee-reimbursement"),
                Self::FeeDiscount => f.write_str("fee-discount"),
                Self::FeeVat => f.write_str("fee-vat"),
                Self::FeeRoundingCompensation => f.write_str("fee-rounding-compensation"),
            }
        }
    }

    impl ::std::str::FromStr for SubTotalsPrepaymentPartType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "fee" => Ok(Self::Fee),
                "fee-reimbursement" => Ok(Self::FeeReimbursement),
                "fee-discount" => Ok(Self::FeeDiscount),
                "fee-vat" => Ok(Self::FeeVat),
                "fee-rounding-compensation" => Ok(Self::FeeRoundingCompensation),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SubTotalsPrepaymentPartType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SubTotalsPrepaymentPartType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SubTotalsPrepaymentPartType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents the transaction type
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the transaction type",
    ///  "examples": [
    ///    "payment"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "payment",
    ///    "split-payment",
    ///    "failed-payment",
    ///    "failed-platform-split-payment",
    ///    "failed-split-payment-compensation",
    ///    "capture",
    ///    "split-transaction",
    ///    "refund",
    ///    "platform-payment-refund",
    ///    "returned-platform-payment-refund",
    ///    "refund-compensation",
    ///    "returned-refund-compensation",
    ///    "returned-refund",
    ///    "chargeback",
    ///    "chargeback-reversal",
    ///    "chargeback-compensation",
    ///    "reversed-chargeback-compensation",
    ///    "platform-payment-chargeback",
    ///    "reversed-platform-payment-chargeback",
    ///    "fee-prepayment",
    ///    "outgoing-transfer",
    ///    "incoming-transfer",
    ///    "canceled-transfer",
    ///    "returned-transfer",
    ///    "balance-reserve",
    ///    "balance-reserve-return",
    ///    "invoice-rounding-compensation",
    ///    "rolling-reserve-hold",
    ///    "rolling-reserve-release",
    ///    "balance-correction",
    ///    "repayment",
    ///    "loan",
    ///    "balance-topup",
    ///    "cash-collateral-issuance';",
    ///    "cash-collateral-release",
    ///    "pending-rolling-reserve",
    ///    "to-be-released-rolling-reserve",
    ///    "held-rolling-reserve",
    ///    "released-rolling-reserve"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SubTotalsTransactionType {
        #[serde(rename = "payment")]
        Payment,
        #[serde(rename = "split-payment")]
        SplitPayment,
        #[serde(rename = "failed-payment")]
        FailedPayment,
        #[serde(rename = "failed-platform-split-payment")]
        FailedPlatformSplitPayment,
        #[serde(rename = "failed-split-payment-compensation")]
        FailedSplitPaymentCompensation,
        #[serde(rename = "capture")]
        Capture,
        #[serde(rename = "split-transaction")]
        SplitTransaction,
        #[serde(rename = "refund")]
        Refund,
        #[serde(rename = "platform-payment-refund")]
        PlatformPaymentRefund,
        #[serde(rename = "returned-platform-payment-refund")]
        ReturnedPlatformPaymentRefund,
        #[serde(rename = "refund-compensation")]
        RefundCompensation,
        #[serde(rename = "returned-refund-compensation")]
        ReturnedRefundCompensation,
        #[serde(rename = "returned-refund")]
        ReturnedRefund,
        #[serde(rename = "chargeback")]
        Chargeback,
        #[serde(rename = "chargeback-reversal")]
        ChargebackReversal,
        #[serde(rename = "chargeback-compensation")]
        ChargebackCompensation,
        #[serde(rename = "reversed-chargeback-compensation")]
        ReversedChargebackCompensation,
        #[serde(rename = "platform-payment-chargeback")]
        PlatformPaymentChargeback,
        #[serde(rename = "reversed-platform-payment-chargeback")]
        ReversedPlatformPaymentChargeback,
        #[serde(rename = "fee-prepayment")]
        FeePrepayment,
        #[serde(rename = "outgoing-transfer")]
        OutgoingTransfer,
        #[serde(rename = "incoming-transfer")]
        IncomingTransfer,
        #[serde(rename = "canceled-transfer")]
        CanceledTransfer,
        #[serde(rename = "returned-transfer")]
        ReturnedTransfer,
        #[serde(rename = "balance-reserve")]
        BalanceReserve,
        #[serde(rename = "balance-reserve-return")]
        BalanceReserveReturn,
        #[serde(rename = "invoice-rounding-compensation")]
        InvoiceRoundingCompensation,
        #[serde(rename = "rolling-reserve-hold")]
        RollingReserveHold,
        #[serde(rename = "rolling-reserve-release")]
        RollingReserveRelease,
        #[serde(rename = "balance-correction")]
        BalanceCorrection,
        #[serde(rename = "repayment")]
        Repayment,
        #[serde(rename = "loan")]
        Loan,
        #[serde(rename = "balance-topup")]
        BalanceTopup,
        #[serde(rename = "cash-collateral-issuance';")]
        CashCollateralIssuance,
        #[serde(rename = "cash-collateral-release")]
        CashCollateralRelease,
        #[serde(rename = "pending-rolling-reserve")]
        PendingRollingReserve,
        #[serde(rename = "to-be-released-rolling-reserve")]
        ToBeReleasedRollingReserve,
        #[serde(rename = "held-rolling-reserve")]
        HeldRollingReserve,
        #[serde(rename = "released-rolling-reserve")]
        ReleasedRollingReserve,
    }

    impl ::std::convert::From<&Self> for SubTotalsTransactionType {
        fn from(value: &SubTotalsTransactionType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SubTotalsTransactionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Payment => f.write_str("payment"),
                Self::SplitPayment => f.write_str("split-payment"),
                Self::FailedPayment => f.write_str("failed-payment"),
                Self::FailedPlatformSplitPayment => f.write_str("failed-platform-split-payment"),
                Self::FailedSplitPaymentCompensation => {
                    f.write_str("failed-split-payment-compensation")
                }
                Self::Capture => f.write_str("capture"),
                Self::SplitTransaction => f.write_str("split-transaction"),
                Self::Refund => f.write_str("refund"),
                Self::PlatformPaymentRefund => f.write_str("platform-payment-refund"),
                Self::ReturnedPlatformPaymentRefund => {
                    f.write_str("returned-platform-payment-refund")
                }
                Self::RefundCompensation => f.write_str("refund-compensation"),
                Self::ReturnedRefundCompensation => f.write_str("returned-refund-compensation"),
                Self::ReturnedRefund => f.write_str("returned-refund"),
                Self::Chargeback => f.write_str("chargeback"),
                Self::ChargebackReversal => f.write_str("chargeback-reversal"),
                Self::ChargebackCompensation => f.write_str("chargeback-compensation"),
                Self::ReversedChargebackCompensation => {
                    f.write_str("reversed-chargeback-compensation")
                }
                Self::PlatformPaymentChargeback => f.write_str("platform-payment-chargeback"),
                Self::ReversedPlatformPaymentChargeback => {
                    f.write_str("reversed-platform-payment-chargeback")
                }
                Self::FeePrepayment => f.write_str("fee-prepayment"),
                Self::OutgoingTransfer => f.write_str("outgoing-transfer"),
                Self::IncomingTransfer => f.write_str("incoming-transfer"),
                Self::CanceledTransfer => f.write_str("canceled-transfer"),
                Self::ReturnedTransfer => f.write_str("returned-transfer"),
                Self::BalanceReserve => f.write_str("balance-reserve"),
                Self::BalanceReserveReturn => f.write_str("balance-reserve-return"),
                Self::InvoiceRoundingCompensation => f.write_str("invoice-rounding-compensation"),
                Self::RollingReserveHold => f.write_str("rolling-reserve-hold"),
                Self::RollingReserveRelease => f.write_str("rolling-reserve-release"),
                Self::BalanceCorrection => f.write_str("balance-correction"),
                Self::Repayment => f.write_str("repayment"),
                Self::Loan => f.write_str("loan"),
                Self::BalanceTopup => f.write_str("balance-topup"),
                Self::CashCollateralIssuance => f.write_str("cash-collateral-issuance';"),
                Self::CashCollateralRelease => f.write_str("cash-collateral-release"),
                Self::PendingRollingReserve => f.write_str("pending-rolling-reserve"),
                Self::ToBeReleasedRollingReserve => f.write_str("to-be-released-rolling-reserve"),
                Self::HeldRollingReserve => f.write_str("held-rolling-reserve"),
                Self::ReleasedRollingReserve => f.write_str("released-rolling-reserve"),
            }
        }
    }

    impl ::std::str::FromStr for SubTotalsTransactionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "payment" => Ok(Self::Payment),
                "split-payment" => Ok(Self::SplitPayment),
                "failed-payment" => Ok(Self::FailedPayment),
                "failed-platform-split-payment" => Ok(Self::FailedPlatformSplitPayment),
                "failed-split-payment-compensation" => Ok(Self::FailedSplitPaymentCompensation),
                "capture" => Ok(Self::Capture),
                "split-transaction" => Ok(Self::SplitTransaction),
                "refund" => Ok(Self::Refund),
                "platform-payment-refund" => Ok(Self::PlatformPaymentRefund),
                "returned-platform-payment-refund" => Ok(Self::ReturnedPlatformPaymentRefund),
                "refund-compensation" => Ok(Self::RefundCompensation),
                "returned-refund-compensation" => Ok(Self::ReturnedRefundCompensation),
                "returned-refund" => Ok(Self::ReturnedRefund),
                "chargeback" => Ok(Self::Chargeback),
                "chargeback-reversal" => Ok(Self::ChargebackReversal),
                "chargeback-compensation" => Ok(Self::ChargebackCompensation),
                "reversed-chargeback-compensation" => Ok(Self::ReversedChargebackCompensation),
                "platform-payment-chargeback" => Ok(Self::PlatformPaymentChargeback),
                "reversed-platform-payment-chargeback" => {
                    Ok(Self::ReversedPlatformPaymentChargeback)
                }
                "fee-prepayment" => Ok(Self::FeePrepayment),
                "outgoing-transfer" => Ok(Self::OutgoingTransfer),
                "incoming-transfer" => Ok(Self::IncomingTransfer),
                "canceled-transfer" => Ok(Self::CanceledTransfer),
                "returned-transfer" => Ok(Self::ReturnedTransfer),
                "balance-reserve" => Ok(Self::BalanceReserve),
                "balance-reserve-return" => Ok(Self::BalanceReserveReturn),
                "invoice-rounding-compensation" => Ok(Self::InvoiceRoundingCompensation),
                "rolling-reserve-hold" => Ok(Self::RollingReserveHold),
                "rolling-reserve-release" => Ok(Self::RollingReserveRelease),
                "balance-correction" => Ok(Self::BalanceCorrection),
                "repayment" => Ok(Self::Repayment),
                "loan" => Ok(Self::Loan),
                "balance-topup" => Ok(Self::BalanceTopup),
                "cash-collateral-issuance';" => Ok(Self::CashCollateralIssuance),
                "cash-collateral-release" => Ok(Self::CashCollateralRelease),
                "pending-rolling-reserve" => Ok(Self::PendingRollingReserve),
                "to-be-released-rolling-reserve" => Ok(Self::ToBeReleasedRollingReserve),
                "held-rolling-reserve" => Ok(Self::HeldRollingReserve),
                "released-rolling-reserve" => Ok(Self::ReleasedRollingReserve),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SubTotalsTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SubTotalsTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SubTotalsTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SubmitOnboardingDataBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "organization": {
    ///      "type": "object",
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/address"
    ///        },
    ///        "name": {
    ///          "description": "The name of the organization.",
    ///          "examples": [
    ///            "Mollie B.V."
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "registrationNumber": {
    ///          "description": "The registration number of the organization at
    /// their local chamber of commerce.",
    ///          "examples": [
    ///            "30204462"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "vatNumber": {
    ///          "description": "The VAT number of the organization, if based in
    /// the European Union or in The United Kingdom. VAT\nnumbers are verified
    /// against the international registry *VIES*.\n\nThe field can be omitted
    /// for merchants residing in other countries.",
    ///          "examples": [
    ///            "NL815839091B01"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "vatRegulation": {
    ///          "description": "Mollie applies Dutch VAT for merchants based in
    /// The Netherlands, British VAT for merchants based in\nThe United Kingdom,
    /// and shifted VAT for merchants in the European Union.\n\nThe field can be
    /// omitted for merchants residing in other countries.",
    ///          "examples": [
    ///            "dutch"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "enum": [
    ///            "dutch",
    ///            "british",
    ///            "shifted"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    "profile": {
    ///      "type": "object",
    ///      "properties": {
    ///        "businessCategory": {
    ///          "description": "The industry associated with the profile's
    /// trade name or brand. Please refer to the\n[business category
    /// list](common-data-types) for all possible options.",
    ///          "examples": [
    ///            "MONEY_SERVICES"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "description": {
    ///          "description": "The products or services offered by the
    /// profile's website or application.",
    ///          "examples": [
    ///            "Payment service provider"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "email": {
    ///          "description": "The email address associated with the profile's
    /// trade name or brand.",
    ///          "examples": [
    ///            "info@mollie.com"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "name": {
    ///          "description": "The profile's name, this will usually reflect the trade name or brand name of the profile's website\nor application.",
    ///          "examples": [
    ///            "Mollie"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "phone": {
    ///          "description": "The phone number associated with the profile's
    /// trade name or brand.",
    ///          "examples": [
    ///            "+31208202070"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "url": {
    ///          "description": "The URL to the profile's website or
    /// application. Only `https` or `http` URLs are allowed. No `@`\nsigns are
    /// allowed.",
    ///          "examples": [
    ///            "https://www.mollie.com"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SubmitOnboardingDataBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub organization: ::std::option::Option<SubmitOnboardingDataBodyOrganization>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub profile: ::std::option::Option<SubmitOnboardingDataBodyProfile>,
    }

    impl ::std::convert::From<&SubmitOnboardingDataBody> for SubmitOnboardingDataBody {
        fn from(value: &SubmitOnboardingDataBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SubmitOnboardingDataBody {
        fn default() -> Self {
            Self {
                organization: Default::default(),
                profile: Default::default(),
            }
        }
    }

    ///`SubmitOnboardingDataBodyOrganization`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "address": {
    ///      "$ref": "#/components/schemas/address"
    ///    },
    ///    "name": {
    ///      "description": "The name of the organization.",
    ///      "examples": [
    ///        "Mollie B.V."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "registrationNumber": {
    ///      "description": "The registration number of the organization at
    /// their local chamber of commerce.",
    ///      "examples": [
    ///        "30204462"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "vatNumber": {
    ///      "description": "The VAT number of the organization, if based in the
    /// European Union or in The United Kingdom. VAT\nnumbers are verified
    /// against the international registry *VIES*.\n\nThe field can be omitted
    /// for merchants residing in other countries.",
    ///      "examples": [
    ///        "NL815839091B01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "vatRegulation": {
    ///      "description": "Mollie applies Dutch VAT for merchants based in The
    /// Netherlands, British VAT for merchants based in\nThe United Kingdom, and
    /// shifted VAT for merchants in the European Union.\n\nThe field can be
    /// omitted for merchants residing in other countries.",
    ///      "examples": [
    ///        "dutch"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "enum": [
    ///        "dutch",
    ///        "british",
    ///        "shifted"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SubmitOnboardingDataBodyOrganization {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<Address>,
        ///The name of the organization.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///The registration number of the organization at their local chamber
        /// of commerce.
        #[serde(
            rename = "registrationNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub registration_number: ::std::option::Option<::std::string::String>,
        ///The VAT number of the organization, if based in the European Union
        /// or in The United Kingdom. VAT numbers are verified against
        /// the international registry *VIES*.
        ///
        ///The field can be omitted for merchants residing in other countries.
        #[serde(
            rename = "vatNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_number: ::std::option::Option<::std::string::String>,
        ///Mollie applies Dutch VAT for merchants based in The Netherlands,
        /// British VAT for merchants based in The United Kingdom, and
        /// shifted VAT for merchants in the European Union.
        ///
        ///The field can be omitted for merchants residing in other countries.
        #[serde(
            rename = "vatRegulation",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vat_regulation:
            ::std::option::Option<SubmitOnboardingDataBodyOrganizationVatRegulation>,
    }

    impl ::std::convert::From<&SubmitOnboardingDataBodyOrganization>
        for SubmitOnboardingDataBodyOrganization
    {
        fn from(value: &SubmitOnboardingDataBodyOrganization) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SubmitOnboardingDataBodyOrganization {
        fn default() -> Self {
            Self {
                address: Default::default(),
                name: Default::default(),
                registration_number: Default::default(),
                vat_number: Default::default(),
                vat_regulation: Default::default(),
            }
        }
    }

    ///Mollie applies Dutch VAT for merchants based in The Netherlands, British
    /// VAT for merchants based in The United Kingdom, and shifted VAT for
    /// merchants in the European Union.
    ///
    ///The field can be omitted for merchants residing in other countries.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Mollie applies Dutch VAT for merchants based in The
    /// Netherlands, British VAT for merchants based in\nThe United Kingdom, and
    /// shifted VAT for merchants in the European Union.\n\nThe field can be
    /// omitted for merchants residing in other countries.",
    ///  "examples": [
    ///    "dutch"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "dutch",
    ///    "british",
    ///    "shifted"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SubmitOnboardingDataBodyOrganizationVatRegulation {
        #[serde(rename = "dutch")]
        Dutch,
        #[serde(rename = "british")]
        British,
        #[serde(rename = "shifted")]
        Shifted,
    }

    impl ::std::convert::From<&Self> for SubmitOnboardingDataBodyOrganizationVatRegulation {
        fn from(value: &SubmitOnboardingDataBodyOrganizationVatRegulation) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SubmitOnboardingDataBodyOrganizationVatRegulation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Dutch => f.write_str("dutch"),
                Self::British => f.write_str("british"),
                Self::Shifted => f.write_str("shifted"),
            }
        }
    }

    impl ::std::str::FromStr for SubmitOnboardingDataBodyOrganizationVatRegulation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "dutch" => Ok(Self::Dutch),
                "british" => Ok(Self::British),
                "shifted" => Ok(Self::Shifted),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SubmitOnboardingDataBodyOrganizationVatRegulation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for SubmitOnboardingDataBodyOrganizationVatRegulation
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for SubmitOnboardingDataBodyOrganizationVatRegulation
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SubmitOnboardingDataBodyProfile`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "businessCategory": {
    ///      "description": "The industry associated with the profile's trade
    /// name or brand. Please refer to the\n[business category
    /// list](common-data-types) for all possible options.",
    ///      "examples": [
    ///        "MONEY_SERVICES"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "description": "The products or services offered by the profile's
    /// website or application.",
    ///      "examples": [
    ///        "Payment service provider"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "email": {
    ///      "description": "The email address associated with the profile's
    /// trade name or brand.",
    ///      "examples": [
    ///        "info@mollie.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "The profile's name, this will usually reflect the
    /// trade name or brand name of the profile's website\nor application.",
    ///      "examples": [
    ///        "Mollie"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "phone": {
    ///      "description": "The phone number associated with the profile's
    /// trade name or brand.",
    ///      "examples": [
    ///        "+31208202070"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "url": {
    ///      "description": "The URL to the profile's website or application. Only `https` or `http` URLs are allowed. No `@`\nsigns are allowed.",
    ///      "examples": [
    ///        "https://www.mollie.com"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SubmitOnboardingDataBodyProfile {
        ///The industry associated with the profile's trade name or brand.
        /// Please refer to the [business category
        /// list](common-data-types) for all possible options.
        #[serde(
            rename = "businessCategory",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub business_category: ::std::option::Option<::std::string::String>,
        ///The products or services offered by the profile's website or
        /// application.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        ///The email address associated with the profile's trade name or brand.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        ///The profile's name, this will usually reflect the trade name or
        /// brand name of the profile's website or application.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///The phone number associated with the profile's trade name or brand.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub phone: ::std::option::Option<::std::string::String>,
        ///The URL to the profile's website or application. Only `https` or
        /// `http` URLs are allowed. No `@` signs are allowed.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub url: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SubmitOnboardingDataBodyProfile> for SubmitOnboardingDataBodyProfile {
        fn from(value: &SubmitOnboardingDataBodyProfile) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SubmitOnboardingDataBodyProfile {
        fn default() -> Self {
            Self {
                business_category: Default::default(),
                description: Default::default(),
                email: Default::default(),
                name: Default::default(),
                phone: Default::default(),
                url: Default::default(),
            }
        }
    }

    ///The payment method used for this subscription. If omitted, any of the
    /// customer's valid mandates may be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The payment method used for this subscription. If
    /// omitted, any of the customer's valid mandates may be used.",
    ///  "examples": [
    ///    "paypal"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "creditcard",
    ///    "directdebit",
    ///    "paypal"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SubscriptionMethod(pub ::std::option::Option<SubscriptionMethodInner>);
    impl ::std::ops::Deref for SubscriptionMethod {
        type Target = ::std::option::Option<SubscriptionMethodInner>;
        fn deref(&self) -> &::std::option::Option<SubscriptionMethodInner> {
            &self.0
        }
    }

    impl ::std::convert::From<SubscriptionMethod> for ::std::option::Option<SubscriptionMethodInner> {
        fn from(value: SubscriptionMethod) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SubscriptionMethod> for SubscriptionMethod {
        fn from(value: &SubscriptionMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<SubscriptionMethodInner>> for SubscriptionMethod {
        fn from(value: ::std::option::Option<SubscriptionMethodInner>) -> Self {
            Self(value)
        }
    }

    ///The payment method used for this subscription. If omitted, any of the
    /// customer's valid mandates may be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The payment method used for this subscription. If
    /// omitted, any of the customer's valid mandates may be used.",
    ///  "examples": [
    ///    "paypal"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "creditcard",
    ///    "directdebit",
    ///    "paypal"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SubscriptionMethodInner {
        #[serde(rename = "creditcard")]
        Creditcard,
        #[serde(rename = "directdebit")]
        Directdebit,
        #[serde(rename = "paypal")]
        Paypal,
    }

    impl ::std::convert::From<&Self> for SubscriptionMethodInner {
        fn from(value: &SubscriptionMethodInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SubscriptionMethodInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Creditcard => f.write_str("creditcard"),
                Self::Directdebit => f.write_str("directdebit"),
                Self::Paypal => f.write_str("paypal"),
            }
        }
    }

    impl ::std::str::FromStr for SubscriptionMethodInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "creditcard" => Ok(Self::Creditcard),
                "directdebit" => Ok(Self::Directdebit),
                "paypal" => Ok(Self::Paypal),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SubscriptionMethodInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SubscriptionMethodInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SubscriptionMethodInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The payment method used for this subscription. If omitted, any of the
    /// customer's valid mandates may be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The payment method used for this subscription. If
    /// omitted, any of the customer's valid mandates may be used.",
    ///  "examples": [
    ///    "paypal"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "creditcard",
    ///    "directdebit",
    ///    "paypal"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SubscriptionMethodResponse(
        pub ::std::option::Option<SubscriptionMethodResponseInner>,
    );
    impl ::std::ops::Deref for SubscriptionMethodResponse {
        type Target = ::std::option::Option<SubscriptionMethodResponseInner>;
        fn deref(&self) -> &::std::option::Option<SubscriptionMethodResponseInner> {
            &self.0
        }
    }

    impl ::std::convert::From<SubscriptionMethodResponse>
        for ::std::option::Option<SubscriptionMethodResponseInner>
    {
        fn from(value: SubscriptionMethodResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SubscriptionMethodResponse> for SubscriptionMethodResponse {
        fn from(value: &SubscriptionMethodResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<SubscriptionMethodResponseInner>>
        for SubscriptionMethodResponse
    {
        fn from(value: ::std::option::Option<SubscriptionMethodResponseInner>) -> Self {
            Self(value)
        }
    }

    ///The payment method used for this subscription. If omitted, any of the
    /// customer's valid mandates may be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The payment method used for this subscription. If
    /// omitted, any of the customer's valid mandates may be used.",
    ///  "examples": [
    ///    "paypal"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "creditcard",
    ///    "directdebit",
    ///    "paypal"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SubscriptionMethodResponseInner {
        #[serde(rename = "creditcard")]
        Creditcard,
        #[serde(rename = "directdebit")]
        Directdebit,
        #[serde(rename = "paypal")]
        Paypal,
    }

    impl ::std::convert::From<&Self> for SubscriptionMethodResponseInner {
        fn from(value: &SubscriptionMethodResponseInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SubscriptionMethodResponseInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Creditcard => f.write_str("creditcard"),
                Self::Directdebit => f.write_str("directdebit"),
                Self::Paypal => f.write_str("paypal"),
            }
        }
    }

    impl ::std::str::FromStr for SubscriptionMethodResponseInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "creditcard" => Ok(Self::Creditcard),
                "directdebit" => Ok(Self::Directdebit),
                "paypal" => Ok(Self::Paypal),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SubscriptionMethodResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SubscriptionMethodResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SubscriptionMethodResponseInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SubscriptionRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "required": [
    ///        "customer",
    ///        "documentation",
    ///        "profile",
    ///        "self"
    ///      ],
    ///      "properties": {
    ///        "customer": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        },
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "mandate": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        },
    ///        "payments": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        },
    ///        "profile": {
    ///          "$ref": "#/components/schemas/url-nullable"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "applicationFee": {
    ///      "description": "With Mollie Connect you can charge fees on payments
    /// that your app is processing on behalf of other
    /// Mollie\nmerchants.\n\nSetting an application fee on the subscription
    /// will ensure this fee is charged on each individual payment.\n\nRefer to
    /// the `applicationFee` parameter on the [Get payment
    /// endpoint](get-payment) documentation for more\ninformation.",
    ///      "type": "object",
    ///      "required": [
    ///        "amount",
    ///        "description"
    ///      ],
    ///      "properties": {
    ///        "amount": {
    ///          "$ref": "#/components/schemas/amount"
    ///        },
    ///        "description": {
    ///          "examples": [
    ///            "Platform fee"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "canceledAt": {
    ///      "description": "The subscription's date and time of cancellation,
    /// in ISO 8601 format. This parameter is omitted if the\nsubscription is
    /// not canceled (yet).",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2025-01-01T13:10:19.0Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "createdAt": {
    ///      "$ref": "#/components/schemas/created-at"
    ///    },
    ///    "description": {
    ///      "description": "The subscription's description will be used as the
    /// description of the resulting individual payments and so showing\nup on
    /// the bank statement of the consumer.\n\n**Please note:** the description
    /// needs to be unique for the Customer in case it has multiple active
    /// subscriptions.",
    ///      "examples": [
    ///        "Subscription of streaming channel"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "$ref": "#/components/schemas/subscriptionToken"
    ///    },
    ///    "interval": {
    ///      "description": "Interval to wait between payments, for example `1
    /// month` or `14 days`.\n\nThe maximum interval is one year (`12 months`,
    /// `52 weeks`, or `365 days`).\n\nPossible values: `... days`, `... weeks`,
    /// `... months`.",
    ///      "examples": [
    ///        "2 days"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\d+ (days|weeks|months)$"
    ///    },
    ///    "mandateId": {
    ///      "$ref": "#/components/schemas/mandateToken"
    ///    },
    ///    "metadata": {
    ///      "$ref": "#/components/schemas/metadata"
    ///    },
    ///    "method": {
    ///      "$ref": "#/components/schemas/subscription-method"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/mode"
    ///    },
    ///    "nextPaymentDate": {
    ///      "description": "The date of the next scheduled payment in
    /// `YYYY-MM-DD` format. If the subscription has been completed or
    /// canceled,\nthis parameter will not be returned.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "2025-01-01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a subscription
    /// object. Will always contain the string `subscription` for
    /// this\nendpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "subscription"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "startDate": {
    ///      "description": "The start date of the subscription in `YYYY-MM-DD`
    /// format.",
    ///      "examples": [
    ///        "2025-01-01"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/subscription-status"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    },
    ///    "times": {
    ///      "description": "Total number of payments for the subscription. Once
    /// this number of payments is reached, the subscription is\nconsidered
    /// completed.\n\nTest mode subscriptions will get canceled automatically
    /// after 10 payments.",
    ///      "examples": [
    ///        6
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "timesRemaining": {
    ///      "description": "Number of payments left for the subscription.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        5
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "webhookUrl": {
    ///      "description": "We will call this URL for any payment status
    /// changes of payments resulting from this subscription.\n\nThis webhook
    /// will receive **all** events for the subscription's payments. This may
    /// include payment failures as\nwell. Be sure to verify the payment's
    /// subscription ID and its status.",
    ///      "examples": [
    ///        "https://example.com/webhook"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SubscriptionRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<Amount>,
        #[serde(
            rename = "applicationFee",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub application_fee: ::std::option::Option<SubscriptionRequestApplicationFee>,
        ///The subscription's date and time of cancellation, in ISO 8601
        /// format. This parameter is omitted if the subscription is not
        /// canceled (yet).
        #[serde(
            rename = "canceledAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub canceled_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<CreatedAt>,
        ///The subscription's description will be used as the description of
        /// the resulting individual payments and so showing
        /// up on the bank statement of the consumer.
        ///
        ///**Please note:** the description needs to be unique for the Customer
        /// in case it has multiple active subscriptions.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<SubscriptionToken>,
        ///Interval to wait between payments, for example `1 month` or `14
        /// days`.
        ///
        ///The maximum interval is one year (`12 months`, `52 weeks`, or `365
        /// days`).
        ///
        ///Possible values: `... days`, `... weeks`, `... months`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub interval: ::std::option::Option<SubscriptionRequestInterval>,
        #[serde(
            rename = "_links",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub links: ::std::option::Option<SubscriptionRequestLinks>,
        #[serde(
            rename = "mandateId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub mandate_id: ::std::option::Option<MandateToken>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<Metadata>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub method: ::std::option::Option<SubscriptionMethod>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<Mode>,
        ///The date of the next scheduled payment in `YYYY-MM-DD` format. If
        /// the subscription has been completed or canceled,
        /// this parameter will not be returned.
        #[serde(
            rename = "nextPaymentDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub next_payment_date: ::std::option::Option<::std::string::String>,
        ///Indicates the response contains a subscription object. Will always
        /// contain the string `subscription` for this endpoint.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<::std::string::String>,
        ///The start date of the subscription in `YYYY-MM-DD` format.
        #[serde(
            rename = "startDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub start_date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<SubscriptionStatus>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
        ///Total number of payments for the subscription. Once this number of
        /// payments is reached, the subscription is considered
        /// completed.
        ///
        ///Test mode subscriptions will get canceled automatically after 10
        /// payments.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub times: ::std::option::Option<i64>,
        ///Number of payments left for the subscription.
        #[serde(
            rename = "timesRemaining",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub times_remaining: ::std::option::Option<i64>,
        ///We will call this URL for any payment status changes of payments
        /// resulting from this subscription.
        ///
        ///This webhook will receive **all** events for the subscription's
        /// payments. This may include payment failures as well. Be sure
        /// to verify the payment's subscription ID and its status.
        #[serde(
            rename = "webhookUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub webhook_url: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SubscriptionRequest> for SubscriptionRequest {
        fn from(value: &SubscriptionRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SubscriptionRequest {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                application_fee: Default::default(),
                canceled_at: Default::default(),
                created_at: Default::default(),
                description: Default::default(),
                id: Default::default(),
                interval: Default::default(),
                links: Default::default(),
                mandate_id: Default::default(),
                metadata: Default::default(),
                method: Default::default(),
                mode: Default::default(),
                next_payment_date: Default::default(),
                resource: Default::default(),
                start_date: Default::default(),
                status: Default::default(),
                testmode: Default::default(),
                times: Default::default(),
                times_remaining: Default::default(),
                webhook_url: Default::default(),
            }
        }
    }

    ///With Mollie Connect you can charge fees on payments that your app is
    /// processing on behalf of other Mollie merchants.
    ///
    ///Setting an application fee on the subscription will ensure this fee is
    /// charged on each individual payment.
    ///
    ///Refer to the `applicationFee` parameter on the [Get payment
    /// endpoint](get-payment) documentation for more information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "With Mollie Connect you can charge fees on payments
    /// that your app is processing on behalf of other
    /// Mollie\nmerchants.\n\nSetting an application fee on the subscription
    /// will ensure this fee is charged on each individual payment.\n\nRefer to
    /// the `applicationFee` parameter on the [Get payment
    /// endpoint](get-payment) documentation for more\ninformation.",
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "description"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "Platform fee"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SubscriptionRequestApplicationFee {
        pub amount: Amount,
        pub description: ::std::string::String,
    }

    impl ::std::convert::From<&SubscriptionRequestApplicationFee>
        for SubscriptionRequestApplicationFee
    {
        fn from(value: &SubscriptionRequestApplicationFee) -> Self {
            value.clone()
        }
    }

    ///Interval to wait between payments, for example `1 month` or `14 days`.
    ///
    ///The maximum interval is one year (`12 months`, `52 weeks`, or `365
    /// days`).
    ///
    ///Possible values: `... days`, `... weeks`, `... months`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Interval to wait between payments, for example `1
    /// month` or `14 days`.\n\nThe maximum interval is one year (`12 months`,
    /// `52 weeks`, or `365 days`).\n\nPossible values: `... days`, `... weeks`,
    /// `... months`.",
    ///  "examples": [
    ///    "2 days"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+ (days|weeks|months)$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SubscriptionRequestInterval(::std::string::String);
    impl ::std::ops::Deref for SubscriptionRequestInterval {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<SubscriptionRequestInterval> for ::std::string::String {
        fn from(value: SubscriptionRequestInterval) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SubscriptionRequestInterval> for SubscriptionRequestInterval {
        fn from(value: &SubscriptionRequestInterval) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for SubscriptionRequestInterval {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^\\d+ (days|weeks|months)$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+ (days|weeks|months)$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for SubscriptionRequestInterval {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SubscriptionRequestInterval {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SubscriptionRequestInterval {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for SubscriptionRequestInterval {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "required": [
    ///    "customer",
    ///    "documentation",
    ///    "profile",
    ///    "self"
    ///  ],
    ///  "properties": {
    ///    "customer": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "mandate": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "payments": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "profile": {
    ///      "$ref": "#/components/schemas/url-nullable"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SubscriptionRequestLinks {
        pub customer: UrlNullable,
        pub documentation: Url,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mandate: ::std::option::Option<UrlNullable>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payments: ::std::option::Option<UrlNullable>,
        pub profile: UrlNullable,
        #[serde(rename = "self")]
        pub self_: Url,
    }

    impl ::std::convert::From<&SubscriptionRequestLinks> for SubscriptionRequestLinks {
        fn from(value: &SubscriptionRequestLinks) -> Self {
            value.clone()
        }
    }

    ///`SubscriptionResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/entity-subscription"
    ///    }
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SubscriptionResponse(pub EntitySubscription);
    impl ::std::ops::Deref for SubscriptionResponse {
        type Target = EntitySubscription;
        fn deref(&self) -> &EntitySubscription {
            &self.0
        }
    }

    impl ::std::convert::From<SubscriptionResponse> for EntitySubscription {
        fn from(value: SubscriptionResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SubscriptionResponse> for SubscriptionResponse {
        fn from(value: &SubscriptionResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<EntitySubscription> for SubscriptionResponse {
        fn from(value: EntitySubscription) -> Self {
            Self(value)
        }
    }

    ///The subscription's current status is directly related to the status of
    /// the underlying customer or mandate that is enabling the
    /// subscription.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The subscription's current status is directly related
    /// to the status of the underlying customer or mandate that is\nenabling
    /// the subscription.",
    ///  "examples": [
    ///    "active"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "pending",
    ///    "active",
    ///    "canceled",
    ///    "suspended",
    ///    "completed"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SubscriptionStatus {
        #[serde(rename = "pending")]
        Pending,
        #[serde(rename = "active")]
        Active,
        #[serde(rename = "canceled")]
        Canceled,
        #[serde(rename = "suspended")]
        Suspended,
        #[serde(rename = "completed")]
        Completed,
    }

    impl ::std::convert::From<&Self> for SubscriptionStatus {
        fn from(value: &SubscriptionStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SubscriptionStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Pending => f.write_str("pending"),
                Self::Active => f.write_str("active"),
                Self::Canceled => f.write_str("canceled"),
                Self::Suspended => f.write_str("suspended"),
                Self::Completed => f.write_str("completed"),
            }
        }
    }

    impl ::std::str::FromStr for SubscriptionStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "pending" => Ok(Self::Pending),
                "active" => Ok(Self::Active),
                "canceled" => Ok(Self::Canceled),
                "suspended" => Ok(Self::Suspended),
                "completed" => Ok(Self::Completed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SubscriptionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SubscriptionStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SubscriptionStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SubscriptionToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "sub_5B8cwPMGnU"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct SubscriptionToken(pub ::std::string::String);
    impl ::std::ops::Deref for SubscriptionToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<SubscriptionToken> for ::std::string::String {
        fn from(value: SubscriptionToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SubscriptionToken> for SubscriptionToken {
        fn from(value: &SubscriptionToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for SubscriptionToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for SubscriptionToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for SubscriptionToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///The brand of the terminal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The brand of the terminal.",
    ///  "examples": [
    ///    "PAX"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "PAX",
    ///    "Tap"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct TerminalBrand(pub ::std::option::Option<TerminalBrandInner>);
    impl ::std::ops::Deref for TerminalBrand {
        type Target = ::std::option::Option<TerminalBrandInner>;
        fn deref(&self) -> &::std::option::Option<TerminalBrandInner> {
            &self.0
        }
    }

    impl ::std::convert::From<TerminalBrand> for ::std::option::Option<TerminalBrandInner> {
        fn from(value: TerminalBrand) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&TerminalBrand> for TerminalBrand {
        fn from(value: &TerminalBrand) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<TerminalBrandInner>> for TerminalBrand {
        fn from(value: ::std::option::Option<TerminalBrandInner>) -> Self {
            Self(value)
        }
    }

    ///The brand of the terminal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The brand of the terminal.",
    ///  "examples": [
    ///    "PAX"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "PAX",
    ///    "Tap"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TerminalBrandInner {
        #[serde(rename = "PAX")]
        Pax,
        Tap,
    }

    impl ::std::convert::From<&Self> for TerminalBrandInner {
        fn from(value: &TerminalBrandInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TerminalBrandInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Pax => f.write_str("PAX"),
                Self::Tap => f.write_str("Tap"),
            }
        }
    }

    impl ::std::str::FromStr for TerminalBrandInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "PAX" => Ok(Self::Pax),
                "Tap" => Ok(Self::Tap),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for TerminalBrandInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for TerminalBrandInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for TerminalBrandInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The model of the terminal. For example for a PAX A920, this field's
    /// value will be `A920`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The model of the terminal. For example for a PAX A920,
    /// this field's value will be `A920`.",
    ///  "examples": [
    ///    "A920"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ],
    ///  "enum": [
    ///    "A35",
    ///    "A77",
    ///    "A920",
    ///    "A920Pro",
    ///    "IM30",
    ///    "Tap"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct TerminalModel(pub ::std::option::Option<TerminalModelInner>);
    impl ::std::ops::Deref for TerminalModel {
        type Target = ::std::option::Option<TerminalModelInner>;
        fn deref(&self) -> &::std::option::Option<TerminalModelInner> {
            &self.0
        }
    }

    impl ::std::convert::From<TerminalModel> for ::std::option::Option<TerminalModelInner> {
        fn from(value: TerminalModel) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&TerminalModel> for TerminalModel {
        fn from(value: &TerminalModel) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<TerminalModelInner>> for TerminalModel {
        fn from(value: ::std::option::Option<TerminalModelInner>) -> Self {
            Self(value)
        }
    }

    ///The model of the terminal. For example for a PAX A920, this field's
    /// value will be `A920`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The model of the terminal. For example for a PAX A920,
    /// this field's value will be `A920`.",
    ///  "examples": [
    ///    "A920"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "A35",
    ///    "A77",
    ///    "A920",
    ///    "A920Pro",
    ///    "IM30",
    ///    "Tap"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TerminalModelInner {
        A35,
        A77,
        A920,
        A920Pro,
        #[serde(rename = "IM30")]
        Im30,
        Tap,
    }

    impl ::std::convert::From<&Self> for TerminalModelInner {
        fn from(value: &TerminalModelInner) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TerminalModelInner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::A35 => f.write_str("A35"),
                Self::A77 => f.write_str("A77"),
                Self::A920 => f.write_str("A920"),
                Self::A920Pro => f.write_str("A920Pro"),
                Self::Im30 => f.write_str("IM30"),
                Self::Tap => f.write_str("Tap"),
            }
        }
    }

    impl ::std::str::FromStr for TerminalModelInner {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "A35" => Ok(Self::A35),
                "A77" => Ok(Self::A77),
                "A920" => Ok(Self::A920),
                "A920Pro" => Ok(Self::A920Pro),
                "IM30" => Ok(Self::Im30),
                "Tap" => Ok(Self::Tap),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for TerminalModelInner {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for TerminalModelInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for TerminalModelInner {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The status of the terminal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status of the terminal.",
    ///  "examples": [
    ///    "active"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "pending",
    ///    "active",
    ///    "inactive"
    ///  ],
    ///  "x-enumDescriptions": {
    ///    "active": "The terminal is fully configured and ready to accept
    /// payments.",
    ///    "inactive": "The terminal has been deactivated. Deactivation happens
    /// for example if you returned the device to\nMollie, or if you requested
    /// to move it to another profile or organization.",
    ///    "pending": "The device has been linked to your account, but has not
    /// yet been activated. If you ordered a terminal\nfrom us, it may already
    /// become visible in your account with this status."
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TerminalStatus {
        #[serde(rename = "pending")]
        Pending,
        #[serde(rename = "active")]
        Active,
        #[serde(rename = "inactive")]
        Inactive,
    }

    impl ::std::convert::From<&Self> for TerminalStatus {
        fn from(value: &TerminalStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TerminalStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Pending => f.write_str("pending"),
                Self::Active => f.write_str("active"),
                Self::Inactive => f.write_str("inactive"),
            }
        }
    }

    impl ::std::str::FromStr for TerminalStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "pending" => Ok(Self::Pending),
                "active" => Ok(Self::Active),
                "inactive" => Ok(Self::Inactive),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for TerminalStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for TerminalStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for TerminalStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`TerminalToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "term_vytxeTZskVKR7C7WgdSP3d"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct TerminalToken(pub ::std::string::String);
    impl ::std::ops::Deref for TerminalToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<TerminalToken> for ::std::string::String {
        fn from(value: TerminalToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&TerminalToken> for TerminalToken {
        fn from(value: &TerminalToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for TerminalToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for TerminalToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for TerminalToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`TestWebhookBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TestWebhookBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<Testmode>,
    }

    impl ::std::convert::From<&TestWebhookBody> for TestWebhookBody {
        fn from(value: &TestWebhookBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TestWebhookBody {
        fn default() -> Self {
            Self {
                testmode: Default::default(),
            }
        }
    }

    ///Most API credentials are specifically created for either live mode or
    /// test mode. For organization-level credentials such as OAuth access
    /// tokens, you can enable test mode by setting `testmode` to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Most API credentials are specifically created for
    /// either live mode or test mode. For organization-level credentials\nsuch
    /// as OAuth access tokens, you can enable test mode by setting `testmode`
    /// to `true`.\n\nTest entities cannot be retrieved when the endpoint is set
    /// to live mode, and vice versa.",
    ///  "writeOnly": true,
    ///  "examples": [
    ///    false
    ///  ],
    ///  "type": [
    ///    "boolean",
    ///    "null"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct Testmode(pub ::std::option::Option<bool>);
    impl ::std::ops::Deref for Testmode {
        type Target = ::std::option::Option<bool>;
        fn deref(&self) -> &::std::option::Option<bool> {
            &self.0
        }
    }

    impl ::std::convert::From<Testmode> for ::std::option::Option<bool> {
        fn from(value: Testmode) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&Testmode> for Testmode {
        fn from(value: &Testmode) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<bool>> for Testmode {
        fn from(value: ::std::option::Option<bool>) -> Self {
            Self(value)
        }
    }

    ///Whether to create the entity in test mode or live mode.
    ///
    ///Most API credentials are specifically created for either live mode or
    /// test mode, in which case this parameter can be omitted. For
    /// organization-level credentials such as OAuth access tokens, you can
    /// enable test mode by setting `testmode` to `true`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Whether to create the entity in test mode or live
    /// mode.\n\nMost API credentials are specifically created for either live
    /// mode or test mode, in which case this parameter can be\nomitted. For
    /// organization-level credentials such as OAuth access tokens, you can
    /// enable test mode by setting\n`testmode` to `true`.",
    ///  "writeOnly": true,
    ///  "examples": [
    ///    false
    ///  ],
    ///  "type": [
    ///    "boolean",
    ///    "null"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct TestmodeCreate(pub ::std::option::Option<bool>);
    impl ::std::ops::Deref for TestmodeCreate {
        type Target = ::std::option::Option<bool>;
        fn deref(&self) -> &::std::option::Option<bool> {
            &self.0
        }
    }

    impl ::std::convert::From<TestmodeCreate> for ::std::option::Option<bool> {
        fn from(value: TestmodeCreate) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&TestmodeCreate> for TestmodeCreate {
        fn from(value: &TestmodeCreate) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<bool>> for TestmodeCreate {
        fn from(value: ::std::option::Option<bool>) -> Self {
            Self(value)
        }
    }

    ///`TransferToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "trf_nyjwa2"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct TransferToken(pub ::std::string::String);
    impl ::std::ops::Deref for TransferToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<TransferToken> for ::std::string::String {
        fn from(value: TransferToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&TransferToken> for TransferToken {
        fn from(value: &TransferToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for TransferToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for TransferToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for TransferToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`UpdatePaymentBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "billingAddress": {
    ///      "$ref": "#/components/schemas/billingAddress"
    ///    },
    ///    "billingEmail": {
    ///      "examples": [
    ///        "test@example.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cancelUrl": {
    ///      "$ref": "#/components/schemas/cancelUrl"
    ///    },
    ///    "description": {
    ///      "$ref": "#/components/schemas/description"
    ///    },
    ///    "dueDate": {
    ///      "$ref": "#/components/schemas/dueDate"
    ///    },
    ///    "issuer": {
    ///      "$ref": "#/components/schemas/issuer"
    ///    },
    ///    "locale": {
    ///      "$ref": "#/components/schemas/locale"
    ///    },
    ///    "metadata": {
    ///      "$ref": "#/components/schemas/metadata"
    ///    },
    ///    "method": {
    ///      "$ref": "#/components/schemas/method"
    ///    },
    ///    "redirectUrl": {
    ///      "$ref": "#/components/schemas/redirectUrl"
    ///    },
    ///    "restrictPaymentMethodsToCountry": {
    ///      "$ref": "#/components/schemas/restrictPaymentMethodsToCountry"
    ///    },
    ///    "shippingAddress": {
    ///      "$ref": "#/components/schemas/payment-address"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode-create"
    ///    },
    ///    "webhookUrl": {
    ///      "$ref": "#/components/schemas/webhookUrl"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdatePaymentBody {
        #[serde(
            rename = "billingAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub billing_address: ::std::option::Option<BillingAddress>,
        #[serde(
            rename = "billingEmail",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub billing_email: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "cancelUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub cancel_url: ::std::option::Option<CancelUrl>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<Description>,
        #[serde(
            rename = "dueDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub due_date: ::std::option::Option<DueDate>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub issuer: ::std::option::Option<Issuer>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub locale: ::std::option::Option<Locale>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<Metadata>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub method: ::std::option::Option<Method>,
        #[serde(
            rename = "redirectUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub redirect_url: ::std::option::Option<RedirectUrl>,
        #[serde(
            rename = "restrictPaymentMethodsToCountry",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub restrict_payment_methods_to_country:
            ::std::option::Option<RestrictPaymentMethodsToCountry>,
        #[serde(
            rename = "shippingAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub shipping_address: ::std::option::Option<PaymentAddress>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<TestmodeCreate>,
        #[serde(
            rename = "webhookUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub webhook_url: ::std::option::Option<WebhookUrl>,
    }

    impl ::std::convert::From<&UpdatePaymentBody> for UpdatePaymentBody {
        fn from(value: &UpdatePaymentBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdatePaymentBody {
        fn default() -> Self {
            Self {
                billing_address: Default::default(),
                billing_email: Default::default(),
                cancel_url: Default::default(),
                description: Default::default(),
                due_date: Default::default(),
                issuer: Default::default(),
                locale: Default::default(),
                metadata: Default::default(),
                method: Default::default(),
                redirect_url: Default::default(),
                restrict_payment_methods_to_country: Default::default(),
                shipping_address: Default::default(),
                testmode: Default::default(),
                webhook_url: Default::default(),
            }
        }
    }

    ///`UpdatePaymentLinkBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "allowedMethods": {
    ///      "$ref": "#/components/schemas/payment-link-methods"
    ///    },
    ///    "archived": {
    ///      "description": "Whether the payment link is archived. Customers
    /// will not be able to complete payments on archived\npayment links.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "billingAddress": {
    ///      "$ref": "#/components/schemas/payment-address"
    ///    },
    ///    "description": {
    ///      "description": "A short description of the payment link. The
    /// description is visible in the Dashboard and will be shown\non the
    /// customer's bank or card statement when possible.\n\nUpdating the
    /// description does not affect any previously existing payments created for
    /// this payment link.",
    ///      "examples": [
    ///        "Chess Board"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "lines": {
    ///      "description": "Optionally provide the order lines for the payment.
    /// Each line contains details such as a description of the item\nordered
    /// and its price.\n\nAll lines must have the same currency as the
    /// payment.\n\nRequired for payment methods `billie`, `in3`, `klarna`,
    /// `riverty` and `voucher`.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/payment-line-item"
    ///      }
    ///    },
    ///    "minimumAmount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "shippingAddress": {
    ///      "$ref": "#/components/schemas/payment-address"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdatePaymentLinkBody {
        #[serde(
            rename = "allowedMethods",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub allowed_methods: ::std::option::Option<PaymentLinkMethods>,
        ///Whether the payment link is archived. Customers will not be able to
        /// complete payments on archived payment links.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub archived: ::std::option::Option<bool>,
        #[serde(
            rename = "billingAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub billing_address: ::std::option::Option<PaymentAddress>,
        ///A short description of the payment link. The description is visible
        /// in the Dashboard and will be shown on the customer's bank or
        /// card statement when possible.
        ///
        ///Updating the description does not affect any previously existing
        /// payments created for this payment link.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<UpdatePaymentLinkBodyDescription>,
        ///Optionally provide the order lines for the payment. Each line
        /// contains details such as a description of the item
        /// ordered and its price.
        ///
        ///All lines must have the same currency as the payment.
        ///
        ///Required for payment methods `billie`, `in3`, `klarna`, `riverty`
        /// and `voucher`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub lines: ::std::option::Option<::std::vec::Vec<PaymentLineItem>>,
        #[serde(
            rename = "minimumAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub minimum_amount: ::std::option::Option<Amount>,
        #[serde(
            rename = "shippingAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub shipping_address: ::std::option::Option<PaymentAddress>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<Testmode>,
    }

    impl ::std::convert::From<&UpdatePaymentLinkBody> for UpdatePaymentLinkBody {
        fn from(value: &UpdatePaymentLinkBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdatePaymentLinkBody {
        fn default() -> Self {
            Self {
                allowed_methods: Default::default(),
                archived: Default::default(),
                billing_address: Default::default(),
                description: Default::default(),
                lines: Default::default(),
                minimum_amount: Default::default(),
                shipping_address: Default::default(),
                testmode: Default::default(),
            }
        }
    }

    ///A short description of the payment link. The description is visible in
    /// the Dashboard and will be shown on the customer's bank or card
    /// statement when possible.
    ///
    ///Updating the description does not affect any previously existing
    /// payments created for this payment link.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A short description of the payment link. The
    /// description is visible in the Dashboard and will be shown\non the
    /// customer's bank or card statement when possible.\n\nUpdating the
    /// description does not affect any previously existing payments created for
    /// this payment link.",
    ///  "examples": [
    ///    "Chess Board"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdatePaymentLinkBodyDescription(::std::string::String);
    impl ::std::ops::Deref for UpdatePaymentLinkBodyDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdatePaymentLinkBodyDescription> for ::std::string::String {
        fn from(value: UpdatePaymentLinkBodyDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdatePaymentLinkBodyDescription> for UpdatePaymentLinkBodyDescription {
        fn from(value: &UpdatePaymentLinkBodyDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdatePaymentLinkBodyDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdatePaymentLinkBodyDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdatePaymentLinkBodyDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdatePaymentLinkBodyDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdatePaymentLinkBodyDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateProfileBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "businessCategory": {
    ///      "description": "The industry associated with the profile's trade
    /// name or brand. Please refer to the\n[business category
    /// list](common-data-types) for all possible options.",
    ///      "examples": [
    ///        "OTHER_MERCHANDISE"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "countriesOfActivity": {
    ///      "description": "A list of countries where you expect that the majority of the profile's customers reside,\nin [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.",
    ///      "examples": [
    ///        [
    ///          "NL",
    ///          "GB"
    ///        ]
    ///      ],
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "description": {
    ///      "description": "The products or services offered by the profile's
    /// website or application.",
    ///      "examples": [
    ///        "My website description"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "maxLength": 500
    ///    },
    ///    "email": {
    ///      "description": "The email address associated with the profile's
    /// trade name or brand.",
    ///      "examples": [
    ///        "test@mollie.com"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "mode": {
    ///      "description": "Updating a profile from `test` mode to `live` mode
    /// will trigger a verification process, where we review\nthe profile before
    /// it can start accepting payments.",
    ///      "examples": [
    ///        "live"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "enum": [
    ///        "live",
    ///        "test"
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "The profile's name, this will usually reflect the
    /// trade name or brand name of the profile's website or\napplication.",
    ///      "examples": [
    ///        "My new website name"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "phone": {
    ///      "description": "The phone number associated with the profile's
    /// trade name or brand.",
    ///      "examples": [
    ///        "+31208202071"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "website": {
    ///      "description": "The URL to the profile's website or application. Only `https` or `http` URLs are allowed. No `@` signs\nare allowed.",
    ///      "examples": [
    ///        "https://example.com"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateProfileBody {
        ///The industry associated with the profile's trade name or brand.
        /// Please refer to the [business category
        /// list](common-data-types) for all possible options.
        #[serde(
            rename = "businessCategory",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub business_category: ::std::option::Option<::std::string::String>,
        ///A list of countries where you expect that the majority of the
        /// profile's customers reside, in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
        #[serde(
            rename = "countriesOfActivity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub countries_of_activity: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
        ///The products or services offered by the profile's website or
        /// application.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<UpdateProfileBodyDescription>,
        ///The email address associated with the profile's trade name or brand.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        ///Updating a profile from `test` mode to `live` mode will trigger a
        /// verification process, where we review the profile before it
        /// can start accepting payments.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<UpdateProfileBodyMode>,
        ///The profile's name, this will usually reflect the trade name or
        /// brand name of the profile's website or application.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///The phone number associated with the profile's trade name or brand.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub phone: ::std::option::Option<::std::string::String>,
        ///The URL to the profile's website or application. Only `https` or
        /// `http` URLs are allowed. No `@` signs are allowed.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub website: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UpdateProfileBody> for UpdateProfileBody {
        fn from(value: &UpdateProfileBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdateProfileBody {
        fn default() -> Self {
            Self {
                business_category: Default::default(),
                countries_of_activity: Default::default(),
                description: Default::default(),
                email: Default::default(),
                mode: Default::default(),
                name: Default::default(),
                phone: Default::default(),
                website: Default::default(),
            }
        }
    }

    ///The products or services offered by the profile's website or
    /// application.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The products or services offered by the profile's
    /// website or application.",
    ///  "examples": [
    ///    "My website description"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 500
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateProfileBodyDescription(::std::string::String);
    impl ::std::ops::Deref for UpdateProfileBodyDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateProfileBodyDescription> for ::std::string::String {
        fn from(value: UpdateProfileBodyDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateProfileBodyDescription> for UpdateProfileBodyDescription {
        fn from(value: &UpdateProfileBodyDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateProfileBodyDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 500usize {
                return Err("longer than 500 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateProfileBodyDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdateProfileBodyDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdateProfileBodyDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateProfileBodyDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Updating a profile from `test` mode to `live` mode will trigger a
    /// verification process, where we review the profile before it can
    /// start accepting payments.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Updating a profile from `test` mode to `live` mode will
    /// trigger a verification process, where we review\nthe profile before it
    /// can start accepting payments.",
    ///  "examples": [
    ///    "live"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "live",
    ///    "test"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UpdateProfileBodyMode {
        #[serde(rename = "live")]
        Live,
        #[serde(rename = "test")]
        Test,
    }

    impl ::std::convert::From<&Self> for UpdateProfileBodyMode {
        fn from(value: &UpdateProfileBodyMode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UpdateProfileBodyMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Live => f.write_str("live"),
                Self::Test => f.write_str("test"),
            }
        }
    }

    impl ::std::str::FromStr for UpdateProfileBodyMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "live" => Ok(Self::Live),
                "test" => Ok(Self::Test),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateProfileBodyMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdateProfileBodyMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdateProfileBodyMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`UpdateSubscriptionBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/amount"
    ///    },
    ///    "description": {
    ///      "description": "The subscription's description will be used as the
    /// description of the resulting individual payments and so showing\nup on
    /// the bank statement of the consumer.\n\n**Please note:** the description
    /// needs to be unique for the Customer in case it has multiple active
    /// subscriptions.",
    ///      "examples": [
    ///        "Subscription of streaming channel"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interval": {
    ///      "description": "Interval to wait between payments, for example `1
    /// month` or `14 days`.\n\nThe maximum interval is one year (`12 months`,
    /// `52 weeks`, or `365 days`).\n\nPossible values: `... days`, `... weeks`,
    /// `... months`.",
    ///      "examples": [
    ///        "1 months"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "mandateId": {
    ///      "$ref": "#/components/schemas/mandateToken"
    ///    },
    ///    "metadata": {
    ///      "$ref": "#/components/schemas/metadata"
    ///    },
    ///    "startDate": {
    ///      "description": "The start date of the subscription in `YYYY-MM-DD`
    /// format.",
    ///      "examples": [
    ///        "2025-01-01"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode"
    ///    },
    ///    "times": {
    ///      "description": "Total number of payments for the subscription. Once
    /// this number of payments is reached, the subscription is\nconsidered
    /// completed.\n\nTest mode subscriptions will get canceled automatically
    /// after 10 payments.",
    ///      "examples": [
    ///        6
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "webhookUrl": {
    ///      "description": "We will call this URL for any payment status
    /// changes of payments resulting from this subscription.\n\nThis webhook
    /// will receive **all** events for the subscription's payments. This may
    /// include payment\nfailures as well. Be sure to verify the payment's
    /// subscription ID and its status.",
    ///      "examples": [
    ///        "https://example.com/webhook"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateSubscriptionBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<Amount>,
        ///The subscription's description will be used as the description of
        /// the resulting individual payments and so showing
        /// up on the bank statement of the consumer.
        ///
        ///**Please note:** the description needs to be unique for the Customer
        /// in case it has multiple active subscriptions.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        ///Interval to wait between payments, for example `1 month` or `14
        /// days`.
        ///
        ///The maximum interval is one year (`12 months`, `52 weeks`, or `365
        /// days`).
        ///
        ///Possible values: `... days`, `... weeks`, `... months`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub interval: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "mandateId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub mandate_id: ::std::option::Option<MandateToken>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<Metadata>,
        ///The start date of the subscription in `YYYY-MM-DD` format.
        #[serde(
            rename = "startDate",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub start_date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<Testmode>,
        ///Total number of payments for the subscription. Once this number of
        /// payments is reached, the subscription is considered
        /// completed.
        ///
        ///Test mode subscriptions will get canceled automatically after 10
        /// payments.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub times: ::std::option::Option<i64>,
        ///We will call this URL for any payment status changes of payments
        /// resulting from this subscription.
        ///
        ///This webhook will receive **all** events for the subscription's
        /// payments. This may include payment failures as well. Be sure
        /// to verify the payment's subscription ID and its status.
        #[serde(
            rename = "webhookUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub webhook_url: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UpdateSubscriptionBody> for UpdateSubscriptionBody {
        fn from(value: &UpdateSubscriptionBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdateSubscriptionBody {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                description: Default::default(),
                interval: Default::default(),
                mandate_id: Default::default(),
                metadata: Default::default(),
                start_date: Default::default(),
                testmode: Default::default(),
                times: Default::default(),
                webhook_url: Default::default(),
            }
        }
    }

    ///`UpdateValuesSalesInvoice`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "discount": {
    ///      "$ref": "#/components/schemas/sales-invoice-discount"
    ///    },
    ///    "emailDetails": {
    ///      "$ref": "#/components/schemas/sales-invoice-email-details"
    ///    },
    ///    "isEInvoice": {
    ///      "description": "This indicates whether the invoice is an e-invoice.
    /// The default value is `false` and can't be changed\nafter the invoice has
    /// been issued.\n\nWhen `emailDetails` is provided, an additional email is
    /// sent to the recipient.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "lines": {
    ///      "description": "Provide the line items for the invoice. Each line
    /// contains details such as a description of the item\nordered and its
    /// price.\n\nAll lines must have the same currency as the invoice.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/sales-invoice-line-item"
    ///      }
    ///    },
    ///    "memo": {
    ///      "description": "A free-form memo you can set on the invoice, and
    /// will be shown on the invoice PDF.",
    ///      "examples": [
    ///        "An updated memo!"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "paymentDetails": {
    ///      "$ref": "#/components/schemas/sales-invoice-payment-details"
    ///    },
    ///    "paymentTerm": {
    ///      "$ref": "#/components/schemas/sales-invoice-payment-term"
    ///    },
    ///    "recipient": {
    ///      "$ref": "#/components/schemas/sales-invoice-recipient"
    ///    },
    ///    "recipientIdentifier": {
    ///      "description": "An identifier tied to the recipient data. This
    /// should be a unique value based on data your system contains,\nso that
    /// both you and us know who we're referring to. It is a value you provide
    /// to us so that recipient management\nis not required to send a first
    /// invoice to a recipient.",
    ///      "examples": [
    ///        "customer-xyz-0123"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/sales-invoice-status"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateValuesSalesInvoice {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub discount: ::std::option::Option<SalesInvoiceDiscount>,
        #[serde(
            rename = "emailDetails",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub email_details: ::std::option::Option<SalesInvoiceEmailDetails>,
        ///This indicates whether the invoice is an e-invoice. The default
        /// value is `false` and can't be changed after the invoice has
        /// been issued.
        ///
        ///When `emailDetails` is provided, an additional email is sent to the
        /// recipient.
        #[serde(
            rename = "isEInvoice",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub is_e_invoice: ::std::option::Option<bool>,
        ///Provide the line items for the invoice. Each line contains details
        /// such as a description of the item ordered and its price.
        ///
        ///All lines must have the same currency as the invoice.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub lines: ::std::option::Option<::std::vec::Vec<SalesInvoiceLineItem>>,
        ///A free-form memo you can set on the invoice, and will be shown on
        /// the invoice PDF.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub memo: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentDetails",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_details: ::std::option::Option<SalesInvoicePaymentDetails>,
        #[serde(
            rename = "paymentTerm",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_term: ::std::option::Option<SalesInvoicePaymentTerm>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub recipient: ::std::option::Option<SalesInvoiceRecipient>,
        ///An identifier tied to the recipient data. This should be a unique
        /// value based on data your system contains, so that both you
        /// and us know who we're referring to. It is a value you provide to us
        /// so that recipient management is not required to send a first
        /// invoice to a recipient.
        #[serde(
            rename = "recipientIdentifier",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub recipient_identifier: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<SalesInvoiceStatus>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<Testmode>,
    }

    impl ::std::convert::From<&UpdateValuesSalesInvoice> for UpdateValuesSalesInvoice {
        fn from(value: &UpdateValuesSalesInvoice) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdateValuesSalesInvoice {
        fn default() -> Self {
            Self {
                discount: Default::default(),
                email_details: Default::default(),
                is_e_invoice: Default::default(),
                lines: Default::default(),
                memo: Default::default(),
                payment_details: Default::default(),
                payment_term: Default::default(),
                recipient: Default::default(),
                recipient_identifier: Default::default(),
                status: Default::default(),
                testmode: Default::default(),
            }
        }
    }

    ///`UpdateWebhookBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "eventTypes": {
    ///      "$ref": "#/components/schemas/webhook-event-types"
    ///    },
    ///    "name": {
    ///      "description": "A name that identifies the webhook.",
    ///      "examples": [
    ///        "Webhook #1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "testmode": {
    ///      "$ref": "#/components/schemas/testmode"
    ///    },
    ///    "url": {
    ///      "description": "The URL Mollie will send the events to. This URL
    /// must be publicly accessible.",
    ///      "examples": [
    ///        "https://mollie.com/"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateWebhookBody {
        #[serde(
            rename = "eventTypes",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub event_types: ::std::option::Option<WebhookEventTypes>,
        ///A name that identifies the webhook.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub testmode: ::std::option::Option<Testmode>,
        ///The URL Mollie will send the events to. This URL must be publicly
        /// accessible.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub url: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UpdateWebhookBody> for UpdateWebhookBody {
        fn from(value: &UpdateWebhookBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdateWebhookBody {
        fn default() -> Self {
            Self {
                event_types: Default::default(),
                name: Default::default(),
                testmode: Default::default(),
                url: Default::default(),
            }
        }
    }

    ///In v2 endpoints, URLs are commonly represented as objects with an `href`
    /// and `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "In v2 endpoints, URLs are commonly represented as
    /// objects with an `href` and `type` field.",
    ///  "type": "object",
    ///  "required": [
    ///    "href",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "description": "The actual URL string.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The content type of the page or endpoint the URL
    /// points to.",
    ///      "examples": [
    ///        "application/json"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Url {
        ///The actual URL string.
        pub href: ::std::string::String,
        ///The content type of the page or endpoint the URL points to.
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }

    impl ::std::convert::From<&Url> for Url {
        fn from(value: &Url) -> Self {
            value.clone()
        }
    }

    ///In v2 endpoints, URLs are commonly represented as objects with an `href`
    /// and `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "In v2 endpoints, URLs are commonly represented as
    /// objects with an `href` and `type` field.",
    ///  "type": [
    ///    "object",
    ///    "null"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "description": "The actual URL string.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The content type of the page or endpoint the URL
    /// points to.",
    ///      "examples": [
    ///        "application/json"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct UrlNullable(pub ::std::option::Option<UrlNullableInner>);
    impl ::std::ops::Deref for UrlNullable {
        type Target = ::std::option::Option<UrlNullableInner>;
        fn deref(&self) -> &::std::option::Option<UrlNullableInner> {
            &self.0
        }
    }

    impl ::std::convert::From<UrlNullable> for ::std::option::Option<UrlNullableInner> {
        fn from(value: UrlNullable) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UrlNullable> for UrlNullable {
        fn from(value: &UrlNullable) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<UrlNullableInner>> for UrlNullable {
        fn from(value: ::std::option::Option<UrlNullableInner>) -> Self {
            Self(value)
        }
    }

    ///In v2 endpoints, URLs are commonly represented as objects with an `href`
    /// and `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "In v2 endpoints, URLs are commonly represented as
    /// objects with an `href` and `type` field.",
    ///  "type": "object",
    ///  "properties": {
    ///    "href": {
    ///      "description": "The actual URL string.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The content type of the page or endpoint the URL
    /// points to.",
    ///      "examples": [
    ///        "application/json"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UrlNullableInner {
        ///The actual URL string.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub href: ::std::option::Option<::std::string::String>,
        ///The content type of the page or endpoint the URL points to.
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UrlNullableInner> for UrlNullableInner {
        fn from(value: &UrlNullableInner) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UrlNullableInner {
        fn default() -> Self {
            Self {
                href: Default::default(),
                type_: Default::default(),
            }
        }
    }

    ///`Voucher`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_links",
    ///    "contractor",
    ///    "id",
    ///    "image",
    ///    "name",
    ///    "resource",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "_links": {
    ///      "description": "An object with several relevant URLs. Every URL
    /// object will contain an `href` and a `type` field.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "documentation": {
    ///          "$ref": "#/components/schemas/url"
    ///        },
    ///        "self": {
    ///          "$ref": "#/components/schemas/url"
    ///        }
    ///      }
    ///    },
    ///    "contractor": {
    ///      "description": "Information regarding the *contractor*. Only
    /// relevant for `voucher` issuers.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "contractId": {
    ///          "examples": [
    ///            "someContractId"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "id": {
    ///          "examples": [
    ///            "Apetiz"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "name": {
    ///          "examples": [
    ///            "Apetiz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "The unique identifier of the payment method
    /// issuer.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "edenred-belgium-eco"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "image": {
    ///      "description": "URLs of images representing the payment method
    /// issuer.",
    ///      "readOnly": true,
    ///      "type": "object",
    ///      "properties": {
    ///        "size1x": {
    ///          "description": "The URL pointing to an icon of 32 by 24
    /// pixels.",
    ///          "examples": [
    ///            "https://..."
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "size2x": {
    ///          "description": "The URL pointing to an icon of 64 by 48
    /// pixels.",
    ///          "examples": [
    ///            "https://..."
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "svg": {
    ///          "description": "The URL pointing to a vector version of the
    /// icon. Usage of this format is preferred, since the icon can\nscale to
    /// any desired size without compromising visual quality.",
    ///          "examples": [
    ///            "https://..."
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "name": {
    ///      "description": "The full name of the payment method issuer.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "Edenred Eco"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "resource": {
    ///      "description": "Indicates the response contains a payment method
    /// issuer object. Will always contain the string `issuer` for
    /// this\nendpoint.",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "issuer"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/method-issuer-status"
    ///    }
    ///  },
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Voucher {
        pub contractor: VoucherContractor,
        ///The unique identifier of the payment method issuer.
        pub id: ::std::string::String,
        pub image: VoucherImage,
        #[serde(rename = "_links")]
        pub links: VoucherLinks,
        ///The full name of the payment method issuer.
        pub name: ::std::string::String,
        ///Indicates the response contains a payment method issuer object. Will
        /// always contain the string `issuer` for this endpoint.
        pub resource: ::std::string::String,
        pub status: MethodIssuerStatus,
    }

    impl ::std::convert::From<&Voucher> for Voucher {
        fn from(value: &Voucher) -> Self {
            value.clone()
        }
    }

    ///Information regarding the *contractor*. Only relevant for `voucher`
    /// issuers.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Information regarding the *contractor*. Only relevant
    /// for `voucher` issuers.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "contractId": {
    ///      "examples": [
    ///        "someContractId"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        "Apetiz"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "Apetiz"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VoucherContractor {
        #[serde(
            rename = "contractId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub contract_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&VoucherContractor> for VoucherContractor {
        fn from(value: &VoucherContractor) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for VoucherContractor {
        fn default() -> Self {
            Self {
                contract_id: Default::default(),
                id: Default::default(),
                name: Default::default(),
            }
        }
    }

    ///URLs of images representing the payment method issuer.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "URLs of images representing the payment method
    /// issuer.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "size1x": {
    ///      "description": "The URL pointing to an icon of 32 by 24 pixels.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "size2x": {
    ///      "description": "The URL pointing to an icon of 64 by 48 pixels.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "svg": {
    ///      "description": "The URL pointing to a vector version of the icon.
    /// Usage of this format is preferred, since the icon can\nscale to any
    /// desired size without compromising visual quality.",
    ///      "examples": [
    ///        "https://..."
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VoucherImage {
        ///The URL pointing to an icon of 32 by 24 pixels.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub size1x: ::std::option::Option<::std::string::String>,
        ///The URL pointing to an icon of 64 by 48 pixels.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub size2x: ::std::option::Option<::std::string::String>,
        ///The URL pointing to a vector version of the icon. Usage of this
        /// format is preferred, since the icon can scale to any desired
        /// size without compromising visual quality.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub svg: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&VoucherImage> for VoucherImage {
        fn from(value: &VoucherImage) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for VoucherImage {
        fn default() -> Self {
            Self {
                size1x: Default::default(),
                size2x: Default::default(),
                svg: Default::default(),
            }
        }
    }

    ///An object with several relevant URLs. Every URL object will contain an
    /// `href` and a `type` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object with several relevant URLs. Every URL object
    /// will contain an `href` and a `type` field.",
    ///  "readOnly": true,
    ///  "type": "object",
    ///  "properties": {
    ///    "documentation": {
    ///      "$ref": "#/components/schemas/url"
    ///    },
    ///    "self": {
    ///      "$ref": "#/components/schemas/url"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VoucherLinks {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub documentation: ::std::option::Option<Url>,
        #[serde(
            rename = "self",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub self_: ::std::option::Option<Url>,
    }

    impl ::std::convert::From<&VoucherLinks> for VoucherLinks {
        fn from(value: &VoucherLinks) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for VoucherLinks {
        fn default() -> Self {
            Self {
                documentation: Default::default(),
                self_: Default::default(),
            }
        }
    }

    ///The event's type
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The event's type",
    ///  "examples": [
    ///    "payment-link.paid"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "payment-link.paid",
    ///    "balance-transaction.created",
    ///    "sales-invoice.created",
    ///    "sales-invoice.issued",
    ///    "sales-invoice.canceled",
    ///    "sales-invoice.paid",
    ///    "*"
    ///  ],
    ///  "x-enumDescriptions": {
    ///    "*": "All event types.",
    ///    "balance-transaction.created": "Occurs when a balance transaction is
    /// created to add to your available balance. It currently only supports
    /// positive amounts and non-captured payments.",
    ///    "payment-link.paid": "Occurs when a payment link has been paid.",
    ///    "sales-invoice.canceled": "Occurs when a sales invoice has been
    /// canceled.",
    ///    "sales-invoice.created": "Occurs when a sales invoice has been
    /// created.",
    ///    "sales-invoice.issued": "Occurs when a sales invoice has been
    /// issued.",
    ///    "sales-invoice.paid": "Occurs when a sales invoice has been paid."
    ///  },
    ///  "x-speakeasy-name-override": "webhook-event-types"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WebhookEventTypes {
        #[serde(rename = "payment-link.paid")]
        PaymentLinkPaid,
        #[serde(rename = "balance-transaction.created")]
        BalanceTransactionCreated,
        #[serde(rename = "sales-invoice.created")]
        SalesInvoiceCreated,
        #[serde(rename = "sales-invoice.issued")]
        SalesInvoiceIssued,
        #[serde(rename = "sales-invoice.canceled")]
        SalesInvoiceCanceled,
        #[serde(rename = "sales-invoice.paid")]
        SalesInvoicePaid,
        #[serde(rename = "*")]
        X,
    }

    impl ::std::convert::From<&Self> for WebhookEventTypes {
        fn from(value: &WebhookEventTypes) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WebhookEventTypes {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PaymentLinkPaid => f.write_str("payment-link.paid"),
                Self::BalanceTransactionCreated => f.write_str("balance-transaction.created"),
                Self::SalesInvoiceCreated => f.write_str("sales-invoice.created"),
                Self::SalesInvoiceIssued => f.write_str("sales-invoice.issued"),
                Self::SalesInvoiceCanceled => f.write_str("sales-invoice.canceled"),
                Self::SalesInvoicePaid => f.write_str("sales-invoice.paid"),
                Self::X => f.write_str("*"),
            }
        }
    }

    impl ::std::str::FromStr for WebhookEventTypes {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "payment-link.paid" => Ok(Self::PaymentLinkPaid),
                "balance-transaction.created" => Ok(Self::BalanceTransactionCreated),
                "sales-invoice.created" => Ok(Self::SalesInvoiceCreated),
                "sales-invoice.issued" => Ok(Self::SalesInvoiceIssued),
                "sales-invoice.canceled" => Ok(Self::SalesInvoiceCanceled),
                "sales-invoice.paid" => Ok(Self::SalesInvoicePaid),
                "*" => Ok(Self::X),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WebhookEventTypes {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WebhookEventTypes {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WebhookEventTypes {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The event's type
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The event's type",
    ///  "examples": [
    ///    "payment-link.paid"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "payment-link.paid",
    ///    "balance-transaction.created",
    ///    "sales-invoice.created",
    ///    "sales-invoice.issued",
    ///    "sales-invoice.canceled",
    ///    "sales-invoice.paid",
    ///    "*"
    ///  ],
    ///  "x-enumDescriptions": {
    ///    "*": "All event types.",
    ///    "balance-transaction.created": "Occurs when a balance transaction is
    /// created to add to your available balance. It currently only supports
    /// positive amounts and non-captured payments.",
    ///    "payment-link.paid": "Occurs when a payment link has been paid.",
    ///    "sales-invoice.canceled": "Occurs when a sales invoice has been
    /// canceled.",
    ///    "sales-invoice.created": "Occurs when a sales invoice has been
    /// created.",
    ///    "sales-invoice.issued": "Occurs when a sales invoice has been
    /// issued.",
    ///    "sales-invoice.paid": "Occurs when a sales invoice has been paid."
    ///  },
    ///  "x-speakeasy-name-override": "webhook-event-types",
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WebhookEventTypesResponse {
        #[serde(rename = "payment-link.paid")]
        PaymentLinkPaid,
        #[serde(rename = "balance-transaction.created")]
        BalanceTransactionCreated,
        #[serde(rename = "sales-invoice.created")]
        SalesInvoiceCreated,
        #[serde(rename = "sales-invoice.issued")]
        SalesInvoiceIssued,
        #[serde(rename = "sales-invoice.canceled")]
        SalesInvoiceCanceled,
        #[serde(rename = "sales-invoice.paid")]
        SalesInvoicePaid,
        #[serde(rename = "*")]
        X,
    }

    impl ::std::convert::From<&Self> for WebhookEventTypesResponse {
        fn from(value: &WebhookEventTypesResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WebhookEventTypesResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PaymentLinkPaid => f.write_str("payment-link.paid"),
                Self::BalanceTransactionCreated => f.write_str("balance-transaction.created"),
                Self::SalesInvoiceCreated => f.write_str("sales-invoice.created"),
                Self::SalesInvoiceIssued => f.write_str("sales-invoice.issued"),
                Self::SalesInvoiceCanceled => f.write_str("sales-invoice.canceled"),
                Self::SalesInvoicePaid => f.write_str("sales-invoice.paid"),
                Self::X => f.write_str("*"),
            }
        }
    }

    impl ::std::str::FromStr for WebhookEventTypesResponse {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "payment-link.paid" => Ok(Self::PaymentLinkPaid),
                "balance-transaction.created" => Ok(Self::BalanceTransactionCreated),
                "sales-invoice.created" => Ok(Self::SalesInvoiceCreated),
                "sales-invoice.issued" => Ok(Self::SalesInvoiceIssued),
                "sales-invoice.canceled" => Ok(Self::SalesInvoiceCanceled),
                "sales-invoice.paid" => Ok(Self::SalesInvoicePaid),
                "*" => Ok(Self::X),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WebhookEventTypesResponse {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WebhookEventTypesResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WebhookEventTypesResponse {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The subscription's current status.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The subscription's current status.",
    ///  "examples": [
    ///    "enabled"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "enabled",
    ///    "blocked",
    ///    "disabled",
    ///    "deleted"
    ///  ],
    ///  "x-speakeasy-unknown-values": "allow"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WebhookStatus {
        #[serde(rename = "enabled")]
        Enabled,
        #[serde(rename = "blocked")]
        Blocked,
        #[serde(rename = "disabled")]
        Disabled,
        #[serde(rename = "deleted")]
        Deleted,
    }

    impl ::std::convert::From<&Self> for WebhookStatus {
        fn from(value: &WebhookStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WebhookStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Enabled => f.write_str("enabled"),
                Self::Blocked => f.write_str("blocked"),
                Self::Disabled => f.write_str("disabled"),
                Self::Deleted => f.write_str("deleted"),
            }
        }
    }

    impl ::std::str::FromStr for WebhookStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "enabled" => Ok(Self::Enabled),
                "blocked" => Ok(Self::Blocked),
                "disabled" => Ok(Self::Disabled),
                "deleted" => Ok(Self::Deleted),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WebhookStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WebhookStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WebhookStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The webhook URL where we will send payment status updates to.
    ///
    ///The webhookUrl is optional, but without a webhook you will miss out on
    /// important status changes to your payment.
    ///
    ///The webhookUrl must be reachable from Mollie's point of view, so you
    /// cannot use `localhost`. If you want to use webhook during
    /// development on `localhost`, you must use a tool like ngrok to have the
    /// webhooks delivered to your local machine.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The webhook URL where we will send payment status
    /// updates to.\n\nThe webhookUrl is optional, but without a webhook you
    /// will miss out on important status changes to your payment.\n\nThe
    /// webhookUrl must be reachable from Mollie's point of view, so you cannot
    /// use `localhost`. If you want to use\nwebhook during development on
    /// `localhost`, you must use a tool like ngrok to have the webhooks
    /// delivered to your\nlocal machine.",
    ///  "examples": [
    ///    "https://example.org/webhooks"
    ///  ],
    ///  "type": [
    ///    "string",
    ///    "null"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct WebhookUrl(pub ::std::option::Option<::std::string::String>);
    impl ::std::ops::Deref for WebhookUrl {
        type Target = ::std::option::Option<::std::string::String>;
        fn deref(&self) -> &::std::option::Option<::std::string::String> {
            &self.0
        }
    }

    impl ::std::convert::From<WebhookUrl> for ::std::option::Option<::std::string::String> {
        fn from(value: WebhookUrl) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&WebhookUrl> for WebhookUrl {
        fn from(value: &WebhookUrl) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::option::Option<::std::string::String>> for WebhookUrl {
        fn from(value: ::std::option::Option<::std::string::String>) -> Self {
            Self(value)
        }
    }
}

#[derive(Clone, Debug)]
///Client for Mollie API
///
///Version: 1.0.0
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}

impl Client {
    /// Create a new client.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = ::std::time::Duration::from_secs(15u64);
            reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }

    /// Construct a new client with an existing `reqwest::Client`,
    /// allowing more control over its configuration.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }
}

impl ClientInfo<()> for Client {
    fn api_version() -> &'static str {
        "1.0.0"
    }

    fn baseurl(&self) -> &str {
        self.baseurl.as_str()
    }

    fn client(&self) -> &reqwest::Client {
        &self.client
    }

    fn inner(&self) -> &() {
        &()
    }
}

impl ClientHooks<()> for &Client {}
#[allow(clippy::all)]
impl Client {
    ///List balances
    ///
    ///Retrieve a list of the organization's balances, including the primary
    /// balance.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/balances`
    ///
    ///Arguments:
    /// - `currency`: Optionally only return balances with the given currency.
    ///   For example: `EUR`.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_balances<'a>(
        &'a self,
        currency: Option<&'a str>,
        from: Option<&'a str>,
        limit: Option<::std::num::NonZeroU64>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListBalancesResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/balances", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("currency", &currency))
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_balances",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get balance
    ///
    ///When processing payments with Mollie, we put all pending funds — usually
    ///minus Mollie fees — on a balance. Once you have linked a bank account to
    /// your Mollie account, we can pay out your balance towards this bank
    /// account.
    ///
    ///With the Balances API you can retrieve your current balance. The
    /// response includes two amounts:
    ///
    /// * The *pending amount*. These are payments that have been marked as
    ///   `paid`,
    ///but are not yet available on your balance.
    /// * The *available amount*. This is the amount that you can get paid out
    ///   to
    ///your bank account, or use for refunds.
    ///
    ///With instant payment methods like iDEAL, payments are moved to the
    /// available balance instantly. With slower payment methods, like
    /// credit card for example, it can take a few days before the funds are
    /// available on your balance. These funds will be shown under the *pending
    /// amount* in the meanwhile.
    ///
    ///Sends a `GET` request to `/balances/{id}`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_balance<'a>(
        &'a self,
        id: &'a str,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityBalance>, Error<types::ErrorResponse>> {
        let url = format!("{}/balances/{}", self.baseurl, encode_path(&id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_balance",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get primary balance
    ///
    ///Retrieve the primary balance. This is the balance of your account's
    /// primary currency, where all payments are settled to by default.
    ///
    ///This endpoint is a convenient alias of the [Get balance](get-balance)
    ///endpoint.
    ///
    ///Sends a `GET` request to `/balances/primary`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_primary_balance<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityBalance>, Error<()>> {
        let url = format!("{}/balances/primary", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_primary_balance",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get balance report
    ///
    ///Retrieve a summarized report for all transactions on a given balance
    /// within a given timeframe.
    ///
    ///The API also provides a detailed report on all 'prepayments' for Mollie
    /// fees that were deducted from your balance during the reported
    /// period, ahead of your Mollie invoice.
    ///
    ///The alias `primary` can be used instead of the balance ID to refer to
    /// the organization's primary balance.
    ///
    ///Sends a `GET` request to `/balances/{balanceId}/report`
    ///
    ///Arguments:
    /// - `balance_id`: Provide the ID of the related balance.
    /// - `from`: The start date of the report, in `YYYY-MM-DD` format. The from
    ///   date is
    ///'inclusive', and in Central European Time. This means a report with for
    /// example `from=2024-01-01` will include transactions from 2024-01-01
    /// 0:00:00 CET and onwards.
    /// - `grouping`: You can retrieve reports in two different formats. With
    ///   the `status-balances` format, transactions are grouped
    ///by status (e.g. `pending`, `available`), then by transaction type, and
    /// then by other sub-groupings where available (e.g. payment method).
    ///
    ///With the `transaction-categories` format, transactions are grouped by
    ///transaction type, then by status, and then again by other sub-groupings
    /// where available.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `until`: The end date of the report, in `YYYY-MM-DD` format. The until
    ///   date is 'exclusive', and in Central European Time.
    ///This means a report with for example `until=2024-02-01` will include
    /// transactions up until 2024-01-31 23:59:59 CET.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_balance_report<'a>(
        &'a self,
        balance_id: &'a str,
        from: &'a str,
        grouping: Option<types::GetBalanceReportGrouping>,
        testmode: Option<bool>,
        until: &'a str,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityBalanceReport>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/balances/{}/report",
            self.baseurl,
            encode_path(&balance_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("grouping", &grouping))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .query(&progenitor_client::QueryParam::new("until", &until))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_balance_report",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List balance transactions
    ///
    ///Retrieve a list of all balance transactions. Transactions include for
    ///example payments, refunds, chargebacks, and settlements.
    ///
    ///For an aggregated report of these balance transactions, refer to the
    /// [Get balance report](get-balance-report) endpoint.
    ///
    ///The alias `primary` can be used instead of the balance ID to refer to
    /// the organization's primary balance.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/balances/{balanceId}/transactions`
    ///
    ///Arguments:
    /// - `balance_id`: Provide the ID of the related balance.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_balance_transactions<'a>(
        &'a self,
        balance_id: &'a str,
        from: Option<&'a str>,
        limit: Option<::std::num::NonZeroU64>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListBalanceTransactionsResponse>, Error<types::ErrorResponse>>
    {
        let url = format!(
            "{}/balances/{}/transactions",
            self.baseurl,
            encode_path(&balance_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_balance_transactions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            429u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List settlements
    ///
    ///Retrieve a list of all your settlements.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/settlements`
    ///
    ///Arguments:
    /// - `balance_id`: Provide the token of the balance to filter the
    ///   settlements by. This is
    ///the balance token that the settlement was settled to.
    /// - `currencies`: Provides the currencies to retrieve the settlements. It
    ///   accepts multiple currencies in a comma-separated format.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `month`: Provide the month to query the settlements. Must be used
    ///   combined with `year` parameter
    /// - `year`: Provide the year to query the settlements. Must be used
    ///   combined with `month` parameter
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_settlements<'a>(
        &'a self,
        balance_id: Option<&'a types::BalanceToken>,
        currencies: Option<types::Currencies>,
        from: Option<&'a str>,
        limit: Option<::std::num::NonZeroU64>,
        month: Option<&'a str>,
        year: Option<&'a str>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListSettlementsResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/settlements", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "balanceId",
                &balance_id,
            ))
            .query(&progenitor_client::QueryParam::new(
                "currencies",
                &currencies,
            ))
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("month", &month))
            .query(&progenitor_client::QueryParam::new("year", &year))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_settlements",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get settlement
    ///
    ///Retrieve a single settlement by its ID.
    ///
    ///To lookup settlements by their bank reference, replace the ID in the URL
    /// by a reference. For example: `1234567.2404.03`.
    ///
    ///A settlement represents a transfer of your balance funds to your
    /// external bank account.
    ///
    ///Settlements will typically include a report that details what balance
    /// transactions have taken place between this settlement and the
    /// previous one.
    ///
    ///For more accurate bookkeeping, refer to the [balance
    /// report](get-balance-report) endpoint or the
    /// [balance transactions](list-balance-transactions) endpoint.
    ///
    ///Sends a `GET` request to `/settlements/{id}`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_settlement<'a>(
        &'a self,
        id: &'a str,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntitySettlement>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/settlements/{}",
            self.baseurl,
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_settlement",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get open settlement
    ///
    ///Retrieve the details of the open balance of the organization. This will
    /// return a settlement object representing your organization's balance.
    ///
    ///For a complete reference of the settlement object, refer to the [Get
    /// settlement endpoint](get-settlement) documentation.
    ///
    ///For more accurate bookkeeping, refer to the [balance
    /// report](get-balance-report) endpoint or the
    /// [balance transactions](list-balance-transactions) endpoint.
    ///
    ///Sends a `GET` request to `/settlements/open`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_open_settlement<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntitySettlement>, Error<()>> {
        let url = format!("{}/settlements/open", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_open_settlement",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get next settlement
    ///
    ///Retrieve the details of the current settlement, that has not yet been
    /// paid out.
    ///
    ///For a complete reference of the settlement object, refer to the [Get
    /// settlement endpoint](get-settlement) documentation.
    ///
    ///For more accurate bookkeeping, refer to the [balance
    /// report](get-balance-report) endpoint or the
    /// [balance transactions](list-balance-transactions) endpoint.
    ///
    ///Sends a `GET` request to `/settlements/next`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_next_settlement<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntitySettlement>, Error<()>> {
        let url = format!("{}/settlements/next", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_next_settlement",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List settlement payments
    ///
    ///Retrieve all payments included in the given settlement.
    ///
    ///The response is in the same format as the response of the [List payments
    /// endpoint](list-payments).
    ///
    ///For capture-based payment methods such as Klarna, the payments are not
    /// listed here. Refer to the [List captures endpoint](list-captures)
    /// endpoint instead.
    ///
    ///Sends a `GET` request to `/settlements/{settlementId}/payments`
    ///
    ///Arguments:
    /// - `settlement_id`: Provide the ID of the related settlement.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate
    ///the result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `profile_id`: The identifier referring to the [profile](get-profile)
    ///   you wish to
    ///retrieve the resources for.
    ///
    ///Most API credentials are linked to a single profile. In these cases the
    /// `profileId` can be omitted. For organization-level credentials such
    /// as OAuth access tokens however, the `profileId` parameter is required.
    /// - `sort`: Used for setting the direction of the result set. Defaults to
    ///   descending order, meaning the results are ordered from
    ///newest to oldest.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_settlement_payments<'a>(
        &'a self,
        settlement_id: &'a str,
        from: Option<&'a types::PaymentToken>,
        limit: Option<::std::num::NonZeroU64>,
        profile_id: Option<&'a types::ProfileToken>,
        sort: Option<types::ListSettlementPaymentsSort>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListSettlementPaymentsResponse>, Error<types::ErrorResponse>>
    {
        let url = format!(
            "{}/settlements/{}/payments",
            self.baseurl,
            encode_path(&settlement_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "profileId",
                &profile_id,
            ))
            .query(&progenitor_client::QueryParam::new("sort", &sort))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_settlement_payments",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List settlement captures
    ///
    ///Retrieve all captures included in the given settlement.
    ///
    ///The response is in the same format as the response of the [List captures
    /// endpoint](list-captures).
    ///
    ///Sends a `GET` request to `/settlements/{settlementId}/captures`
    ///
    ///Arguments:
    /// - `settlement_id`: Provide the ID of the related settlement.
    /// - `embed`: This endpoint allows embedding related API items by appending
    ///   the following values via the `embed` query string
    ///parameter.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_settlement_captures<'a>(
        &'a self,
        settlement_id: &'a str,
        embed: Option<&'a str>,
        from: Option<&'a types::CaptureToken>,
        limit: Option<::std::num::NonZeroU64>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListSettlementCapturesResponse>, Error<types::ErrorResponse>>
    {
        let url = format!(
            "{}/settlements/{}/captures",
            self.baseurl,
            encode_path(&settlement_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("embed", &embed))
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_settlement_captures",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List settlement refunds
    ///
    ///Retrieve all refunds 'deducted' from the given settlement.
    ///
    ///The response is in the same format as the response of the [List refunds
    /// endpoint](list-refunds).
    ///
    ///Sends a `GET` request to `/settlements/{settlementId}/refunds`
    ///
    ///Arguments:
    /// - `settlement_id`: Provide the ID of the related settlement.
    /// - `embed`: This endpoint allows embedding related API items by appending
    ///   the following values via the `embed` query string
    ///parameter.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_settlement_refunds<'a>(
        &'a self,
        settlement_id: &'a str,
        embed: Option<&'a str>,
        from: Option<&'a types::RefundToken>,
        limit: Option<::std::num::NonZeroU64>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListSettlementRefundsResponse>, Error<types::ErrorResponse>>
    {
        let url = format!(
            "{}/settlements/{}/refunds",
            self.baseurl,
            encode_path(&settlement_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("embed", &embed))
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_settlement_refunds",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List settlement chargebacks
    ///
    ///Retrieve all chargebacks 'deducted' from the given settlement.
    ///
    ///The response is in the same format as the response of the [List
    /// chargebacks endpoint](list-chargebacks).
    ///
    ///Sends a `GET` request to `/settlements/{settlementId}/chargebacks`
    ///
    ///Arguments:
    /// - `settlement_id`: Provide the ID of the related settlement.
    /// - `embed`: This endpoint allows embedding related API items by appending
    ///   the following values via the `embed` query string
    ///parameter.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_settlement_chargebacks<'a>(
        &'a self,
        settlement_id: &'a str,
        embed: Option<&'a str>,
        from: Option<&'a types::ChargebackToken>,
        limit: Option<::std::num::NonZeroU64>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListSettlementChargebacksResponse>, Error<types::ErrorResponse>>
    {
        let url = format!(
            "{}/settlements/{}/chargebacks",
            self.baseurl,
            encode_path(&settlement_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("embed", &embed))
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_settlement_chargebacks",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List invoices
    ///
    ///Retrieve a list of all your invoices, optionally filtered by year or by
    ///invoice reference.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/invoices`
    ///
    ///Arguments:
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `month`: Filter for invoices of a specific month, for example `01`.
    /// - `reference`: Filter for an invoice with a specific invoice reference,
    ///   for example
    ///`2024.10000`.
    /// - `sort`: Used for setting the direction of the result set. Defaults to
    ///   descending order, meaning the results are ordered from
    ///newest to oldest.
    /// - `year`: Filter for invoices of a specific year, for example `2024`.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_invoices<'a>(
        &'a self,
        from: Option<&'a str>,
        limit: Option<::std::num::NonZeroU64>,
        month: Option<&'a types::ListInvoicesMonth>,
        reference: Option<&'a str>,
        sort: Option<types::ListInvoicesSort>,
        year: Option<&'a str>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListInvoicesResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/invoices", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("month", &month))
            .query(&progenitor_client::QueryParam::new("reference", &reference))
            .query(&progenitor_client::QueryParam::new("sort", &sort))
            .query(&progenitor_client::QueryParam::new("year", &year))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_invoices",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get invoice
    ///
    ///Retrieve a single invoice by its ID.
    ///
    ///If you want to retrieve the details of an invoice by its invoice number,
    ///call the [List invoices](list-invoices) endpoint with the `reference`
    /// parameter.
    ///
    ///Sends a `GET` request to `/invoices/{id}`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_invoice<'a>(
        &'a self,
        id: &'a str,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityInvoice>, Error<types::ErrorResponse>> {
        let url = format!("{}/invoices/{}", self.baseurl, encode_path(&id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_invoice",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List permissions
    ///
    ///Retrieve a list of all permissions available to the current access
    /// token.
    ///
    ///The results are **not** paginated.
    ///
    ///Sends a `GET` request to `/permissions`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_permissions<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListPermissionsResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/permissions", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_permissions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get permission
    ///
    ///Retrieve a single permission by its ID, and see if the permission is
    /// granted to the current access token.
    ///
    ///Sends a `GET` request to `/permissions/{permissionId}`
    ///
    ///Arguments:
    /// - `permission_id`: Provide the ID of the related permission.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_permission<'a>(
        &'a self,
        permission_id: &'a types::PermissionToken,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityPermission>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/permissions/{}",
            self.baseurl,
            encode_path(&permission_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_permission",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get organization
    ///
    ///Retrieve a single organization by its ID.
    ///
    ///You can normally only retrieve the currently authenticated organization
    /// with this endpoint. This is primarily useful for OAuth apps. See
    /// also [Get current organization](get-current-organization).
    ///
    ///If you have a *partner account*', you can retrieve organization details
    /// of connected organizations.
    ///
    ///Sends a `GET` request to `/organizations/{id}`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_organization<'a>(
        &'a self,
        id: &'a str,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityOrganization>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/organizations/{}",
            self.baseurl,
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_organization",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get current organization
    ///
    ///Retrieve the currently authenticated organization. A convenient alias of
    /// the [Get organization](get-organization) endpoint.
    ///
    ///For a complete reference of the organization object, refer to the [Get
    /// organization](get-organization) endpoint documentation.
    ///
    ///Sends a `GET` request to `/organizations/me`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_current_organization<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityOrganization>, Error<()>> {
        let url = format!("{}/organizations/me", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_current_organization",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get partner status
    ///
    ///Retrieve partnership details about the currently authenticated
    /// organization. Only relevant for so-called *partner accounts*.
    ///
    ///Sends a `GET` request to `/organizations/me/partner`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_partner_status<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::GetPartnerStatusResponse>, Error<()>> {
        let url = format!("{}/organizations/me/partner", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_partner_status",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List profiles
    ///
    ///Retrieve a list of all of your profiles.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/profiles`
    ///
    ///Arguments:
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_profiles<'a>(
        &'a self,
        from: Option<&'a str>,
        limit: Option<::std::num::NonZeroU64>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListProfilesResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/profiles", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_profiles",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create profile
    ///
    ///Create a profile to process payments on.
    ///
    ///Profiles are required for payment processing. Normally they are created
    /// via the Mollie dashboard. Alternatively, you can use this endpoint
    /// to automate profile creation.
    ///
    ///Sends a `POST` request to `/profiles`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn create_profile<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        body: &'a types::EntityProfile,
    ) -> Result<ResponseValue<types::EntityProfileResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/profiles", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_profile",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get profile
    ///
    ///Retrieve a single profile by its ID.
    ///
    ///Sends a `GET` request to `/profiles/{id}`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_profile<'a>(
        &'a self,
        id: &'a str,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityProfileResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/profiles/{}", self.baseurl, encode_path(&id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_profile",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            410u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete profile
    ///
    ///Delete a profile. A deleted profile and its related credentials can no
    /// longer be used for accepting payments.
    ///
    ///Sends a `DELETE` request to `/profiles/{id}`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn delete_profile<'a>(
        &'a self,
        id: &'a str,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<::serde_json::Value>, Error<types::ErrorResponse>> {
        let url = format!("{}/profiles/{}", self.baseurl, encode_path(&id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_profile",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            410u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update profile
    ///
    ///Update an existing profile.
    ///
    ///Profiles are required for payment processing. Normally they are created
    /// and updated via the Mollie dashboard. Alternatively, you can use
    /// this endpoint to automate profile management.
    ///
    ///Sends a `PATCH` request to `/profiles/{id}`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn update_profile<'a>(
        &'a self,
        id: &'a str,
        idempotency_key: Option<&'a str>,
        body: &'a types::UpdateProfileBody,
    ) -> Result<ResponseValue<types::EntityProfileResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/profiles/{}", self.baseurl, encode_path(&id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_profile",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            410u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get current profile
    ///
    ///Retrieve the currently authenticated profile. A convenient alias of the
    /// [Get profile](get-profile) endpoint.
    ///
    ///For a complete reference of the profile object, refer to the [Get
    /// profile](get-profile) endpoint documentation.
    ///
    ///Sends a `GET` request to `/profiles/me`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_current_profile<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityProfileResponse>, Error<()>> {
        let url = format!("{}/profiles/me", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_current_profile",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get onboarding status
    ///
    ///Retrieve the onboarding status of the currently authenticated
    /// organization.
    ///
    ///Sends a `GET` request to `/onboarding/me`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_onboarding_status<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityOnboardingStatus>, Error<()>> {
        let url = format!("{}/onboarding/me", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_onboarding_status",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Submit onboarding data
    ///
    ///**⚠️ We no longer recommend implementing this endpoint. Please refer to
    /// the Client Links API instead to kick off the onboarding process for
    /// your merchants.**
    ///
    ///Submit data that will be prefilled in the merchant's onboarding. The
    /// data you submit will only be processed when the onboarding status is
    /// `needs-data`. Information that the merchant has entered in their
    /// dashboard will not be overwritten.
    ///
    ///Sends a `POST` request to `/onboarding/me`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn submit_onboarding_data<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        body: &'a types::SubmitOnboardingDataBody,
    ) -> Result<ResponseValue<::serde_json::Value>, Error<()>> {
        let url = format!("{}/onboarding/me", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "submit_onboarding_data",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List capabilities
    ///
    /// > 🚧 Beta feature
    ///>
    /// > This feature is currently in beta testing, and the final specification
    /// > may still change.
    ///
    ///Retrieve a list of capabilities for an organization.
    ///
    ///This API provides detailed insights into the specific requirements and
    /// status of each client's onboarding journey.
    ///
    ///Capabilities are at the organization level, indicating if the
    /// organization can perform a given capability.
    ///
    ///For payments, regardless them being at the profile level, the capability
    /// is listed at the organization level. This means that if at least one
    /// of the clients's profiles can receive payments, the payments
    /// capability is enabled, communicating that the organization can indeed
    /// receive payments.
    ///
    ///Sends a `GET` request to `/capabilities`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_capabilities<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListCapabilitiesResponse>, Error<()>> {
        let url = format!("{}/capabilities", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_capabilities",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List clients
    ///
    ///Retrieve a list of all clients linked to your account.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/clients`
    ///
    ///Arguments:
    /// - `embed`: This endpoint allows embedding related API items by appending
    ///   the following values via the `embed` query string
    ///parameter.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_clients<'a>(
        &'a self,
        embed: Option<&'a str>,
        from: Option<&'a str>,
        limit: Option<::std::num::NonZeroU64>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListClientsResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/clients", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("embed", &embed))
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_clients",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get client
    ///
    ///Retrieve a single client by its ID.
    ///
    ///Sends a `GET` request to `/clients/{id}`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `embed`: This endpoint allows embedding related API items by appending
    ///   the following values via the `embed` query string
    ///parameter.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_client<'a>(
        &'a self,
        id: &'a str,
        embed: Option<&'a str>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::GetClientResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/clients/{}", self.baseurl, encode_path(&id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("embed", &embed))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_client",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create client link
    ///
    ///Link a new or existing organization to your OAuth application, in effect
    /// creating a new client. The response contains a `clientLink` where
    /// you should redirect your customer to.
    ///
    ///## Redirecting the Customer
    ///
    ///The `clientLink` URL behaves similarly to a standard OAuth authorization
    /// URL. Therefore, after receiving the `clientLink` URL in the API
    /// response, you need to **append the following query parameters** *before*
    /// redirecting the customer:
    ///
    /// * `client_id` _string (required)_
    ///
    ///  The client ID you received when you registered your OAuth app. The ID
    /// starts with `app_`. For example:  `app_abc123qwerty`.
    ///
    /// * `state` _string (required)_
    ///
    ///  A random string **generated by your app** to prevent CSRF attacks. This
    /// will be reflected in the `state` query  parameter when the user
    /// returns to the `redirect_uri` after authorizing your app.
    ///
    /// * `scope` _string (required)_
    ///
    ///  A space-separated list of permissions ('scopes') your app requires. See
    /// the  [permissions list](https://docs.mollie.com/docs/connect-permissions) for more information about the available
    ///  scopes.
    ///
    ///  We recommend at least : `onboarding.read onboarding.write`
    ///
    /// * `approval_prompt` _string_
    ///
    ///  Can be set to `force` to force showing the consent screen to the
    /// merchant, *even when it is not necessary*. If you  force an approval
    /// prompt and the user creates a new authorization, previously active
    /// authorizations will be  revoked.
    ///
    ///  Possible values: `auto` `force` (default: `auto`)
    ///
    ///### Example of a Complete Redirect URL
    ///
    ///After adding the above url parameter your URL will look something like
    /// this and you can redirect your client to this page:
    ///
    ///```
    /// https://my.mollie.com/dashboard/client-link/{id}?client_id={your_client_id}&state={unique_state}&scope=onboarding.read%20onboarding.write
    /// ```
    ///
    ///## Error Handling
    ///
    ///Error handling is also dealt with similar to the [Authorize](https://docs.mollie.com/reference/authorize) endpoint:
    ///the customer is redirected back to your app's redirect URL with the
    /// `error` and `error_description` parameters added to the URL.
    ///
    /// > 🚧
    ///>
    /// > A client link must be used within 30 days of creation. After that
    /// > period, it will expire and you will need to create a new client link.
    ///
    ///Sends a `POST` request to `/client-links`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn create_client_link<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        body: &'a types::EntityClientLink,
    ) -> Result<ResponseValue<types::EntityClientLinkResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/client-links", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_client_link",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List all webhooks
    ///
    ///Returns a paginated list of your webhooks. If no webhook endpoints are
    /// available, the resulting array will be empty. This request should never
    /// throw an error.
    ///
    ///Sends a `GET` request to `/webhooks`
    ///
    ///Arguments:
    /// - `event_types`: Used to filter out only the webhooks that are
    ///   subscribed to certain types of events.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `sort`: Used for setting the direction of the result set. Defaults to
    ///   descending order, meaning the results are ordered from
    ///newest to oldest.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_webhooks<'a>(
        &'a self,
        event_types: Option<types::WebhookEventTypes>,
        from: Option<&'a str>,
        limit: Option<::std::num::NonZeroU64>,
        sort: Option<types::ListWebhooksSort>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListWebhooksResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/webhooks", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "eventTypes",
                &event_types,
            ))
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("sort", &sort))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_webhooks",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create a webhook
    ///
    ///A webhook must have a name, an url and a list of event types. You can
    /// also create webhooks in the webhooks settings section of the Dashboard.
    ///
    ///Sends a `POST` request to `/webhooks`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn create_webhook<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        body: &'a types::CreateWebhookBody,
    ) -> Result<ResponseValue<types::CreateWebhook>, Error<types::ErrorResponse>> {
        let url = format!("{}/webhooks", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_webhook",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get a webhook
    ///
    ///Retrieve a single webhook object by its ID.
    ///
    ///Sends a `GET` request to `/webhooks/{id}`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_webhook<'a>(
        &'a self,
        id: &'a str,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityWebhook>, Error<types::ErrorResponse>> {
        let url = format!("{}/webhooks/{}", self.baseurl, encode_path(&id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_webhook",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete a webhook
    ///
    ///Delete a single webhook object by its webhook ID.
    ///
    ///Sends a `DELETE` request to `/webhooks/{id}`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn delete_webhook<'a>(
        &'a self,
        id: &'a str,
        idempotency_key: Option<&'a str>,
        body: &'a types::DeleteWebhookBody,
    ) -> Result<ResponseValue<::serde_json::Value>, Error<types::ErrorResponse>> {
        let url = format!("{}/webhooks/{}", self.baseurl, encode_path(&id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_webhook",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update a webhook
    ///
    ///Updates the webhook. You may edit the name, url and the list of
    /// subscribed event types.
    ///
    ///Sends a `PATCH` request to `/webhooks/{id}`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn update_webhook<'a>(
        &'a self,
        id: &'a str,
        idempotency_key: Option<&'a str>,
        body: &'a types::UpdateWebhookBody,
    ) -> Result<ResponseValue<types::EntityWebhook>, Error<types::ErrorResponse>> {
        let url = format!("{}/webhooks/{}", self.baseurl, encode_path(&id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_webhook",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Test a webhook
    ///
    ///Sends a test event to the webhook to verify the endpoint is working as
    /// expected.
    ///
    ///Sends a `POST` request to `/webhooks/{id}/ping`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn test_webhook<'a>(
        &'a self,
        id: &'a str,
        idempotency_key: Option<&'a str>,
        body: &'a types::TestWebhookBody,
    ) -> Result<ResponseValue<::serde_json::Value>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/webhooks/{}/ping",
            self.baseurl,
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "test_webhook",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get a Webhook Event
    ///
    ///Retrieve a single webhook event object by its event ID.
    ///
    ///Sends a `GET` request to `/events/{id}`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_webhook_event<'a>(
        &'a self,
        id: &'a str,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityWebhookEvent>, Error<types::ErrorResponse>> {
        let url = format!("{}/events/{}", self.baseurl, encode_path(&id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_webhook_event",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List all Connect balance transfers
    ///
    ///Returns a paginated list of balance transfers associated with your
    /// organization. These may be a balance transfer that was received or sent
    /// from your balance, or a balance transfer that you initiated on behalf of
    /// your clients. If no balance transfers are available, the resulting array
    /// will be empty. This request should never throw an error.
    ///
    ///Sends a `GET` request to `/connect/balance-transfers`
    ///
    ///Arguments:
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `sort`: Used for setting the direction of the result set. Defaults to
    ///   descending order, meaning the results are ordered from
    ///newest to oldest.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_connect_balance_transfers<'a>(
        &'a self,
        from: Option<&'a str>,
        limit: Option<::std::num::NonZeroU64>,
        sort: Option<types::ListConnectBalanceTransfersSort>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::ListConnectBalanceTransfersResponse>,
        Error<types::ErrorResponse>,
    > {
        let url = format!("{}/connect/balance-transfers", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("sort", &sort))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_connect_balance_transfers",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create a Connect balance transfer
    ///
    ///This API endpoint allows you to create a balance transfer from your
    /// organization's balance to a connected organization's balance, or vice
    /// versa. You can also create a balance transfer between two connected
    /// organizations. To create a balance transfer, you must be
    /// authenticated as the source organization, and the destination
    /// organization must be a connected organization that has authorized
    /// the `balance-transfers.write` scope for your organization.
    ///
    ///Sends a `POST` request to `/connect/balance-transfers`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn create_connect_balance_transfer<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        body: &'a types::EntityBalanceTransfer,
    ) -> Result<ResponseValue<types::EntityBalanceTransferResponse>, Error<types::ErrorResponse>>
    {
        let url = format!("{}/connect/balance-transfers", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_connect_balance_transfer",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get a Connect balance transfer
    ///
    ///Retrieve a single Connect balance transfer object by its ID.
    ///
    ///Sends a `GET` request to `/connect/balance-transfers/{id}`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_connect_balance_transfer<'a>(
        &'a self,
        id: &'a str,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityBalanceTransferResponse>, Error<types::ErrorResponse>>
    {
        let url = format!(
            "{}/connect/balance-transfers/{}",
            self.baseurl,
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_connect_balance_transfer",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List payments
    ///
    ///Retrieve all payments created with the current website profile.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/payments`
    ///
    ///Arguments:
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate
    ///the result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `profile_id`: The identifier referring to the [profile](get-profile)
    ///   you wish to
    ///retrieve the resources for.
    ///
    ///Most API credentials are linked to a single profile. In these cases the
    /// `profileId` can be omitted. For organization-level credentials such
    /// as OAuth access tokens however, the `profileId` parameter is required.
    /// - `sort`: Used for setting the direction of the result set. Defaults to
    ///   descending order, meaning the results are ordered from
    ///newest to oldest.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_payments<'a>(
        &'a self,
        from: Option<&'a types::PaymentToken>,
        limit: Option<::std::num::NonZeroU64>,
        profile_id: Option<&'a types::ProfileToken>,
        sort: Option<types::ListPaymentsSort>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListPaymentsResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/payments", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "profileId",
                &profile_id,
            ))
            .query(&progenitor_client::QueryParam::new("sort", &sort))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_payments",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create payment
    ///
    ///Payment creation is elemental to the Mollie API: this is where most
    /// payment implementations start off.
    ///
    ///Once you have created a payment, you should redirect your customer to
    /// the URL in the `_links.checkout` property from the response.
    ///
    ///To wrap your head around the payment process, an explanation and flow
    /// charts can be found in the 'Accepting payments' guide.
    ///
    ///If you specify the `method` parameter when creating a payment, optional
    ///additional parameters may be available for the payment method that are
    /// not listed below. Please refer to the guide on [method-specific
    /// parameters](extra-payment-parameters).
    ///
    ///Sends a `POST` request to `/payments`
    ///
    ///Arguments:
    /// - `include`: This endpoint allows you to include additional information
    ///   via the `include` query string parameter.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn create_payment<'a>(
        &'a self,
        include: Option<&'a str>,
        idempotency_key: Option<&'a str>,
        body: &'a types::PaymentRequest,
    ) -> Result<ResponseValue<types::PaymentResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/payments", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&progenitor_client::QueryParam::new("include", &include))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_payment",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            503u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get payment
    ///
    ///Retrieve a single payment object by its payment ID.
    ///
    ///Sends a `GET` request to `/payments/{paymentId}`
    ///
    ///Arguments:
    /// - `payment_id`: Provide the ID of the related payment.
    /// - `embed`: This endpoint allows embedding related API items by appending
    ///   the following values via the `embed` query string
    ///parameter.
    /// - `include`: This endpoint allows you to include additional information
    ///   via the `include` query string parameter.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_payment<'a>(
        &'a self,
        payment_id: &'a types::PaymentToken,
        embed: Option<&'a str>,
        include: Option<&'a str>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::PaymentResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payments/{}",
            self.baseurl,
            encode_path(&payment_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("embed", &embed))
            .query(&progenitor_client::QueryParam::new("include", &include))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_payment",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Cancel payment
    ///
    ///Depending on the payment method, you may be able to cancel a payment for
    /// a certain amount of time — usually until the next business day or as
    /// long as the payment status is open.
    ///
    ///Payments may also be canceled manually from the Mollie Dashboard.
    ///
    ///The `isCancelable` property on the [Payment object](get-payment) will
    /// indicate if the payment can be canceled.
    ///
    ///Sends a `DELETE` request to `/payments/{paymentId}`
    ///
    ///Arguments:
    /// - `payment_id`: Provide the ID of the related payment.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn cancel_payment<'a>(
        &'a self,
        payment_id: &'a types::PaymentToken,
        idempotency_key: Option<&'a str>,
        body: &'a types::CancelPaymentBody,
    ) -> Result<ResponseValue<types::PaymentResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payments/{}",
            self.baseurl,
            encode_path(&payment_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "cancel_payment",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update payment
    ///
    ///Certain details of an existing payment can be updated.
    ///
    ///Updating the payment details will not result in a webhook call.
    ///
    ///Sends a `PATCH` request to `/payments/{paymentId}`
    ///
    ///Arguments:
    /// - `payment_id`: Provide the ID of the related payment.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn update_payment<'a>(
        &'a self,
        payment_id: &'a types::PaymentToken,
        idempotency_key: Option<&'a str>,
        body: &'a types::UpdatePaymentBody,
    ) -> Result<ResponseValue<types::PaymentResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payments/{}",
            self.baseurl,
            encode_path(&payment_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_payment",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Release payment authorization
    ///
    ///Releases the full remaining authorized amount. Call this endpoint when
    /// you will not be making any additional captures. Payment
    /// authorizations may also be released manually from the Mollie Dashboard.
    ///
    ///Mollie will do its best to process release requests, but it is not
    /// guaranteed that it will succeed. It is up to the issuing bank if and
    /// when the hold will be released.
    ///
    ///If the request does succeed, the payment status will change to
    /// `canceled` for payments without captures. If there is a successful
    /// capture, the payment will transition to `paid`.
    ///
    ///Sends a `POST` request to `/payments/{paymentId}/release-authorization`
    ///
    ///Arguments:
    /// - `payment_id`: Provide the ID of the related payment.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn release_authorization<'a>(
        &'a self,
        payment_id: &'a types::PaymentToken,
        idempotency_key: Option<&'a str>,
        body: &'a types::ReleaseAuthorizationBody,
    ) -> Result<ResponseValue<::serde_json::Value>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payments/{}/release-authorization",
            self.baseurl,
            encode_path(&payment_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "release_authorization",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List payment methods
    ///
    ///Retrieve all enabled payment methods. The results of this endpoint are
    ///**not** paginated — unlike most other list endpoints in our API.
    ///
    ///For test mode, all pending and enabled payment methods are returned. If
    /// no payment methods are requested yet, the most popular payment
    /// methods are returned in the test mode. For live mode, only fully
    /// enabled payment methods are returned.
    ///
    ///Payment methods can be requested and enabled via the Mollie Dashboard,
    /// or via the [Enable payment method endpoint](enable-method) of the
    /// Profiles API.
    ///
    ///The list can optionally be filtered using a number of parameters
    /// described below.
    ///
    ///By default, only payment methods for the Euro currency are returned. If
    /// you wish to retrieve payment methods which exclusively support other
    /// currencies (e.g. Twint), you need to use the `amount` parameters.
    ///
    ///Sends a `GET` request to `/methods`
    ///
    ///Arguments:
    /// - `amount`: If supplied, only payment methods that support the amount
    ///   and currency
    ///are returned.
    ///
    ///Example: `/v2/methods?amount[value]=100.00&amount[currency]=USD`
    /// - `billing_country`: The country taken from your customer's billing
    ///   address in ISO 3166-1 alpha-2 format. This parameter can be used
    ///to check whether your customer is eligible for certain payment methods,
    /// for example for Klarna.
    ///
    ///Example: `/v2/methods?resource=orders&billingCountry=DE`
    /// - `include`: This endpoint allows you to include additional information
    ///   via the `include` query string parameter.
    /// - `include_wallets`: A comma-separated list of the wallets you support
    ///   in your checkout. Wallets often require wallet specific code
    ///to check if they are available on the shoppers device, hence the need to
    /// indicate your support.
    /// - `locale`: Response language
    /// - `order_line_categories`: A comma-separated list of the line categories
    ///   you support in your checkout.
    ///
    ///Example: `/v2/methods?orderLineCategories=eco,meal`
    /// - `profile_id`: The identifier referring to the [profile](get-profile)
    ///   you wish to
    ///retrieve the resources for.
    ///
    ///Most API credentials are linked to a single profile. In these cases the
    /// `profileId` can be omitted. For organization-level credentials such
    /// as OAuth access tokens however, the `profileId` parameter is required.
    /// - `resource`: **⚠️ We no longer recommend using the Orders API. Please
    ///   refer to the [Payments API](payments-api) instead.**
    ///
    ///Indicate if you will use the result for the [Create order](create-order)
    ///or the [Create payment](create-payment) endpoint.
    ///
    ///When passing the value `orders`, the result will include payment methods
    ///that are only available for payments created via the Orders API.
    /// - `sequence_type`: Set this parameter to `first` to only return the
    ///   enabled methods that
    ///can be used for the first payment of a recurring sequence.
    ///
    ///Set it to `recurring` to only return enabled methods that can be used
    /// for recurring payments or subscriptions.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_methods<'a>(
        &'a self,
        amount: Option<&'a types::Amount>,
        billing_country: Option<&'a str>,
        include: Option<&'a str>,
        include_wallets: Option<types::ListMethodsIncludeWallets>,
        locale: Option<types::ListMethodsLocale>,
        order_line_categories: Option<types::LineCategories>,
        profile_id: Option<&'a types::ProfileToken>,
        resource: Option<types::ListMethodsResource>,
        sequence_type: Option<types::SequenceType>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListMethodsResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/methods", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("amount", &amount))
            .query(&progenitor_client::QueryParam::new(
                "billingCountry",
                &billing_country,
            ))
            .query(&progenitor_client::QueryParam::new("include", &include))
            .query(&progenitor_client::QueryParam::new(
                "includeWallets",
                &include_wallets,
            ))
            .query(&progenitor_client::QueryParam::new("locale", &locale))
            .query(&progenitor_client::QueryParam::new(
                "orderLineCategories",
                &order_line_categories,
            ))
            .query(&progenitor_client::QueryParam::new(
                "profileId",
                &profile_id,
            ))
            .query(&progenitor_client::QueryParam::new("resource", &resource))
            .query(&progenitor_client::QueryParam::new(
                "sequenceType",
                &sequence_type,
            ))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_methods",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List all payment methods
    ///
    ///Retrieve all payment methods that Mollie offers, regardless of the
    /// eligibility of the organization for the specific method. The results
    /// of this endpoint are **not** paginated — unlike most other list
    /// endpoints in our API.
    ///
    ///The list can optionally be filtered using a number of parameters
    /// described below.
    ///
    ///Sends a `GET` request to `/methods/all`
    ///
    ///Arguments:
    /// - `amount`: If supplied, only payment methods that support the amount
    ///   and currency
    ///are returned.
    ///
    ///Example: `/v2/methods/all?amount[value]=100.00&amount[currency]=USD`
    /// - `include`: This endpoint allows you to include additional information
    ///   via the `include` query string parameter.
    /// - `locale`: Response language
    /// - `profile_id`: The identifier referring to the [profile](get-profile)
    ///   you wish to
    ///retrieve the resources for.
    ///
    ///Most API credentials are linked to a single profile. In these cases the
    /// `profileId` can be omitted. For organization-level credentials such
    /// as OAuth access tokens however, the `profileId` parameter is required.
    /// - `sequence_type`: Set this parameter to `first` to only return the
    ///   methods that
    ///can be used for the first payment of a recurring sequence.
    ///
    ///Set it to `recurring` to only return methods that can be used for
    /// recurring payments or subscriptions.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_all_methods<'a>(
        &'a self,
        amount: Option<&'a types::Amount>,
        include: Option<&'a str>,
        locale: Option<types::ListAllMethodsLocale>,
        profile_id: Option<&'a types::ProfileToken>,
        sequence_type: Option<types::SequenceType>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListAllMethodsResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/methods/all", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("amount", &amount))
            .query(&progenitor_client::QueryParam::new("include", &include))
            .query(&progenitor_client::QueryParam::new("locale", &locale))
            .query(&progenitor_client::QueryParam::new(
                "profileId",
                &profile_id,
            ))
            .query(&progenitor_client::QueryParam::new(
                "sequenceType",
                &sequence_type,
            ))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_all_methods",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get payment method
    ///
    ///Retrieve a single payment method by its ID.
    ///
    ///If a method is not available on this profile, a `404 Not Found` response
    /// is returned. If the method is available but not enabled yet, a
    /// status `403 Forbidden` is returned. You can enable payments methods
    /// via the [Enable payment method endpoint](enable-method) of the Profiles
    /// API, or via the Mollie Dashboard.
    ///
    ///If you do not know the method's ID, you can use the [methods list
    ///endpoint](list-methods) to retrieve all payment methods that are
    /// available.
    ///
    ///Additionally, it is possible to check if wallet methods such as Apple
    /// Pay are enabled by passing the wallet ID (`applepay`) as the method
    /// ID.
    ///
    ///Sends a `GET` request to `/methods/{id}`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `currency`: If provided, the `minimumAmount` and `maximumAmount` will
    ///   be converted
    ///to the given currency. An error is returned if the currency is not
    /// supported by the payment method.
    /// - `include`: This endpoint allows you to include additional information
    ///   via the `include` query string parameter.
    /// - `locale`: Response language
    /// - `profile_id`: The identifier referring to the [profile](get-profile)
    ///   you wish to
    ///retrieve the resources for.
    ///
    ///Most API credentials are linked to a single profile. In these cases the
    /// `profileId` can be omitted. For organization-level credentials such
    /// as OAuth access tokens however, the `profileId` parameter is required.
    /// - `sequence_type`: Set this parameter to `first` to only return the
    ///   methods that
    ///can be used for the first payment of a recurring sequence.
    ///
    ///Set it to `recurring` to only return methods that can be used for
    /// recurring payments or subscriptions.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_method<'a>(
        &'a self,
        id: &'a str,
        currency: Option<&'a str>,
        include: Option<&'a str>,
        locale: Option<types::GetMethodLocale>,
        profile_id: Option<&'a types::ProfileToken>,
        sequence_type: Option<types::SequenceType>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityMethod>, Error<types::ErrorResponse>> {
        let url = format!("{}/methods/{}", self.baseurl, encode_path(&id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("currency", &currency))
            .query(&progenitor_client::QueryParam::new("include", &include))
            .query(&progenitor_client::QueryParam::new("locale", &locale))
            .query(&progenitor_client::QueryParam::new(
                "profileId",
                &profile_id,
            ))
            .query(&progenitor_client::QueryParam::new(
                "sequenceType",
                &sequence_type,
            ))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_method",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Enable payment method
    ///
    ///Enable a payment method on a specific profile.
    ///
    ///When using a profile-specific API credential, the alias `me` can be used
    ///instead of the profile ID to refer to the current profile.
    ///
    ///Some payment methods require extra steps in order to be activated. In
    /// cases where a step at the payment method provider needs to be
    /// completed first, the status will be set to `pending-external` and
    /// the response will contain a link to complete the activation at the
    /// provider.
    ///
    ///To enable voucher or gift card issuers, refer to the [Enable payment
    /// method issuer](enable-method-issuer) endpoint.
    ///
    ///Sends a `POST` request to `/profiles/{profileId}/methods/{id}`
    ///
    ///Arguments:
    /// - `profile_id`: Provide the ID of the related profile.
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn enable_method<'a>(
        &'a self,
        profile_id: &'a types::EnableMethodProfileId,
        id: &'a str,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityMethod>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/profiles/{}/methods/{}",
            self.baseurl,
            encode_path(&profile_id.to_string()),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "enable_method",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Disable payment method
    ///
    ///Disable a payment method on a specific profile.
    ///
    ///When using a profile-specific API credential, the alias `me` can be used
    ///instead of the profile ID to refer to the current profile.
    ///
    ///Sends a `DELETE` request to `/profiles/{profileId}/methods/{id}`
    ///
    ///Arguments:
    /// - `profile_id`: Provide the ID of the related profile.
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn disable_method<'a>(
        &'a self,
        profile_id: &'a types::DisableMethodProfileId,
        id: &'a str,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<::serde_json::Value>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/profiles/{}/methods/{}",
            self.baseurl,
            encode_path(&profile_id.to_string()),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disable_method",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Enable payment method issuer
    ///
    ///Enable an issuer for a payment method on a specific profile.
    ///
    ///Currently only the payment methods `voucher` and `giftcard` are
    /// supported.
    ///
    ///When using a profile-specific API credential, the alias `me` can be used
    /// instead of the profile ID to refer to the current profile.
    ///
    ///Sends a `POST` request to
    /// `/profiles/{profileId}/methods/{methodId}/issuers/{id}`
    ///
    ///Arguments:
    /// - `profile_id`: Provide the ID of the related profile.
    /// - `method_id`: Provide the ID of the related payment method.
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn enable_method_issuer<'a>(
        &'a self,
        profile_id: &'a types::EnableMethodIssuerProfileId,
        method_id: &'a str,
        id: &'a str,
        idempotency_key: Option<&'a str>,
        body: &'a types::EnableMethodIssuerBody,
    ) -> Result<ResponseValue<types::EnableMethodIssuerResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/profiles/{}/methods/{}/issuers/{}",
            self.baseurl,
            encode_path(&profile_id.to_string()),
            encode_path(&method_id.to_string()),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "enable_method_issuer",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Disable payment method issuer
    ///
    ///Disable an issuer for a payment method on a specific profile.
    ///
    ///Currently only the payment methods `voucher` and `giftcard` are
    /// supported.
    ///
    ///When using a profile-specific API credential, the alias `me` can be used
    /// instead of the profile ID to refer to the current profile.
    ///
    ///Sends a `DELETE` request to
    /// `/profiles/{profileId}/methods/{methodId}/issuers/{id}`
    ///
    ///Arguments:
    /// - `profile_id`: Provide the ID of the related profile.
    /// - `method_id`: Provide the ID of the related payment method.
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn disable_method_issuer<'a>(
        &'a self,
        profile_id: &'a types::DisableMethodIssuerProfileId,
        method_id: &'a str,
        id: &'a str,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<::serde_json::Value>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/profiles/{}/methods/{}/issuers/{}",
            self.baseurl,
            encode_path(&profile_id.to_string()),
            encode_path(&method_id.to_string()),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disable_method_issuer",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List payment refunds
    ///
    ///Retrieve a list of all refunds created for a specific payment.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/payments/{paymentId}/refunds`
    ///
    ///Arguments:
    /// - `payment_id`: Provide the ID of the related payment.
    /// - `embed`: This endpoint allows embedding related API items by appending
    ///   the following values via the `embed` query string
    ///parameter.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_refunds<'a>(
        &'a self,
        payment_id: &'a types::PaymentToken,
        embed: Option<&'a str>,
        from: Option<&'a types::RefundToken>,
        limit: Option<::std::num::NonZeroU64>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListRefundsResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payments/{}/refunds",
            self.baseurl,
            encode_path(&payment_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("embed", &embed))
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_refunds",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create payment refund
    ///
    ///Creates a refund for a specific payment. The refunded amount is credited
    /// to your customer usually either via a bank transfer or by refunding
    /// the amount to your customer's credit card.
    ///
    ///Sends a `POST` request to `/payments/{paymentId}/refunds`
    ///
    ///Arguments:
    /// - `payment_id`: Provide the ID of the related payment.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn create_refund<'a>(
        &'a self,
        payment_id: &'a types::PaymentToken,
        idempotency_key: Option<&'a str>,
        body: &'a types::RefundRequest,
    ) -> Result<ResponseValue<types::EntityRefundResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payments/{}/refunds",
            self.baseurl,
            encode_path(&payment_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_refund",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            409u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get payment refund
    ///
    ///Retrieve a single payment refund by its ID and the ID of its parent
    /// payment.
    ///
    ///Sends a `GET` request to `/payments/{paymentId}/refunds/{refundId}`
    ///
    ///Arguments:
    /// - `payment_id`: Provide the ID of the related payment.
    /// - `refund_id`: Provide the ID of the related refund.
    /// - `embed`: This endpoint allows embedding related API items by appending
    ///   the following values via the `embed` query string
    ///parameter.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_refund<'a>(
        &'a self,
        payment_id: &'a types::PaymentToken,
        refund_id: &'a types::RefundToken,
        embed: Option<&'a str>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityRefundResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payments/{}/refunds/{}",
            self.baseurl,
            encode_path(&payment_id.to_string()),
            encode_path(&refund_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("embed", &embed))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_refund",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Cancel payment refund
    ///
    ///Refunds will be executed with a delay of two hours. Until that time,
    /// refunds may be canceled manually via the Mollie Dashboard, or by
    /// using this endpoint.
    ///
    ///A refund can only be canceled while its `status` field is either
    /// `queued` or `pending`. See the [Get refund endpoint](get-refund) for
    /// more information.
    ///
    ///Sends a `DELETE` request to `/payments/{paymentId}/refunds/{refundId}`
    ///
    ///Arguments:
    /// - `payment_id`: Provide the ID of the related payment.
    /// - `refund_id`: Provide the ID of the related refund.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn cancel_refund<'a>(
        &'a self,
        payment_id: &'a types::PaymentToken,
        refund_id: &'a types::RefundToken,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<::serde_json::Value>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payments/{}/refunds/{}",
            self.baseurl,
            encode_path(&payment_id.to_string()),
            encode_path(&refund_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "cancel_refund",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List all refunds
    ///
    ///Retrieve a list of all of your refunds.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/refunds`
    ///
    ///Arguments:
    /// - `embed`: This endpoint allows embedding related API items by appending
    ///   the following values via the `embed` query string
    ///parameter.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `profile_id`: The identifier referring to the [profile](get-profile)
    ///   you wish to
    ///retrieve the resources for.
    ///
    ///Most API credentials are linked to a single profile. In these cases the
    /// `profileId` can be omitted. For organization-level credentials such
    /// as OAuth access tokens however, the `profileId` parameter is required.
    /// - `sort`: Used for setting the direction of the result set. Defaults to
    ///   descending order, meaning the results are ordered from
    ///newest to oldest.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_all_refunds<'a>(
        &'a self,
        embed: Option<&'a str>,
        from: Option<&'a types::RefundToken>,
        limit: Option<::std::num::NonZeroU64>,
        profile_id: Option<&'a types::ProfileToken>,
        sort: Option<types::ListAllRefundsSort>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListAllRefundsResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/refunds", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("embed", &embed))
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "profileId",
                &profile_id,
            ))
            .query(&progenitor_client::QueryParam::new("sort", &sort))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_all_refunds",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List payment chargebacks
    ///
    ///Retrieve the chargebacks initiated for a specific payment.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/payments/{paymentId}/chargebacks`
    ///
    ///Arguments:
    /// - `payment_id`: Provide the ID of the related payment.
    /// - `embed`: This endpoint allows embedding related API items by appending
    ///   the following values via the `embed` query string
    ///parameter.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_chargebacks<'a>(
        &'a self,
        payment_id: &'a types::PaymentToken,
        embed: Option<&'a str>,
        from: Option<&'a types::ChargebackToken>,
        limit: Option<::std::num::NonZeroU64>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListChargebacksResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payments/{}/chargebacks",
            self.baseurl,
            encode_path(&payment_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("embed", &embed))
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_chargebacks",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get payment chargeback
    ///
    ///Retrieve a single payment chargeback by its ID and the ID of its parent
    /// payment.
    ///
    ///Sends a `GET` request to
    /// `/payments/{paymentId}/chargebacks/{chargebackId}`
    ///
    ///Arguments:
    /// - `payment_id`: Provide the ID of the related payment.
    /// - `chargeback_id`: Provide the ID of the related chargeback.
    /// - `embed`: This endpoint allows embedding related API items by appending
    ///   the following values via the `embed` query string
    ///parameter.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_chargeback<'a>(
        &'a self,
        payment_id: &'a types::PaymentToken,
        chargeback_id: &'a types::ChargebackToken,
        embed: Option<&'a str>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityChargeback>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payments/{}/chargebacks/{}",
            self.baseurl,
            encode_path(&payment_id.to_string()),
            encode_path(&chargeback_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("embed", &embed))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_chargeback",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List all chargebacks
    ///
    ///Retrieve all chargebacks initiated for all your payments.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/chargebacks`
    ///
    ///Arguments:
    /// - `embed`: This endpoint allows embedding related API items by appending
    ///   the following values via the `embed` query string
    ///parameter.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `profile_id`: The identifier referring to the [profile](get-profile)
    ///   you wish to
    ///retrieve chargebacks for.
    ///
    ///Most API credentials are linked to a single profile. In these cases the
    ///`profileId` is already implied.
    ///
    ///To retrieve all chargebacks across the organization, use an
    ///organization-level API credential and omit the `profileId` parameter.
    /// - `sort`: Used for setting the direction of the result set. Defaults to
    ///   descending order, meaning the results are ordered from
    ///newest to oldest.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_all_chargebacks<'a>(
        &'a self,
        embed: Option<&'a str>,
        from: Option<&'a types::ChargebackToken>,
        limit: Option<::std::num::NonZeroU64>,
        profile_id: Option<&'a types::ProfileToken>,
        sort: Option<types::ListAllChargebacksSort>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListAllChargebacksResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/chargebacks", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("embed", &embed))
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "profileId",
                &profile_id,
            ))
            .query(&progenitor_client::QueryParam::new("sort", &sort))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_all_chargebacks",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List captures
    ///
    ///Retrieve a list of all captures created for a specific payment.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/payments/{paymentId}/captures`
    ///
    ///Arguments:
    /// - `payment_id`: Provide the ID of the related payment.
    /// - `embed`: This endpoint allows embedding related API items by appending
    ///   the following values via the `embed` query string
    ///parameter.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_captures<'a>(
        &'a self,
        payment_id: &'a types::PaymentToken,
        embed: Option<&'a str>,
        from: Option<&'a types::CaptureToken>,
        limit: Option<::std::num::NonZeroU64>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListCapturesResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payments/{}/captures",
            self.baseurl,
            encode_path(&payment_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("embed", &embed))
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_captures",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create capture
    ///
    ///Capture an *authorized* payment.
    ///
    ///Some payment methods allow you to first collect a customer's
    /// authorization, and capture the amount at a later point.
    ///
    ///By default, Mollie captures payments automatically. If however you
    ///configured your payment with `captureMode: manual`, you can capture the
    /// payment using this endpoint after having collected the customer's
    /// authorization.
    ///
    ///Sends a `POST` request to `/payments/{paymentId}/captures`
    ///
    ///Arguments:
    /// - `payment_id`: Provide the ID of the related payment.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn create_capture<'a>(
        &'a self,
        payment_id: &'a types::PaymentToken,
        idempotency_key: Option<&'a str>,
        body: &'a types::EntityCapture,
    ) -> Result<ResponseValue<types::CaptureResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payments/{}/captures",
            self.baseurl,
            encode_path(&payment_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_capture",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get capture
    ///
    ///Retrieve a single payment capture by its ID and the ID of its parent
    ///payment.
    ///
    ///Sends a `GET` request to `/payments/{paymentId}/captures/{captureId}`
    ///
    ///Arguments:
    /// - `payment_id`: Provide the ID of the related payment.
    /// - `capture_id`: Provide the ID of the related capture.
    /// - `embed`: This endpoint allows embedding related API items by appending
    ///   the following values via the `embed` query string
    ///parameter.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_capture<'a>(
        &'a self,
        payment_id: &'a types::PaymentToken,
        capture_id: &'a str,
        embed: Option<&'a str>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::CaptureResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payments/{}/captures/{}",
            self.baseurl,
            encode_path(&payment_id.to_string()),
            encode_path(&capture_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("embed", &embed))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_capture",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Request Apple Pay payment session
    ///
    ///When integrating Apple Pay in your own checkout on the web, you need to
    ///[provide merchant validation](https://developer.apple.com/documentation/apple_pay_on_the_web/apple_pay_js_api/providing_merchant_validation).
    ///This is normally done using Apple's
    ///[Requesting an Apple Pay Session](https://developer.apple.com/documentation/apple_pay_on_the_web/apple_pay_js_api/requesting_an_apple_pay_payment_session).
    ///The merchant validation proves to Apple that a validated merchant is
    /// calling the Apple Pay Javascript APIs.
    ///
    ///To integrate Apple Pay via Mollie, you will have to call the Mollie API
    /// instead of Apple's API. The response of this API call can then be
    /// passed as-is to the completion method, `completeMerchantValidation`.
    ///
    ///Before requesting an Apple Pay Payment Session, you must place the
    /// domain validation file on your server at: `https://[domain]/.well-known/apple-developer-merchantid-domain-association`. Without this file, it will not be
    ///possible to use Apple Pay on your domain.
    ///
    ///Each new transaction requires a new payment session object. Merchant
    /// session objects are not reusable, and they expire after five
    /// minutes.
    ///
    ///Payment sessions cannot be requested directly from the browser. The
    /// request must be sent from your server. For the full documentation,
    /// see the official [Apple Pay JS API](https://developer.apple.com/documentation/apple_pay_on_the_web/apple_pay_js_api) documentation.
    ///
    ///Sends a `POST` request to `/wallets/applepay/sessions`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn request_apple_pay_payment_session<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        body: &'a types::RequestApplePayPaymentSessionBody,
    ) -> Result<ResponseValue<types::EntitySession>, Error<types::ErrorResponse>> {
        let url = format!("{}/wallets/applepay/sessions", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "request_apple_pay_payment_session",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List payment links
    ///
    ///Retrieve a list of all payment links.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/payment-links`
    ///
    ///Arguments:
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_payment_links<'a>(
        &'a self,
        from: Option<&'a types::PaymentLinkToken>,
        limit: Option<::std::num::NonZeroU64>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListPaymentLinksResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/payment-links", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_payment_links",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create payment link
    ///
    ///With the Payment links API you can generate payment links that by
    /// default, unlike regular payments, do not expire. The payment link
    /// can be shared with your customers and will redirect them to them the
    /// payment page where they can complete the payment. A
    /// [payment](get-payment) will only be created once the customer initiates
    /// the payment.
    ///
    ///Sends a `POST` request to `/payment-links`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn create_payment_link<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        body: &'a types::CreatePaymentLinkBody,
    ) -> Result<ResponseValue<types::PaymentLinkResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/payment-links", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_payment_link",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get payment link
    ///
    ///Retrieve a single payment link by its ID.
    ///
    ///Sends a `GET` request to `/payment-links/{paymentLinkId}`
    ///
    ///Arguments:
    /// - `payment_link_id`: Provide the ID of the related payment link.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_payment_link<'a>(
        &'a self,
        payment_link_id: &'a types::PaymentLinkToken,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::PaymentLinkResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payment-links/{}",
            self.baseurl,
            encode_path(&payment_link_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_payment_link",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete payment link
    ///
    ///Payment links which have not been opened and no payments have been made
    /// yet can be deleted entirely. This can be useful for removing payment
    /// links that have been incorrectly configured or that are no longer
    /// relevant.
    ///
    ///Once deleted, the payment link will no longer show up in the API or
    /// Mollie dashboard.
    ///
    ///To simply disable a payment link without fully deleting it, you can use
    /// the `archived` parameter on the [Update payment
    /// link](update-payment-link) endpoint instead.
    ///
    ///Sends a `DELETE` request to `/payment-links/{paymentLinkId}`
    ///
    ///Arguments:
    /// - `payment_link_id`: Provide the ID of the related payment link.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn delete_payment_link<'a>(
        &'a self,
        payment_link_id: &'a types::PaymentLinkToken,
        idempotency_key: Option<&'a str>,
        body: &'a types::DeletePaymentLinkBody,
    ) -> Result<ResponseValue<::serde_json::Value>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payment-links/{}",
            self.baseurl,
            encode_path(&payment_link_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_payment_link",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update payment link
    ///
    ///Certain details of an existing payment link can be updated.
    ///
    ///Sends a `PATCH` request to `/payment-links/{paymentLinkId}`
    ///
    ///Arguments:
    /// - `payment_link_id`: Provide the ID of the related payment link.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn update_payment_link<'a>(
        &'a self,
        payment_link_id: &'a types::PaymentLinkToken,
        idempotency_key: Option<&'a str>,
        body: &'a types::UpdatePaymentLinkBody,
    ) -> Result<ResponseValue<types::PaymentLinkResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payment-links/{}",
            self.baseurl,
            encode_path(&payment_link_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_payment_link",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get payment link payments
    ///
    ///Retrieve the list of payments for a specific payment link.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/payment-links/{paymentLinkId}/payments`
    ///
    ///Arguments:
    /// - `payment_link_id`: Provide the ID of the related payment link.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `sort`: Used for setting the direction of the result set. Defaults to
    ///   descending order, meaning the results are ordered from
    ///newest to oldest.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_payment_link_payments<'a>(
        &'a self,
        payment_link_id: &'a types::PaymentLinkToken,
        from: Option<&'a types::PaymentToken>,
        limit: Option<::std::num::NonZeroU64>,
        sort: Option<types::GetPaymentLinkPaymentsSort>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::GetPaymentLinkPaymentsResponse>, Error<types::ErrorResponse>>
    {
        let url = format!(
            "{}/payment-links/{}/payments",
            self.baseurl,
            encode_path(&payment_link_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("sort", &sort))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_payment_link_payments",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List terminals
    ///
    ///Retrieve a list of all physical point-of-sale devices.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/terminals`
    ///
    ///Arguments:
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `sort`: Used for setting the direction of the result set. Defaults to
    ///   descending order, meaning the results are ordered from
    ///newest to oldest.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_terminals<'a>(
        &'a self,
        from: Option<&'a types::TerminalToken>,
        limit: Option<::std::num::NonZeroU64>,
        sort: Option<types::ListTerminalsSort>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListTerminalsResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/terminals", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("sort", &sort))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_terminals",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get terminal
    ///
    ///Retrieve a single terminal by its ID.
    ///
    ///Sends a `GET` request to `/terminals/{terminalId}`
    ///
    ///Arguments:
    /// - `terminal_id`: Provide the ID of the related terminal.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_terminal<'a>(
        &'a self,
        terminal_id: &'a types::TerminalToken,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntityTerminal>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/terminals/{}",
            self.baseurl,
            encode_path(&terminal_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_terminal",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List payment routes
    ///
    ///Retrieve a list of all routes created for a specific payment.
    ///
    ///Sends a `GET` request to `/payments/{paymentId}/routes`
    ///
    ///Arguments:
    /// - `payment_id`: Provide the ID of the related payment.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn payment_list_routes<'a>(
        &'a self,
        payment_id: &'a types::PaymentToken,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::PaymentListRoutesResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payments/{}/routes",
            self.baseurl,
            encode_path(&payment_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "payment_list_routes",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create a delayed route
    ///
    ///Create a route for a specific payment.
    ///The routed amount is credited to the account of your customer.
    ///
    ///Sends a `POST` request to `/payments/{paymentId}/routes`
    ///
    ///Arguments:
    /// - `payment_id`: Provide the ID of the related payment.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn payment_create_route<'a>(
        &'a self,
        payment_id: &'a types::PaymentToken,
        idempotency_key: Option<&'a str>,
        body: &'a types::RouteCreateRequest,
    ) -> Result<ResponseValue<types::RouteCreateResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/payments/{}/routes",
            self.baseurl,
            encode_path(&payment_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "payment_create_route",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List customers
    ///
    ///Retrieve a list of all customers.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/customers`
    ///
    ///Arguments:
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `sort`: Used for setting the direction of the result set. Defaults to
    ///   descending order, meaning the results are ordered from
    ///newest to oldest.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_customers<'a>(
        &'a self,
        from: Option<&'a types::CustomerToken>,
        limit: Option<::std::num::NonZeroU64>,
        sort: Option<types::ListCustomersSort>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListCustomersResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/customers", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("sort", &sort))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_customers",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create customer
    ///
    ///Creates a simple minimal representation of a customer. Payments,
    /// recurring mandates, and subscriptions can be linked to this customer
    /// object, which simplifies management of recurring payments.
    ///
    ///Once registered, customers will also appear in your Mollie dashboard.
    ///
    ///Sends a `POST` request to `/customers`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn create_customer<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        body: &'a types::EntityCustomer,
    ) -> Result<ResponseValue<types::CustomerResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/customers", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_customer",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get customer
    ///
    ///Retrieve a single customer by its ID.
    ///
    ///Sends a `GET` request to `/customers/{customerId}`
    ///
    ///Arguments:
    /// - `customer_id`: Provide the ID of the related customer.
    /// - `include`: This endpoint allows you to include additional information
    ///   via the `include` query string parameter.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_customer<'a>(
        &'a self,
        customer_id: &'a types::CustomerToken,
        include: Option<&'a str>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::GetCustomerResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/customers/{}",
            self.baseurl,
            encode_path(&customer_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("include", &include))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_customer",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete customer
    ///
    ///Delete a customer. All mandates and subscriptions created for this
    /// customer will be canceled as well.
    ///
    ///Sends a `DELETE` request to `/customers/{customerId}`
    ///
    ///Arguments:
    /// - `customer_id`: Provide the ID of the related customer.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn delete_customer<'a>(
        &'a self,
        customer_id: &'a types::CustomerToken,
        idempotency_key: Option<&'a str>,
        body: &'a types::DeleteCustomerBody,
    ) -> Result<ResponseValue<::serde_json::Value>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/customers/{}",
            self.baseurl,
            encode_path(&customer_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_customer",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update customer
    ///
    ///Update an existing customer.
    ///
    ///For an in-depth explanation of each parameter, refer to the [Create
    /// customer](create-customer) endpoint.
    ///
    ///Sends a `PATCH` request to `/customers/{customerId}`
    ///
    ///Arguments:
    /// - `customer_id`: Provide the ID of the related customer.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn update_customer<'a>(
        &'a self,
        customer_id: &'a types::CustomerToken,
        idempotency_key: Option<&'a str>,
        body: &'a types::EntityCustomer,
    ) -> Result<ResponseValue<types::CustomerResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/customers/{}",
            self.baseurl,
            encode_path(&customer_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_customer",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List customer payments
    ///
    ///Retrieve all payments linked to the customer.
    ///
    ///Sends a `GET` request to `/customers/{customerId}/payments`
    ///
    ///Arguments:
    /// - `customer_id`: Provide the ID of the related customer.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate
    ///the result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `profile_id`: The identifier referring to the [profile](get-profile)
    ///   you wish to
    ///retrieve the resources for.
    ///
    ///Most API credentials are linked to a single profile. In these cases the
    /// `profileId` can be omitted. For organization-level credentials such
    /// as OAuth access tokens however, the `profileId` parameter is required.
    /// - `sort`: Used for setting the direction of the result set. Defaults to
    ///   descending order, meaning the results are ordered from
    ///newest to oldest.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_customer_payments<'a>(
        &'a self,
        customer_id: &'a types::CustomerToken,
        from: Option<&'a types::PaymentToken>,
        limit: Option<::std::num::NonZeroU64>,
        profile_id: Option<&'a types::ProfileToken>,
        sort: Option<types::ListCustomerPaymentsSort>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListCustomerPaymentsResponse>, Error<types::ErrorResponse>>
    {
        let url = format!(
            "{}/customers/{}/payments",
            self.baseurl,
            encode_path(&customer_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "profileId",
                &profile_id,
            ))
            .query(&progenitor_client::QueryParam::new("sort", &sort))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_customer_payments",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create customer payment
    ///
    ///Creates a payment for the customer.
    ///
    ///Linking customers to payments enables you to:
    ///
    /// * Keep track of payment preferences for your customers
    /// * Allow your customers to charge a previously used credit card with a
    ///   single click in our hosted checkout
    /// * Improve payment insights in the Mollie dashboard
    /// * Use recurring payments
    ///
    ///This endpoint is effectively an alias of the [Create payment
    /// endpoint](create-payment) with the `customerId`
    /// parameter predefined.
    ///
    ///Sends a `POST` request to `/customers/{customerId}/payments`
    ///
    ///Arguments:
    /// - `customer_id`: Provide the ID of the related customer.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn create_customer_payment<'a>(
        &'a self,
        customer_id: &'a types::CustomerToken,
        idempotency_key: Option<&'a str>,
        body: &'a types::PaymentRequest,
    ) -> Result<ResponseValue<types::PaymentResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/customers/{}/payments",
            self.baseurl,
            encode_path(&customer_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_customer_payment",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            503u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List mandates
    ///
    ///Retrieve a list of all mandates.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/customers/{customerId}/mandates`
    ///
    ///Arguments:
    /// - `customer_id`: Provide the ID of the related customer.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `sort`: Used for setting the direction of the result set. Defaults to
    ///   descending order, meaning the results are ordered from
    ///newest to oldest.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_mandates<'a>(
        &'a self,
        customer_id: &'a types::CustomerToken,
        from: Option<&'a types::MandateToken>,
        limit: Option<::std::num::NonZeroU64>,
        sort: Option<types::ListMandatesSort>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListMandatesResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/customers/{}/mandates",
            self.baseurl,
            encode_path(&customer_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("sort", &sort))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_mandates",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create mandate
    ///
    ///Create a mandate for a specific customer. Mandates allow you to charge a
    /// customer's card, PayPal account or bank account recurrently.
    ///
    ///It is only possible to create mandates for IBANs and PayPal billing
    /// agreements with this endpoint. To create mandates for cards, your
    /// customers need to perform a 'first payment' with their card.
    ///
    ///Sends a `POST` request to `/customers/{customerId}/mandates`
    ///
    ///Arguments:
    /// - `customer_id`: Provide the ID of the related customer.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn create_mandate<'a>(
        &'a self,
        customer_id: &'a types::CustomerToken,
        idempotency_key: Option<&'a str>,
        body: &'a types::MandateRequest,
    ) -> Result<ResponseValue<types::MandateResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/customers/{}/mandates",
            self.baseurl,
            encode_path(&customer_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_mandate",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get mandate
    ///
    ///Retrieve a single mandate by its ID. Depending on the type of mandate,
    /// the object will contain the customer's bank account details, card
    /// details, or PayPal account details.
    ///
    ///Sends a `GET` request to `/customers/{customerId}/mandates/{mandateId}`
    ///
    ///Arguments:
    /// - `customer_id`: Provide the ID of the related customer.
    /// - `mandate_id`: Provide the ID of the related mandate.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_mandate<'a>(
        &'a self,
        customer_id: &'a types::CustomerToken,
        mandate_id: &'a types::MandateToken,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::MandateResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/customers/{}/mandates/{}",
            self.baseurl,
            encode_path(&customer_id.to_string()),
            encode_path(&mandate_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_mandate",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Revoke mandate
    ///
    ///Revoke a customer's mandate. You will no longer be able to charge the
    /// customer's bank account or card with this mandate, and all connected
    /// subscriptions will be canceled.
    ///
    ///Sends a `DELETE` request to
    /// `/customers/{customerId}/mandates/{mandateId}`
    ///
    ///Arguments:
    /// - `customer_id`: Provide the ID of the related customer.
    /// - `mandate_id`: Provide the ID of the related mandate.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn revoke_mandate<'a>(
        &'a self,
        customer_id: &'a types::CustomerToken,
        mandate_id: &'a types::MandateToken,
        idempotency_key: Option<&'a str>,
        body: &'a types::RevokeMandateBody,
    ) -> Result<ResponseValue<::serde_json::Value>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/customers/{}/mandates/{}",
            self.baseurl,
            encode_path(&customer_id.to_string()),
            encode_path(&mandate_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "revoke_mandate",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List customer subscriptions
    ///
    ///Retrieve all subscriptions of a customer.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/customers/{customerId}/subscriptions`
    ///
    ///Arguments:
    /// - `customer_id`: Provide the ID of the related customer.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `sort`: Used for setting the direction of the result set. Defaults to
    ///   descending order, meaning the results are ordered from
    ///newest to oldest.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_subscriptions<'a>(
        &'a self,
        customer_id: &'a types::CustomerToken,
        from: Option<&'a types::SubscriptionToken>,
        limit: Option<::std::num::NonZeroU64>,
        sort: Option<types::ListSubscriptionsSort>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListSubscriptionsResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/customers/{}/subscriptions",
            self.baseurl,
            encode_path(&customer_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("sort", &sort))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_subscriptions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create subscription
    ///
    ///With subscriptions, you can schedule recurring payments to take place at
    /// regular intervals.
    ///
    ///For example, by simply specifying an `amount` and an `interval`, you can
    /// create an endless subscription to charge a monthly fee, until you
    /// cancel the subscription.
    ///
    ///Or, you could use the times parameter to only charge a limited number of
    /// times, for example to split a big transaction in multiple parts.
    ///
    ///A few example usages:
    ///
    ///`amount[currency]="EUR"` `amount[value]="5.00"` `interval="2 weeks"`
    ///Your customer will be charged €5 once every two weeks.
    ///
    ///`amount[currency]="EUR"` `amount[value]="20.00"` `interval="1 day"
    /// times=5` Your customer will be charged €20 every day, for five
    /// consecutive days.
    ///
    ///`amount[currency]="EUR"` `amount[value]="10.00"` `interval="1 month"`
    ///`startDate="2018-04-30"`
    ///Your customer will be charged €10 on the last day of each month,
    /// starting in April 2018.
    ///
    ///Sends a `POST` request to `/customers/{customerId}/subscriptions`
    ///
    ///Arguments:
    /// - `customer_id`: Provide the ID of the related customer.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn create_subscription<'a>(
        &'a self,
        customer_id: &'a types::CustomerToken,
        idempotency_key: Option<&'a str>,
        body: &'a types::SubscriptionRequest,
    ) -> Result<ResponseValue<types::SubscriptionResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/customers/{}/subscriptions",
            self.baseurl,
            encode_path(&customer_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_subscription",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get subscription
    ///
    ///Retrieve a single subscription by its ID and the ID of its parent
    /// customer.
    ///
    ///Sends a `GET` request to
    /// `/customers/{customerId}/subscriptions/{subscriptionId}`
    ///
    ///Arguments:
    /// - `customer_id`: Provide the ID of the related customer.
    /// - `subscription_id`: Provide the ID of the related subscription.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_subscription<'a>(
        &'a self,
        customer_id: &'a types::CustomerToken,
        subscription_id: &'a types::SubscriptionToken,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::SubscriptionResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/customers/{}/subscriptions/{}",
            self.baseurl,
            encode_path(&customer_id.to_string()),
            encode_path(&subscription_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_subscription",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Cancel subscription
    ///
    ///Cancel an existing subscription. Canceling a subscription has no effect
    /// on the mandates of the customer.
    ///
    ///Sends a `DELETE` request to
    /// `/customers/{customerId}/subscriptions/{subscriptionId}`
    ///
    ///Arguments:
    /// - `customer_id`: Provide the ID of the related customer.
    /// - `subscription_id`: Provide the ID of the related subscription.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn cancel_subscription<'a>(
        &'a self,
        customer_id: &'a types::CustomerToken,
        subscription_id: &'a types::SubscriptionToken,
        idempotency_key: Option<&'a str>,
        body: &'a types::CancelSubscriptionBody,
    ) -> Result<ResponseValue<types::SubscriptionResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/customers/{}/subscriptions/{}",
            self.baseurl,
            encode_path(&customer_id.to_string()),
            encode_path(&subscription_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "cancel_subscription",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update subscription
    ///
    ///Update an existing subscription.
    ///
    ///Canceled subscriptions cannot be updated.
    ///
    ///For an in-depth explanation of each parameter, refer to the [Create
    /// subscription](create-subscription) endpoint.
    ///
    ///Sends a `PATCH` request to
    /// `/customers/{customerId}/subscriptions/{subscriptionId}`
    ///
    ///Arguments:
    /// - `customer_id`: Provide the ID of the related customer.
    /// - `subscription_id`: Provide the ID of the related subscription.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn update_subscription<'a>(
        &'a self,
        customer_id: &'a types::CustomerToken,
        subscription_id: &'a types::SubscriptionToken,
        idempotency_key: Option<&'a str>,
        body: &'a types::UpdateSubscriptionBody,
    ) -> Result<ResponseValue<types::SubscriptionResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/customers/{}/subscriptions/{}",
            self.baseurl,
            encode_path(&customer_id.to_string()),
            encode_path(&subscription_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_subscription",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List all subscriptions
    ///
    ///Retrieve all subscriptions initiated across all your customers.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/subscriptions`
    ///
    ///Arguments:
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `profile_id`: The identifier referring to the [profile](get-profile)
    ///   you wish to retrieve subscriptions for.
    ///
    ///Most API credentials are linked to a single profile. In these cases the
    /// `profileId` is already implied.
    ///
    ///To retrieve all subscriptions across the organization, use an
    /// organization-level API credential and omit the `profileId`
    /// parameter.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_all_subscriptions<'a>(
        &'a self,
        from: Option<&'a str>,
        limit: Option<::std::num::NonZeroU64>,
        profile_id: Option<&'a str>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListAllSubscriptionsResponse>, Error<types::ErrorResponse>>
    {
        let url = format!("{}/subscriptions", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "profileId",
                &profile_id,
            ))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_all_subscriptions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List subscription payments
    ///
    ///Retrieve all payments of a specific subscription.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to
    /// `/customers/{customerId}/subscriptions/{subscriptionId}/payments`
    ///
    ///Arguments:
    /// - `customer_id`: Provide the ID of the related customer.
    /// - `subscription_id`: Provide the ID of the related subscription.
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate
    ///the result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `profile_id`: The identifier referring to the [profile](get-profile)
    ///   you wish to
    ///retrieve the resources for.
    ///
    ///Most API credentials are linked to a single profile. In these cases the
    /// `profileId` can be omitted. For organization-level credentials such
    /// as OAuth access tokens however, the `profileId` parameter is required.
    /// - `sort`: Used for setting the direction of the result set. Defaults to
    ///   descending order, meaning the results are ordered from
    ///newest to oldest.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_subscription_payments<'a>(
        &'a self,
        customer_id: &'a types::CustomerToken,
        subscription_id: &'a types::SubscriptionToken,
        from: Option<&'a types::PaymentToken>,
        limit: Option<::std::num::NonZeroU64>,
        profile_id: Option<&'a types::ProfileToken>,
        sort: Option<types::ListSubscriptionPaymentsSort>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListSubscriptionPaymentsResponse>, Error<types::ErrorResponse>>
    {
        let url = format!(
            "{}/customers/{}/subscriptions/{}/payments",
            self.baseurl,
            encode_path(&customer_id.to_string()),
            encode_path(&subscription_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "profileId",
                &profile_id,
            ))
            .query(&progenitor_client::QueryParam::new("sort", &sort))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_subscription_payments",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List sales invoices
    ///
    /// > 🚧 Beta feature
    ///>
    /// > This feature is currently in beta testing, and the final specification
    /// > may still change.
    ///
    ///Retrieve a list of all sales invoices created through the API.
    ///
    ///The results are paginated.
    ///
    ///Sends a `GET` request to `/sales-invoices`
    ///
    ///Arguments:
    /// - `from`: Provide an ID to start the result set from the item with the
    ///   given ID and onwards. This allows you to paginate the
    ///result set.
    /// - `limit`: The maximum number of items to return. Defaults to 50 items.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn list_sales_invoices<'a>(
        &'a self,
        from: Option<&'a str>,
        limit: Option<::std::num::NonZeroU64>,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::ListSalesInvoicesResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/sales-invoices", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from", &from))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_sales_invoices",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create sales invoice
    ///
    /// > 🚧 Beta feature
    ///>
    /// > This feature is currently in beta testing, and the final specification
    /// > may still change.
    ///
    ///With the Sales Invoice API you can generate sales invoices to send to
    /// your customers.
    ///
    ///Sends a `POST` request to `/sales-invoices`
    ///
    ///Arguments:
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn create_sales_invoice<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        body: &'a types::EntitySalesInvoice,
    ) -> Result<ResponseValue<types::EntitySalesInvoiceResponse>, Error<types::ErrorResponse>> {
        let url = format!("{}/sales-invoices", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_sales_invoice",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get sales invoice
    ///
    /// > 🚧 Beta feature
    ///>
    /// > This feature is currently in beta testing, and the final specification
    /// > may still change.
    ///
    ///Retrieve a single sales invoice by its ID.
    ///
    ///Sends a `GET` request to `/sales-invoices/{id}`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `testmode`: Most API credentials are specifically created for either
    ///   live mode or test mode. In those cases the `testmode` query
    ///parameter can be omitted. For organization-level credentials such as
    /// OAuth access tokens, you can enable test mode by setting the
    /// `testmode` query parameter to `true`.
    ///
    ///Test entities cannot be retrieved when the endpoint is set to live mode,
    /// and vice versa.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    pub async fn get_sales_invoice<'a>(
        &'a self,
        id: &'a str,
        testmode: Option<bool>,
        idempotency_key: Option<&'a str>,
    ) -> Result<ResponseValue<types::EntitySalesInvoiceResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/sales-invoices/{}",
            self.baseurl,
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("testmode", &testmode))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_sales_invoice",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete sales invoice
    ///
    /// > 🚧 Beta feature
    ///>
    /// > This feature is currently in beta testing, and the final specification
    /// > may still change.
    ///
    ///Sales invoices which are in status `draft` can be deleted. For all other
    /// statuses, please use the [Update sales
    /// invoice](update-sales-invoice) endpoint instead.
    ///
    ///Sends a `DELETE` request to `/sales-invoices/{id}`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn delete_sales_invoice<'a>(
        &'a self,
        id: &'a str,
        idempotency_key: Option<&'a str>,
        body: &'a types::DeleteValuesSalesInvoice,
    ) -> Result<ResponseValue<::serde_json::Value>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/sales-invoices/{}",
            self.baseurl,
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_sales_invoice",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update sales invoice
    ///
    /// > 🚧 Beta feature
    ///>
    /// > This feature is currently in beta testing, and the final specification
    /// > may still change.
    ///
    ///Certain details of an existing sales invoice can be updated. For `draft`
    /// it is all values listed below, but for statuses `paid` and `issued`
    /// there are certain additional requirements (`paymentDetails` and
    /// `emailDetails`, respectively).
    ///
    ///Sends a `PATCH` request to `/sales-invoices/{id}`
    ///
    ///Arguments:
    /// - `id`: Provide the ID of the item you want to perform this operation
    ///   on.
    /// - `idempotency_key`: A unique key to ensure idempotent requests. This
    ///   key should be a UUID v4 string.
    /// - `body`
    pub async fn update_sales_invoice<'a>(
        &'a self,
        id: &'a str,
        idempotency_key: Option<&'a str>,
        body: &'a types::UpdateValuesSalesInvoice,
    ) -> Result<ResponseValue<types::EntitySalesInvoiceResponse>, Error<types::ErrorResponse>> {
        let url = format!(
            "{}/sales-invoices/{}",
            self.baseurl,
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = idempotency_key {
            header_map.append("idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_sales_invoice",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
}

/// Items consumers will typically use such as the Client.
pub mod prelude {
    #[allow(unused_imports)]
    pub use super::Client;
}
